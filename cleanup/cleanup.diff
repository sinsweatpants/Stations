diff --git a/backup_20251003_052813/package.json b/backup_20251003_052813/package.json
deleted file mode 100644
index 628505b..0000000
--- a/backup_20251003_052813/package.json
+++ /dev/null
@@ -1,131 +0,0 @@
-{
-  "name": "rest-express",
-  "version": "1.0.0",
-  "type": "module",
-  "license": "MIT",
-  "scripts": {
-    "dev": "NODE_ENV=development tsx server/index.ts",
-    "build": "vite build && esbuild server/index.ts --platform=node --packages=external --bundle --format=esm --outdir=dist",
-    "start": "NODE_ENV=production node dist/index.js",
-    "check": "tsc",
-    "db:push": "drizzle-kit push",
-    "lint": "eslint . --ext .ts,.tsx",
-    "lint:fix": "eslint . --ext .ts,.tsx --fix",
-    "format": "prettier --write \"**/*.{ts,tsx,js,jsx,json,css,md}\"",
-    "format:check": "prettier --check \"**/*.{ts,tsx,js,jsx,json,css,md}\"",
-    "docker:build": "docker build -t stations-app .",
-    "docker:run": "docker run -p 5000:5000 --env-file .env stations-app",
-    "docker:compose": "docker-compose up",
-    "test": "vitest run"
-  },
-  "dependencies": {
-    "@google/generative-ai": "^0.24.1",
-    "@hookform/resolvers": "^3.10.0",
-    "@jridgewell/trace-mapping": "^0.3.25",
-    "@neondatabase/serverless": "^0.10.4",
-    "@radix-ui/react-accordion": "^1.2.4",
-    "@radix-ui/react-alert-dialog": "^1.1.7",
-    "@radix-ui/react-aspect-ratio": "^1.1.3",
-    "@radix-ui/react-avatar": "^1.1.4",
-    "@radix-ui/react-checkbox": "^1.1.5",
-    "@radix-ui/react-collapsible": "^1.1.4",
-    "@radix-ui/react-context-menu": "^2.2.7",
-    "@radix-ui/react-dialog": "^1.1.7",
-    "@radix-ui/react-dropdown-menu": "^2.1.7",
-    "@radix-ui/react-hover-card": "^1.1.7",
-    "@radix-ui/react-label": "^2.1.3",
-    "@radix-ui/react-menubar": "^1.1.7",
-    "@radix-ui/react-navigation-menu": "^1.2.6",
-    "@radix-ui/react-popover": "^1.1.7",
-    "@radix-ui/react-progress": "^1.1.3",
-    "@radix-ui/react-radio-group": "^1.2.4",
-    "@radix-ui/react-scroll-area": "^1.2.4",
-    "@radix-ui/react-select": "^2.1.7",
-    "@radix-ui/react-separator": "^1.1.3",
-    "@radix-ui/react-slider": "^1.2.4",
-    "@radix-ui/react-slot": "^1.2.0",
-    "@radix-ui/react-switch": "^1.1.4",
-    "@radix-ui/react-tabs": "^1.1.4",
-    "@radix-ui/react-toast": "^1.2.7",
-    "@radix-ui/react-toggle": "^1.1.3",
-    "@radix-ui/react-toggle-group": "^1.1.3",
-    "@radix-ui/react-tooltip": "^1.2.0",
-    "@tanstack/react-query": "^5.60.5",
-    "class-variance-authority": "^0.7.1",
-    "clsx": "^2.1.1",
-    "cmdk": "^1.1.1",
-    "connect-pg-simple": "^10.0.0",
-    "cors": "^2.8.5",
-    "date-fns": "^3.6.0",
-    "dotenv": "^17.2.3",
-    "drizzle-orm": "^0.39.1",
-    "drizzle-zod": "^0.7.0",
-    "embla-carousel-react": "^8.6.0",
-    "express": "^4.21.2",
-    "express-rate-limit": "^8.1.0",
-    "express-session": "^1.18.1",
-    "framer-motion": "^11.13.1",
-    "helmet": "^8.1.0",
-    "input-otp": "^1.4.2",
-    "lucide-react": "^0.453.0",
-    "memorystore": "^1.6.7",
-    "morgan": "^1.10.1",
-    "next-themes": "^0.4.6",
-    "passport": "^0.7.0",
-    "passport-local": "^1.0.0",
-    "react": "^18.3.1",
-    "react-day-picker": "^8.10.1",
-    "react-dom": "^18.3.1",
-    "react-hook-form": "^7.55.0",
-    "react-icons": "^5.4.0",
-    "react-resizable-panels": "^2.1.7",
-    "recharts": "^2.15.2",
-    "tailwind-merge": "^2.6.0",
-    "tailwindcss-animate": "^1.0.7",
-    "tw-animate-css": "^1.2.5",
-    "vaul": "^1.1.2",
-    "winston": "^3.18.3",
-    "wouter": "^3.3.5",
-    "ws": "^8.18.0",
-    "zod": "^3.24.2",
-    "zod-validation-error": "^3.4.0"
-  },
-  "devDependencies": {
-    "@replit/vite-plugin-cartographer": "^0.3.1",
-    "@replit/vite-plugin-dev-banner": "^0.1.1",
-    "@replit/vite-plugin-runtime-error-modal": "^0.0.3",
-    "@tailwindcss/typography": "^0.5.15",
-    "@tailwindcss/vite": "^4.1.3",
-    "@types/connect-pg-simple": "^7.0.3",
-    "@types/cors": "^2.8.19",
-    "@types/express": "4.17.21",
-    "@types/express-rate-limit": "^5.1.3",
-    "@types/express-session": "^1.18.0",
-    "@types/morgan": "^1.9.10",
-    "@types/node": "20.16.11",
-    "@types/passport": "^1.0.16",
-    "@types/passport-local": "^1.0.38",
-    "@types/react": "^18.3.11",
-    "@types/react-dom": "^18.3.1",
-    "@types/ws": "^8.5.13",
-    "@typescript-eslint/eslint-plugin": "^8.45.0",
-    "@typescript-eslint/parser": "^8.45.0",
-    "@vitejs/plugin-react": "^4.7.0",
-    "autoprefixer": "^10.4.20",
-    "drizzle-kit": "^0.31.4",
-    "esbuild": "^0.25.0",
-    "eslint": "^9.36.0",
-    "eslint-config-prettier": "^10.1.8",
-    "jsdom": "^27.0.0",
-    "postcss": "^8.4.47",
-    "prettier": "^3.6.2",
-    "tailwindcss": "^3.4.17",
-    "tsx": "^4.20.5",
-    "typescript": "5.6.3",
-    "vite": "^5.4.20",
-    "vitest": "^2.1.5"
-  },
-  "optionalDependencies": {
-    "bufferutil": "^4.0.8"
-  }
-}
diff --git a/backup_20251003_052813/server/analysis_modules/efficiency-metrics.ts b/backup_20251003_052813/server/analysis_modules/efficiency-metrics.ts
deleted file mode 100644
index 2bb660e..0000000
--- a/backup_20251003_052813/server/analysis_modules/efficiency-metrics.ts
+++ /dev/null
@@ -1,330 +0,0 @@
-import { ConflictNetwork } from '../core/models/base-entities';
-
-export interface EfficiencyMetrics {
-  overallEfficiencyScore: number;
-  overallRating: 'Excellent' | 'Good' | 'Fair' | 'Poor' | 'Critical';
-  conflictCohesion: number;
-  dramaticBalance: {
-    balanceScore: number;
-    characterInvolvementGini: number;
-  };
-  narrativeEfficiency: {
-    characterEfficiency: number;
-    relationshipEfficiency: number;
-    conflictEfficiency: number;
-  };
-  narrativeDensity: number;
-  redundancyMetrics: {
-    characterRedundancy: number;
-    relationshipRedundancy: number;
-    conflictRedundancy: number;
-  };
-}
-
-export class EfficiencyAnalyzer {
-  
-  calculateEfficiencyMetrics(network: ConflictNetwork): EfficiencyMetrics {
-    const conflictCohesion = this.calculateConflictCohesion(network);
-    const dramaticBalance = this.calculateDramaticBalance(network);
-    const narrativeEfficiency = this.calculateNarrativeEfficiency(network);
-    const narrativeDensity = this.calculateNarrativeDensity(network);
-    const redundancyMetrics = this.calculateRedundancyMetrics(network);
-    
-    const overallScore = this.calculateOverallScore({
-      conflictCohesion,
-      dramaticBalance: dramaticBalance.balanceScore,
-      narrativeEfficiency: (narrativeEfficiency.characterEfficiency + 
-                          narrativeEfficiency.relationshipEfficiency + 
-                          narrativeEfficiency.conflictEfficiency) / 3,
-      narrativeDensity,
-      redundancy: 1 - ((redundancyMetrics.characterRedundancy + 
-                       redundancyMetrics.relationshipRedundancy + 
-                       redundancyMetrics.conflictRedundancy) / 3)
-    });
-
-    return {
-      overallEfficiencyScore: overallScore,
-      overallRating: this.getRating(overallScore),
-      conflictCohesion,
-      dramaticBalance,
-      narrativeEfficiency,
-      narrativeDensity,
-      redundancyMetrics
-    };
-  }
-
-  private calculateConflictCohesion(network: ConflictNetwork): number {
-    if (network.conflicts.size === 0) return 0;
-    
-    let totalConnections = 0;
-    let possibleConnections = 0;
-    
-    const conflicts = Array.from(network.conflicts.values());
-    
-    for (let i = 0; i < conflicts.length; i++) {
-      for (let j = i + 1; j < conflicts.length; j++) {
-        possibleConnections++;
-        
-        const conflict1 = conflicts[i];
-        const conflict2 = conflicts[j];
-        
-        // Check if conflicts share characters
-        const sharedCharacters = conflict1.involvedCharacters.filter(
-          char => conflict2.involvedCharacters.includes(char)
-        );
-        
-        if (sharedCharacters.length > 0) {
-          totalConnections++;
-        }
-      }
-    }
-    
-    return possibleConnections > 0 ? totalConnections / possibleConnections : 0;
-  }
-
-  private calculateDramaticBalance(network: ConflictNetwork): {
-    balanceScore: number;
-    characterInvolvementGini: number;
-  } {
-    const characters = Array.from(network.characters.values());
-    const involvementCounts = characters.map(char => {
-      return Array.from(network.conflicts.values()).filter(
-        conflict => conflict.involvedCharacters.includes(char.id)
-      ).length;
-    });
-
-    const giniCoefficient = this.calculateGiniCoefficient(involvementCounts);
-    const balanceScore = 1 - giniCoefficient; // Lower Gini = better balance
-
-    return {
-      balanceScore,
-      characterInvolvementGini: giniCoefficient
-    };
-  }
-
-  private calculateNarrativeEfficiency(network: ConflictNetwork): {
-    characterEfficiency: number;
-    relationshipEfficiency: number;
-    conflictEfficiency: number;
-  } {
-    const characterEfficiency = this.calculateCharacterEfficiency(network);
-    const relationshipEfficiency = this.calculateRelationshipEfficiency(network);
-    const conflictEfficiency = this.calculateConflictEfficiency(network);
-
-    return {
-      characterEfficiency,
-      relationshipEfficiency,
-      conflictEfficiency
-    };
-  }
-
-  private calculateCharacterEfficiency(network: ConflictNetwork): number {
-    if (network.characters.size === 0) return 0;
-    
-    let activeCharacters = 0;
-    
-    for (const character of network.characters.values()) {
-      const isInConflict = Array.from(network.conflicts.values()).some(
-        conflict => conflict.involvedCharacters.includes(character.id)
-      );
-      
-      const hasRelationships = Array.from(network.relationships.values()).some(
-        rel => rel.source === character.id || rel.target === character.id
-      );
-      
-      if (isInConflict || hasRelationships) {
-        activeCharacters++;
-      }
-    }
-    
-    return activeCharacters / network.characters.size;
-  }
-
-  private calculateRelationshipEfficiency(network: ConflictNetwork): number {
-    if (network.relationships.size === 0) return 0;
-    
-    let activeRelationships = 0;
-    
-    for (const relationship of network.relationships.values()) {
-      const isRelevantToConflict = Array.from(network.conflicts.values()).some(
-        conflict => conflict.relatedRelationships.includes(relationship.id)
-      );
-      
-      if (isRelevantToConflict || relationship.strength >= 5) {
-        activeRelationships++;
-      }
-    }
-    
-    return activeRelationships / network.relationships.size;
-  }
-
-  private calculateConflictEfficiency(network: ConflictNetwork): number {
-    if (network.conflicts.size === 0) return 0;
-    
-    let activeConflicts = 0;
-    
-    for (const conflict of network.conflicts.values()) {
-      if (conflict.strength >= 5 && conflict.involvedCharacters.length >= 2) {
-        activeConflicts++;
-      }
-    }
-    
-    return activeConflicts / network.conflicts.size;
-  }
-
-  private calculateNarrativeDensity(network: ConflictNetwork): number {
-    const totalElements = network.characters.size + network.relationships.size + network.conflicts.size;
-    if (totalElements === 0) return 0;
-    
-    const connections = Array.from(network.relationships.values()).length + 
-                       Array.from(network.conflicts.values()).reduce(
-                         (sum, conflict) => sum + conflict.involvedCharacters.length, 0
-                       );
-    
-    return connections / totalElements;
-  }
-
-  private calculateRedundancyMetrics(network: ConflictNetwork): {
-    characterRedundancy: number;
-    relationshipRedundancy: number;
-    conflictRedundancy: number;
-  } {
-    return {
-      characterRedundancy: this.calculateCharacterRedundancy(network),
-      relationshipRedundancy: this.calculateRelationshipRedundancy(network),
-      conflictRedundancy: this.calculateConflictRedundancy(network)
-    };
-  }
-
-  private calculateCharacterRedundancy(network: ConflictNetwork): number {
-    // Simple redundancy check based on similar roles/functions
-    const characters = Array.from(network.characters.values());
-    if (characters.length <= 1) return 0;
-    
-    let redundantPairs = 0;
-    let totalPairs = 0;
-    
-    for (let i = 0; i < characters.length; i++) {
-      for (let j = i + 1; j < characters.length; j++) {
-        totalPairs++;
-        
-        const char1 = characters[i];
-        const char2 = characters[j];
-        
-        // Check if characters have similar narrative functions
-        if (char1.description === char2.description) {
-          redundantPairs++;
-        }
-      }
-    }
-    
-    return totalPairs > 0 ? redundantPairs / totalPairs : 0;
-  }
-
-  private calculateRelationshipRedundancy(network: ConflictNetwork): number {
-    const relationships = Array.from(network.relationships.values());
-    if (relationships.length <= 1) return 0;
-    
-    let redundantPairs = 0;
-    let totalPairs = 0;
-    
-    for (let i = 0; i < relationships.length; i++) {
-      for (let j = i + 1; j < relationships.length; j++) {
-        totalPairs++;
-        
-        const rel1 = relationships[i];
-        const rel2 = relationships[j];
-        
-        // Check for duplicate relationships
-        if ((rel1.source === rel2.source && rel1.target === rel2.target) ||
-            (rel1.source === rel2.target && rel1.target === rel2.source)) {
-          if (rel1.type === rel2.type) {
-            redundantPairs++;
-          }
-        }
-      }
-    }
-    
-    return totalPairs > 0 ? redundantPairs / totalPairs : 0;
-  }
-
-  private calculateConflictRedundancy(network: ConflictNetwork): number {
-    const conflicts = Array.from(network.conflicts.values());
-    if (conflicts.length <= 1) return 0;
-    
-    let redundantPairs = 0;
-    let totalPairs = 0;
-    
-    for (let i = 0; i < conflicts.length; i++) {
-      for (let j = i + 1; j < conflicts.length; j++) {
-        totalPairs++;
-        
-        const conflict1 = conflicts[i];
-        const conflict2 = conflicts[j];
-        
-        // Check for similar conflicts
-        if (conflict1.subject === conflict2.subject && 
-            conflict1.scope === conflict2.scope) {
-          const sharedCharacters = conflict1.involvedCharacters.filter(
-            char => conflict2.involvedCharacters.includes(char)
-          );
-          
-          if (sharedCharacters.length > 0) {
-            redundantPairs++;
-          }
-        }
-      }
-    }
-    
-    return totalPairs > 0 ? redundantPairs / totalPairs : 0;
-  }
-
-  private calculateGiniCoefficient(values: number[]): number {
-    if (values.length === 0) return 0;
-    
-    const sortedValues = values.sort((a, b) => a - b);
-    const n = sortedValues.length;
-    const sum = sortedValues.reduce((a, b) => a + b, 0);
-    
-    if (sum === 0) return 0;
-    
-    let gini = 0;
-    for (let i = 0; i < n; i++) {
-      gini += (2 * (i + 1) - n - 1) * sortedValues[i];
-    }
-    
-    return gini / (n * sum);
-  }
-
-  private calculateOverallScore(metrics: {
-    conflictCohesion: number;
-    dramaticBalance: number;
-    narrativeEfficiency: number;
-    narrativeDensity: number;
-    redundancy: number;
-  }): number {
-    const weights = {
-      conflictCohesion: 0.25,
-      dramaticBalance: 0.25,
-      narrativeEfficiency: 0.25,
-      narrativeDensity: 0.15,
-      redundancy: 0.10
-    };
-    
-    return (
-      metrics.conflictCohesion * weights.conflictCohesion +
-      metrics.dramaticBalance * weights.dramaticBalance +
-      metrics.narrativeEfficiency * weights.narrativeEfficiency +
-      metrics.narrativeDensity * weights.narrativeDensity +
-      metrics.redundancy * weights.redundancy
-    ) * 100;
-  }
-
-  private getRating(score: number): 'Excellent' | 'Good' | 'Fair' | 'Poor' | 'Critical' {
-    if (score >= 85) return 'Excellent';
-    if (score >= 70) return 'Good';
-    if (score >= 55) return 'Fair';
-    if (score >= 40) return 'Poor';
-    return 'Critical';
-  }
-}
\ No newline at end of file
diff --git a/backup_20251003_052813/server/analysis_modules/network-diagnostics.ts b/backup_20251003_052813/server/analysis_modules/network-diagnostics.ts
deleted file mode 100644
index 4e6287f..0000000
--- a/backup_20251003_052813/server/analysis_modules/network-diagnostics.ts
+++ /dev/null
@@ -1,532 +0,0 @@
-import { ConflictNetwork, Character, Conflict, Relationship } from '../core/models/base-entities';
-
-export interface DiagnosticReport {
-  overallHealthScore: number;
-  criticalityLevel: 'healthy' | 'minor_issues' | 'moderate_issues' | 'major_issues' | 'critical';
-  structuralIssues: StructuralIssue[];
-  isolatedCharacters: {
-    totalIsolated: number;
-    characters: IsolatedCharacterIssue[];
-  };
-  abandonedConflicts: {
-    totalAbandoned: number;
-    conflicts: AbandonedConflictIssue[];
-  };
-  overloadedCharacters: {
-    totalOverloaded: number;
-    characters: OverloadedCharacterIssue[];
-  };
-  weakConnections: {
-    totalWeak: number;
-    connections: WeakConnectionIssue[];
-  };
-  redundancies: {
-    totalRedundant: number;
-    items: RedundancyIssue[];
-  };
-}
-
-export interface StructuralIssue {
-  type: 'disconnected_components' | 'single_point_failure' | 'circular_dependency';
-  severity: 'low' | 'medium' | 'high' | 'critical';
-  description: string;
-  affectedElements: string[];
-}
-
-export interface IsolatedCharacterIssue {
-  characterName: string;
-  characterId: string;
-  isolationType: 'completely_isolated' | 'weakly_connected' | 'conflict_isolated';
-  suggestedConnections: string[];
-}
-
-export interface AbandonedConflictIssue {
-  conflictName: string;
-  conflictId: string;
-  issueType: 'stuck_in_phase' | 'no_progression' | 'weak_involvement';
-  daysInactive: number;
-  suggestedActions: string[];
-}
-
-export interface OverloadedCharacterIssue {
-  characterName: string;
-  characterId: string;
-  overloadType: 'too_many_conflicts' | 'too_many_relationships' | 'central_bottleneck';
-  currentLoad: number;
-  recommendedLoad: number;
-  suggestedDistribution: string[];
-}
-
-export interface WeakConnectionIssue {
-  connectionType: 'relationship' | 'conflict_involvement';
-  elementId: string;
-  weakness: string;
-  strengthScore: number;
-  improvementSuggestions: string[];
-}
-
-export interface RedundancyIssue {
-  redundancyType: 'duplicate_relationships' | 'similar_conflicts' | 'overlapping_characters';
-  affectedElements: string[];
-  redundancyScore: number;
-  consolidationSuggestion: string;
-}
-
-export class NetworkDiagnostics {
-  private network: ConflictNetwork;
-
-  constructor(network: ConflictNetwork) {
-    this.network = network;
-  }
-
-  runAllDiagnostics(): DiagnosticReport {
-    const structuralIssues = this.analyzeStructuralIssues();
-    const isolatedCharacters = this.findIsolatedCharacters();
-    const abandonedConflicts = this.findAbandonedConflicts();
-    const overloadedCharacters = this.findOverloadedCharacters();
-    const weakConnections = this.findWeakConnections();
-    const redundancies = this.findRedundancies();
-
-    const overallHealthScore = this.calculateOverallHealth({
-      structuralIssues,
-      isolatedCharacters,
-      abandonedConflicts,
-      overloadedCharacters,
-      weakConnections,
-      redundancies
-    });
-
-    return {
-      overallHealthScore,
-      criticalityLevel: this.determineCriticalityLevel(overallHealthScore),
-      structuralIssues,
-      isolatedCharacters,
-      abandonedConflicts,
-      overloadedCharacters,
-      weakConnections,
-      redundancies
-    };
-  }
-
-  private analyzeStructuralIssues(): StructuralIssue[] {
-    const issues: StructuralIssue[] = [];
-
-    // Check for disconnected components
-    const components = this.findConnectedComponents();
-    if (components.length > 1) {
-      issues.push({
-        type: 'disconnected_components',
-        severity: 'high',
-        description: `الشبكة مقسمة إلى ${components.length} مكونات منفصلة`,
-        affectedElements: components.flat()
-      });
-    }
-
-    // Check for single points of failure
-    const criticalNodes = this.findCriticalNodes();
-    if (criticalNodes.length > 0) {
-      issues.push({
-        type: 'single_point_failure',
-        severity: 'medium',
-        description: 'توجد شخصيات حرجة قد تؤدي إزالتها لانهيار الشبكة',
-        affectedElements: criticalNodes
-      });
-    }
-
-    return issues;
-  }
-
-  private findIsolatedCharacters(): {
-    totalIsolated: number;
-    characters: IsolatedCharacterIssue[];
-  } {
-    const isolatedChars: IsolatedCharacterIssue[] = [];
-
-    for (const character of this.network.characters.values()) {
-      const relationships = this.getCharacterRelationships(character.id);
-      const conflicts = this.getCharacterConflicts(character.id);
-
-      if (relationships.length === 0 && conflicts.length === 0) {
-        isolatedChars.push({
-          characterName: character.name,
-          characterId: character.id,
-          isolationType: 'completely_isolated',
-          suggestedConnections: this.suggestConnectionsForCharacter(character.id)
-        });
-      } else if (relationships.length <= 1 && conflicts.length === 0) {
-        isolatedChars.push({
-          characterName: character.name,
-          characterId: character.id,
-          isolationType: 'weakly_connected',
-          suggestedConnections: this.suggestConnectionsForCharacter(character.id)
-        });
-      } else if (relationships.length > 0 && conflicts.length === 0) {
-        isolatedChars.push({
-          characterName: character.name,
-          characterId: character.id,
-          isolationType: 'conflict_isolated',
-          suggestedConnections: this.suggestConflictInvolvement(character.id)
-        });
-      }
-    }
-
-    return {
-      totalIsolated: isolatedChars.length,
-      characters: isolatedChars
-    };
-  }
-
-  private findAbandonedConflicts(): {
-    totalAbandoned: number;
-    conflicts: AbandonedConflictIssue[];
-  } {
-    const abandonedConflicts: AbandonedConflictIssue[] = [];
-
-    for (const conflict of this.network.conflicts.values()) {
-      const daysSinceLastUpdate = this.calculateDaysSinceLastUpdate(conflict);
-      
-      if (daysSinceLastUpdate > 30) {
-        abandonedConflicts.push({
-          conflictName: conflict.name,
-          conflictId: conflict.id,
-          issueType: 'stuck_in_phase',
-          daysInactive: daysSinceLastUpdate,
-          suggestedActions: this.suggestConflictActions(conflict)
-        });
-      } else if (conflict.strength < 3) {
-        abandonedConflicts.push({
-          conflictName: conflict.name,
-          conflictId: conflict.id,
-          issueType: 'weak_involvement',
-          daysInactive: daysSinceLastUpdate,
-          suggestedActions: this.suggestConflictActions(conflict)
-        });
-      }
-    }
-
-    return {
-      totalAbandoned: abandonedConflicts.length,
-      conflicts: abandonedConflicts
-    };
-  }
-
-  private findOverloadedCharacters(): {
-    totalOverloaded: number;
-    characters: OverloadedCharacterIssue[];
-  } {
-    const overloadedChars: OverloadedCharacterIssue[] = [];
-
-    for (const character of this.network.characters.values()) {
-      const relationships = this.getCharacterRelationships(character.id);
-      const conflicts = this.getCharacterConflicts(character.id);
-      
-      const totalLoad = relationships.length + conflicts.length * 2; // Conflicts weighted more
-      
-      if (totalLoad > 8) { // Threshold for overload
-        overloadedChars.push({
-          characterName: character.name,
-          characterId: character.id,
-          overloadType: 'central_bottleneck',
-          currentLoad: totalLoad,
-          recommendedLoad: 6,
-          suggestedDistribution: this.suggestLoadDistribution(character.id)
-        });
-      }
-    }
-
-    return {
-      totalOverloaded: overloadedChars.length,
-      characters: overloadedChars
-    };
-  }
-
-  private findWeakConnections(): {
-    totalWeak: number;
-    connections: WeakConnectionIssue[];
-  } {
-    const weakConnections: WeakConnectionIssue[] = [];
-
-    // Check weak relationships
-    for (const relationship of this.network.relationships.values()) {
-      if (relationship.strength < 4) {
-        weakConnections.push({
-          connectionType: 'relationship',
-          elementId: relationship.id,
-          weakness: 'قوة العلاقة ضعيفة',
-          strengthScore: relationship.strength,
-          improvementSuggestions: [
-            'أضف مشاهد تفاعل أكثر بين الشخصيتين',
-            'طور الخلفية المشتركة للشخصيتين',
-            'أنشئ صراعاً يجمع بينهما'
-          ]
-        });
-      }
-    }
-
-    // Check weak conflict involvement
-    for (const conflict of this.network.conflicts.values()) {
-      if (conflict.strength < 4) {
-        weakConnections.push({
-          connectionType: 'conflict_involvement',
-          elementId: conflict.id,
-          weakness: 'مشاركة ضعيفة في الصراع',
-          strengthScore: conflict.strength,
-          improvementSuggestions: [
-            'زد من حدة الصراع',
-            'أضف نقاط تحول مهمة',
-            'اربط الصراع بدوافع الشخصيات الأساسية'
-          ]
-        });
-      }
-    }
-
-    return {
-      totalWeak: weakConnections.length,
-      connections: weakConnections
-    };
-  }
-
-  private findRedundancies(): {
-    totalRedundant: number;
-    items: RedundancyIssue[];
-  } {
-    const redundancies: RedundancyIssue[] = [];
-
-    // Check for duplicate relationships
-    const relationshipPairs = this.findDuplicateRelationships();
-    for (const pair of relationshipPairs) {
-      redundancies.push({
-        redundancyType: 'duplicate_relationships',
-        affectedElements: pair,
-        redundancyScore: 0.8,
-        consolidationSuggestion: 'دمج العلاقات المتشابهة في علاقة واحدة أقوى'
-      });
-    }
-
-    // Check for similar conflicts
-    const conflictGroups = this.findSimilarConflicts();
-    for (const group of conflictGroups) {
-      if (group.length > 1) {
-        redundancies.push({
-          redundancyType: 'similar_conflicts',
-          affectedElements: group,
-          redundancyScore: 0.7,
-          consolidationSuggestion: 'دمج الصراعات المتشابهة في صراع واحد أكثر تعقيداً'
-        });
-      }
-    }
-
-    return {
-      totalRedundant: redundancies.length,
-      items: redundancies
-    };
-  }
-
-  // Helper methods
-  private getCharacterRelationships(characterId: string): Relationship[] {
-    return Array.from(this.network.relationships.values()).filter(
-      rel => rel.source === characterId || rel.target === characterId
-    );
-  }
-
-  private getCharacterConflicts(characterId: string): Conflict[] {
-    return Array.from(this.network.conflicts.values()).filter(
-      conflict => conflict.involvedCharacters.includes(characterId)
-    );
-  }
-
-  private findConnectedComponents(): string[][] {
-    // Simple connected components algorithm
-    const visited = new Set<string>();
-    const components: string[][] = [];
-
-    for (const charId of this.network.characters.keys()) {
-      if (!visited.has(charId)) {
-        const component = this.dfsComponent(charId, visited);
-        components.push(component);
-      }
-    }
-
-    return components;
-  }
-
-  private dfsComponent(startId: string, visited: Set<string>): string[] {
-    const component: string[] = [];
-    const stack = [startId];
-
-    while (stack.length > 0) {
-      const currentId = stack.pop()!;
-      if (visited.has(currentId)) continue;
-
-      visited.add(currentId);
-      component.push(currentId);
-
-      // Add connected characters
-      const relationships = this.getCharacterRelationships(currentId);
-      for (const rel of relationships) {
-        const otherId = rel.source === currentId ? rel.target : rel.source;
-        if (!visited.has(otherId)) {
-          stack.push(otherId);
-        }
-      }
-    }
-
-    return component;
-  }
-
-  private findCriticalNodes(): string[] {
-    // Characters whose removal would disconnect the network
-    const criticalNodes: string[] = [];
-    
-    for (const charId of this.network.characters.keys()) {
-      const relationships = this.getCharacterRelationships(charId);
-      if (relationships.length >= 3) { // High connectivity threshold
-        criticalNodes.push(charId);
-      }
-    }
-
-    return criticalNodes;
-  }
-
-  private suggestConnectionsForCharacter(characterId: string): string[] {
-    const suggestions: string[] = [];
-    const character = this.network.characters.get(characterId);
-    
-    if (character) {
-      // Find characters with similar traits or roles
-      for (const otherChar of this.network.characters.values()) {
-        if (otherChar.id !== characterId) {
-          suggestions.push(`ربط مع الشخصية: ${otherChar.name}`);
-          if (suggestions.length >= 3) break;
-        }
-      }
-    }
-
-    return suggestions;
-  }
-
-  private suggestConflictInvolvement(characterId: string): string[] {
-    const suggestions: string[] = [];
-    const conflicts = Array.from(this.network.conflicts.values());
-    
-    for (const conflict of conflicts.slice(0, 2)) {
-      suggestions.push(`إشراك في الصراع: ${conflict.name}`);
-    }
-
-    return suggestions;
-  }
-
-  private calculateDaysSinceLastUpdate(conflict: Conflict): number {
-    if (conflict.timestamps.length === 0) return 365; // Very old
-    
-    const lastUpdate = conflict.timestamps[conflict.timestamps.length - 1];
-    const now = new Date();
-    const diffTime = Math.abs(now.getTime() - lastUpdate.getTime());
-    return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
-  }
-
-  private suggestConflictActions(conflict: Conflict): string[] {
-    return [
-      'تطوير الصراع إلى المرحلة التالية',
-      'إضافة نقطة تحول جديدة',
-      'زيادة مشاركة الشخصيات',
-      'ربط الصراع بصراعات أخرى'
-    ];
-  }
-
-  private suggestLoadDistribution(characterId: string): string[] {
-    return [
-      'نقل بعض العلاقات لشخصيات أخرى',
-      'تقسيم الصراعات الكبيرة',
-      'إنشاء شخصيات مساعدة'
-    ];
-  }
-
-  private findDuplicateRelationships(): string[][] {
-    const duplicates: string[][] = [];
-    const relationships = Array.from(this.network.relationships.values());
-    
-    for (let i = 0; i < relationships.length; i++) {
-      for (let j = i + 1; j < relationships.length; j++) {
-        const rel1 = relationships[i];
-        const rel2 = relationships[j];
-        
-        if (this.areRelationshipsSimilar(rel1, rel2)) {
-          duplicates.push([rel1.id, rel2.id]);
-        }
-      }
-    }
-    
-    return duplicates;
-  }
-
-  private findSimilarConflicts(): string[][] {
-    const groups: string[][] = [];
-    const conflicts = Array.from(this.network.conflicts.values());
-    const processed = new Set<string>();
-    
-    for (const conflict of conflicts) {
-      if (processed.has(conflict.id)) continue;
-      
-      const similarGroup = [conflict.id];
-      processed.add(conflict.id);
-      
-      for (const otherConflict of conflicts) {
-        if (otherConflict.id !== conflict.id && !processed.has(otherConflict.id)) {
-          if (this.areConflictsSimilar(conflict, otherConflict)) {
-            similarGroup.push(otherConflict.id);
-            processed.add(otherConflict.id);
-          }
-        }
-      }
-      
-      if (similarGroup.length > 1) {
-        groups.push(similarGroup);
-      }
-    }
-    
-    return groups;
-  }
-
-  private areRelationshipsSimilar(rel1: Relationship, rel2: Relationship): boolean {
-    return (
-      rel1.type === rel2.type &&
-      ((rel1.source === rel2.source && rel1.target === rel2.target) ||
-       (rel1.source === rel2.target && rel1.target === rel2.source))
-    );
-  }
-
-  private areConflictsSimilar(conflict1: Conflict, conflict2: Conflict): boolean {
-    return (
-      conflict1.subject === conflict2.subject &&
-      conflict1.scope === conflict2.scope &&
-      this.hasOverlappingCharacters(conflict1.involvedCharacters, conflict2.involvedCharacters)
-    );
-  }
-
-  private hasOverlappingCharacters(chars1: string[], chars2: string[]): boolean {
-    return chars1.some(char => chars2.includes(char));
-  }
-
-  private calculateOverallHealth(issues: any): number {
-    let score = 100;
-    
-    // Deduct points for each type of issue
-    score -= issues.structuralIssues.length * 15;
-    score -= issues.isolatedCharacters.totalIsolated * 10;
-    score -= issues.abandonedConflicts.totalAbandoned * 8;
-    score -= issues.overloadedCharacters.totalOverloaded * 12;
-    score -= issues.weakConnections.totalWeak * 5;
-    score -= issues.redundancies.totalRedundant * 7;
-    
-    return Math.max(0, score);
-  }
-
-  private determineCriticalityLevel(score: number): 'healthy' | 'minor_issues' | 'moderate_issues' | 'major_issues' | 'critical' {
-    if (score >= 85) return 'healthy';
-    if (score >= 70) return 'minor_issues';
-    if (score >= 50) return 'moderate_issues';
-    if (score >= 30) return 'major_issues';
-    return 'critical';
-  }
-}
\ No newline at end of file
diff --git a/backup_20251003_052813/server/core/models/base-entities.ts b/backup_20251003_052813/server/core/models/base-entities.ts
deleted file mode 100644
index 8d589bd..0000000
--- a/backup_20251003_052813/server/core/models/base-entities.ts
+++ /dev/null
@@ -1,156 +0,0 @@
-export interface Character {
-  id: string;
-  name: string;
-  description: string;
-  profile: {
-    personalityTraits: string;
-    motivationsGoals: string;
-    potentialArc: string;
-  };
-  metadata: Record<string, any>;
-}
-
-export enum RelationshipType {
-  LOVE = 'LOVE',
-  RIVALRY = 'RIVALRY',
-  ALLIANCE = 'ALLIANCE',
-  FAMILY = 'FAMILY',
-  MENTORSHIP = 'MENTORSHIP',
-  ENMITY = 'ENMITY',
-  OTHER = 'OTHER'
-}
-
-export enum RelationshipNature {
-  POSITIVE = 'POSITIVE',
-  NEGATIVE = 'NEGATIVE',
-  NEUTRAL = 'NEUTRAL',
-  AMBIVALENT = 'AMBIVALENT',
-  OTHER = 'OTHER'
-}
-
-export enum RelationshipDirection {
-  DIRECTED = 'DIRECTED',
-  BIDIRECTIONAL = 'BIDIRECTIONAL'
-}
-
-export interface Relationship {
-  id: string;
-  source: string;
-  target: string;
-  type: RelationshipType;
-  nature: RelationshipNature;
-  direction: RelationshipDirection;
-  strength: number;
-  description: string;
-  triggers: string[];
-  metadata: Record<string, any>;
-}
-
-export enum ConflictSubject {
-  VALUE = 'VALUE',
-  MATERIAL = 'MATERIAL',
-  POWER = 'POWER',
-  PSYCHOLOGICAL = 'PSYCHOLOGICAL',
-  RELATIONSHIP = 'RELATIONSHIP',
-  INFORMATIONAL = 'INFORMATIONAL',
-  SURVIVAL = 'SURVIVAL',
-  OTHER = 'OTHER'
-}
-
-export enum ConflictScope {
-  INTERNAL = 'INTERNAL',
-  PERSONAL = 'PERSONAL',
-  GROUP = 'GROUP',
-  SOCIETAL = 'SOCIETAL',
-  UNIVERSAL = 'UNIVERSAL'
-}
-
-export enum ConflictPhase {
-  LATENT = 'LATENT',
-  EMERGING = 'EMERGING',
-  ESCALATING = 'ESCALATING',
-  STALEMATE = 'STALEMATE',
-  CLIMAX = 'CLIMAX',
-  DEESCALATING = 'DEESCALATING',
-  RESOLUTION = 'RESOLUTION',
-  AFTERMATH = 'AFTERMATH',
-  OTHER = 'OTHER'
-}
-
-export interface Conflict {
-  id: string;
-  name: string;
-  description: string;
-  involvedCharacters: string[];
-  subject: ConflictSubject;
-  scope: ConflictScope;
-  phase: ConflictPhase;
-  strength: number;
-  relatedRelationships: string[];
-  pivotPoints: string[];
-  timestamps: Date[];
-  metadata: Record<string, any>;
-}
-
-export interface NetworkSnapshot {
-  timestamp: Date;
-  description: string;
-  networkState: Partial<ConflictNetwork>;
-}
-
-export interface ConflictNetwork {
-  id: string;
-  name: string;
-  characters: Map<string, Character>;
-  relationships: Map<string, Relationship>;
-  conflicts: Map<string, Conflict>;
-  snapshots: NetworkSnapshot[];
-  metadata: Record<string, any>;
-}
-
-export class ConflictNetworkImpl implements ConflictNetwork {
-  id: string;
-  name: string;
-  characters: Map<string, Character>;
-  relationships: Map<string, Relationship>;
-  conflicts: Map<string, Conflict>;
-  snapshots: NetworkSnapshot[];
-  metadata: Record<string, any>;
-
-  constructor(id: string, name: string) {
-    this.id = id;
-    this.name = name;
-    this.characters = new Map();
-    this.relationships = new Map();
-    this.conflicts = new Map();
-    this.snapshots = [];
-    this.metadata = {};
-  }
-
-  addCharacter(character: Character): void {
-    this.characters.set(character.id, character);
-  }
-
-  addRelationship(relationship: Relationship): void {
-    this.relationships.set(relationship.id, relationship);
-  }
-
-  addConflict(conflict: Conflict): void {
-    this.conflicts.set(conflict.id, conflict);
-  }
-
-  createSnapshot(description: string): void {
-    this.snapshots.push({
-      timestamp: new Date(),
-      description,
-      networkState: {
-        id: this.id,
-        name: this.name,
-        characters: new Map(this.characters),
-        relationships: new Map(this.relationships),
-        conflicts: new Map(this.conflicts),
-        metadata: { ...this.metadata }
-      }
-    });
-  }
-}
diff --git a/backup_20251003_052813/server/core/pipeline/base-station.ts b/backup_20251003_052813/server/core/pipeline/base-station.ts
deleted file mode 100644
index 60ccd01..0000000
--- a/backup_20251003_052813/server/core/pipeline/base-station.ts
+++ /dev/null
@@ -1,146 +0,0 @@
-import { GeminiService, GeminiModel } from '../../services/ai/gemini-service';
-import logger from '../../utils/logger';
-
-export interface StationConfig<TInput, TOutput> {
-  stationNumber: number;
-  stationName: string;
-  inputValidation: (input: TInput) => boolean;
-  outputValidation: (output: TOutput) => boolean;
-  cacheEnabled: boolean;
-  performanceTracking: boolean;
-}
-
-export interface StationMetadata {
-  executionTime: number;
-  timestamp: Date;
-  modelUsed: GeminiModel;
-  cacheHit: boolean;
-  errorOccurred: boolean;
-  errorDetails?: string;
-}
-
-export abstract class BaseStation<TInput, TOutput> {
-  protected config: StationConfig<TInput, TOutput>;
-  protected geminiService: GeminiService;
-  protected cache: Map<string, TOutput>;
-
-  constructor(
-    config: StationConfig<TInput, TOutput>,
-    geminiService: GeminiService
-  ) {
-    this.config = config;
-    this.geminiService = geminiService;
-    this.cache = new Map();
-  }
-
-  async execute(input: TInput): Promise<{
-    output: TOutput;
-    metadata: StationMetadata;
-  }> {
-    const startTime = Date.now();
-    
-    const safeInputSnapshot = this.extractRequiredData(input);
-
-    try {
-      this.validateInput(input);
-
-      const cachedResult = this.checkCache(input);
-      if (cachedResult) {
-        return {
-          output: cachedResult,
-          metadata: this.createMetadata(startTime, true)
-        };
-      }
-      
-      const output = await this.process(input);
-      
-      this.validateOutput(output);
-      
-      this.saveToCache(input, output);
-      
-      return {
-        output,
-        metadata: this.createMetadata(startTime, false)
-      };
-      
-    } catch (error) {
-      return this.handleError(error, startTime, safeInputSnapshot);
-    }
-  }
-
-  protected abstract process(input: TInput): Promise<TOutput>;
-
-  protected abstract extractRequiredData(input: TInput): Record<string, unknown>;
-  
-  protected validateInput(input: TInput): void {
-    if (!this.config.inputValidation(input)) {
-      throw new Error(
-        `Invalid input for ${this.config.stationName}`
-      );
-    }
-  }
-  
-  protected validateOutput(output: TOutput): void {
-    if (!this.config.outputValidation(output)) {
-      throw new Error(
-        `Invalid output from ${this.config.stationName}`
-      );
-    }
-  }
-  
-  protected checkCache(input: TInput): TOutput | null {
-    if (!this.config.cacheEnabled) return null;
-    
-    const cacheKey = this.generateCacheKey(input);
-    return this.cache.get(cacheKey) || null;
-  }
-  
-  protected saveToCache(input: TInput, output: TOutput): void {
-    if (!this.config.cacheEnabled) return;
-    
-    const cacheKey = this.generateCacheKey(input);
-    this.cache.set(cacheKey, output);
-  }
-  
-  protected generateCacheKey(input: TInput): string {
-    return JSON.stringify(input);
-  }
-  
-  protected createMetadata(
-    startTime: number,
-    cacheHit: boolean
-  ): StationMetadata {
-    return {
-      executionTime: Date.now() - startTime,
-      timestamp: new Date(),
-      modelUsed: GeminiModel.PRO,
-      cacheHit,
-      errorOccurred: false
-    };
-  }
-  
-  protected handleError(
-    error: unknown,
-    startTime: number,
-    safeInputSnapshot: Record<string, unknown>
-  ): { output: TOutput; metadata: StationMetadata } {
-    logger.error(`Error in ${this.config.stationName}`, {
-      station: this.config.stationName,
-      stationNumber: this.config.stationNumber,
-      input: safeInputSnapshot,
-      error: error instanceof Error ? error.message : 'Unknown error',
-      stack: error instanceof Error ? error.stack : undefined,
-    });
-
-    return {
-      output: this.getErrorFallback(),
-      metadata: {
-        ...this.createMetadata(startTime, false),
-        errorOccurred: true,
-        errorDetails: error instanceof Error ? error.message : 'Unknown error',
-      },
-    };
-  }
-
-  protected abstract getErrorFallback(): TOutput;
-}
\ No newline at end of file
diff --git a/backup_20251003_052813/server/index.ts b/backup_20251003_052813/server/index.ts
deleted file mode 100644
index f0e0f4c..0000000
--- a/backup_20251003_052813/server/index.ts
+++ /dev/null
@@ -1,91 +0,0 @@
-import express, { type Request, Response, NextFunction } from "express";
-import helmet from "helmet";
-import cors from "cors";
-import { registerRoutes } from "./routes";
-import { setupVite, serveStatic } from "./vite";
-import logger from "./utils/logger";
-
-const app = express();
-
-app.use(helmet());
-app.use(cors({
-  origin: process.env.ALLOWED_ORIGINS?.split(",").filter(Boolean) || "*",
-  methods: ["GET", "POST", "OPTIONS"],
-  allowedHeaders: ["Content-Type", "X-API-Key"],
-}));
-
-app.use(express.json({ limit: "1mb" }));
-app.use(express.urlencoded({ extended: false }));
-
-app.use((req, res, next) => {
-  const start = Date.now();
-  const path = req.path;
-  let capturedJsonResponse: Record<string, any> | undefined = undefined;
-
-  const originalResJson = res.json;
-  res.json = function (bodyJson, ...args) {
-    capturedJsonResponse = bodyJson;
-    return originalResJson.apply(res, [bodyJson, ...args]);
-  };
-
-  res.on("finish", () => {
-    const duration = Date.now() - start;
-    if (path.startsWith("/api")) {
-      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;
-      if (capturedJsonResponse) {
-        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
-      }
-
-      if (logLine.length > 80) {
-        logLine = `${logLine.slice(0, 79)}…`;
-      }
-
-      logger.info(logLine);
-    }
-  });
-
-  next();
-});
-
-(async () => {
-  const server = await registerRoutes(app);
-
-  app.use((err: unknown, _req: Request, res: Response, _next: NextFunction) => {
-    const status = typeof (err as { status?: number }).status === "number"
-      ? (err as { status?: number }).status!
-      : typeof (err as { statusCode?: number }).statusCode === "number"
-        ? (err as { statusCode?: number }).statusCode!
-        : 500;
-    const message = (err as Error).message ?? "Internal Server Error";
-
-    logger.error("Unhandled request error", {
-      status,
-      message,
-      stack: err instanceof Error ? err.stack : undefined,
-    });
-
-    res.status(status).json({ message });
-  });
-
-  // importantly only setup vite in development and after
-  // setting up all the other routes so the catch-all route
-  // doesn't interfere with the other routes
-  if (app.get("env") === "development") {
-    await setupVite(app, server);
-  } else {
-    serveStatic(app);
-  }
-
-  // ALWAYS serve the app on the port specified in the environment variable PORT
-  // Other ports are firewalled. Default to 5000 if not specified.
-  // this serves both the API and the client.
-  // It is the only port that is not firewalled.
-  const port = parseInt(process.env.PORT || '5000', 10);
-  server.listen({
-    port,
-    host: "0.0.0.0",
-    reusePort: true,
-  }, () => {
-    logger.info(`serving on port ${port}`);
-  });
-})();
diff --git a/backup_20251003_052813/server/middleware/auth.ts b/backup_20251003_052813/server/middleware/auth.ts
deleted file mode 100644
index ac37164..0000000
--- a/backup_20251003_052813/server/middleware/auth.ts
+++ /dev/null
@@ -1,51 +0,0 @@
-import { Request, Response, NextFunction } from 'express';
-
-export interface AuthenticatedRequest extends Request {
-  apiKey?: string;
-  userId?: string;
-}
-
-export function apiKeyAuth(req: AuthenticatedRequest, res: Response, next: NextFunction): void {
-  const apiKey = req.headers['x-api-key'] as string;
-
-  if (!apiKey) {
-    res.status(401).json({
-      error: 'Authentication required',
-      message: 'Please provide an API key in X-API-Key header'
-    });
-    return;
-  }
-
-  const validApiKeys = (process.env.VALID_API_KEYS || '').split(',').filter(Boolean);
-
-  if (validApiKeys.length === 0) {
-    console.warn('⚠️ No API keys configured. Authentication is disabled.');
-    req.apiKey = apiKey;
-    next();
-    return;
-  }
-
-  if (!validApiKeys.includes(apiKey)) {
-    res.status(403).json({
-      error: 'Invalid API key',
-      message: 'The provided API key is not valid'
-    });
-    return;
-  }
-
-  req.apiKey = apiKey;
-  next();
-}
-
-export function optionalAuth(req: AuthenticatedRequest, res: Response, next: NextFunction): void {
-  const apiKey = req.headers['x-api-key'] as string;
-
-  if (apiKey) {
-    const validApiKeys = (process.env.VALID_API_KEYS || '').split(',').filter(Boolean);
-    if (validApiKeys.includes(apiKey)) {
-      req.apiKey = apiKey;
-    }
-  }
-
-  next();
-}
diff --git a/backup_20251003_052813/server/middleware/rate-limit.ts b/backup_20251003_052813/server/middleware/rate-limit.ts
deleted file mode 100644
index ffc31aa..0000000
--- a/backup_20251003_052813/server/middleware/rate-limit.ts
+++ /dev/null
@@ -1,43 +0,0 @@
-import rateLimit from 'express-rate-limit';
-
-export const apiLimiter = rateLimit({
-  windowMs: 15 * 60 * 1000,
-  max: 100,
-  message: {
-    error: 'Too many requests',
-    message: 'You have exceeded the rate limit. Please try again later.',
-    retryAfter: '15 minutes'
-  },
-  standardHeaders: true,
-  legacyHeaders: false,
-  skip: (req) => {
-    if (process.env.NODE_ENV === 'development' &&
-        (req.ip === '127.0.0.1' || req.ip === '::1')) {
-      return true;
-    }
-    return false;
-  }
-});
-
-export const aiAnalysisLimiter = rateLimit({
-  windowMs: 60 * 60 * 1000,
-  max: 10,
-  message: {
-    error: 'Too many analysis requests',
-    message: 'You have exceeded the analysis rate limit. Please try again in an hour.',
-    retryAfter: '1 hour'
-  },
-  standardHeaders: true,
-  legacyHeaders: false,
-  skipSuccessfulRequests: false,
-  skipFailedRequests: false
-});
-
-export const readLimiter = rateLimit({
-  windowMs: 15 * 60 * 1000,
-  max: 1000,
-  message: {
-    error: 'Too many requests',
-    message: 'Please slow down your requests.'
-  }
-});
diff --git a/backup_20251003_052813/server/middleware/sanitize.ts b/backup_20251003_052813/server/middleware/sanitize.ts
deleted file mode 100644
index 28cc35b..0000000
--- a/backup_20251003_052813/server/middleware/sanitize.ts
+++ /dev/null
@@ -1,44 +0,0 @@
-import { Request, Response, NextFunction } from 'express';
-
-export function sanitizeInput(req: Request, res: Response, next: NextFunction): void {
-  if (req.body && typeof req.body === 'object') {
-    sanitizeObject(req.body);
-  }
-  next();
-}
-
-function sanitizeObject(obj: any): void {
-  for (const key in obj) {
-    if (obj.hasOwnProperty(key)) {
-      const value = obj[key];
-
-      if (typeof value === 'string') {
-        obj[key] = value
-          .replace(/<[^>]*>/g, '')
-          .replace(/[\u0000-\u001F\u007F]+/g, '')
-          .replace(/\0/g, '')
-          .trim();
-
-        if (obj[key].length > 500000) {
-          obj[key] = obj[key].substring(0, 500000);
-        }
-      } else if (typeof value === 'object' && value !== null) {
-        sanitizeObject(value);
-      }
-    }
-  }
-}
-
-export function requireJsonContent(req: Request, res: Response, next: NextFunction): void {
-  const contentType = req.headers['content-type'];
-
-  if (!contentType || !contentType.includes('application/json')) {
-    res.status(415).json({
-      error: 'Unsupported Media Type',
-      message: 'Content-Type must be application/json'
-    });
-    return;
-  }
-
-  next();
-}
diff --git a/backup_20251003_052813/server/routes/health.ts b/backup_20251003_052813/server/routes/health.ts
deleted file mode 100644
index d5b90ac..0000000
--- a/backup_20251003_052813/server/routes/health.ts
+++ /dev/null
@@ -1,49 +0,0 @@
-import { Router, Request, Response } from 'express';
-import * as fs from 'fs';
-import * as path from 'path';
-
-const router = Router();
-
-router.get('/health', (req: Request, res: Response) => {
-  res.status(200).json({
-    status: 'ok',
-    timestamp: new Date().toISOString(),
-    uptime: process.uptime()
-  });
-});
-
-router.get('/ready', async (req: Request, res: Response) => {
-  const checks: Record<string, boolean> = {};
-  let isReady = true;
-
-  checks.geminiApiKey = Boolean(process.env.GEMINI_API_KEY);
-  if (!checks.geminiApiKey) {
-    isReady = false;
-  }
-
-  try {
-    const testFile = path.join(process.cwd(), '.health-check-test');
-    fs.writeFileSync(testFile, 'test');
-    fs.unlinkSync(testFile);
-    checks.fileSystem = true;
-  } catch (error) {
-    checks.fileSystem = false;
-    isReady = false;
-  }
-
-  const status = isReady ? 200 : 503;
-  res.status(status).json({
-    status: isReady ? 'ready' : 'not ready',
-    checks,
-    timestamp: new Date().toISOString()
-  });
-});
-
-router.get('/live', (req: Request, res: Response) => {
-  res.status(200).json({
-    status: 'alive',
-    timestamp: new Date().toISOString()
-  });
-});
-
-export default router;
diff --git a/backup_20251003_052813/server/routes.ts b/backup_20251003_052813/server/routes.ts
deleted file mode 100644
index e18ede3..0000000
--- a/backup_20251003_052813/server/routes.ts
+++ /dev/null
@@ -1,209 +0,0 @@
-import type { Express } from 'express';
-import { createServer, type Server } from 'http';
-import { ZodError } from 'zod';
-import { analyzeTextSchema } from '@shared/schema';
-import { AnalysisPipeline } from './run-all-stations';
-import { GeminiService, GeminiModel } from './services/ai/gemini-service';
-import { Station1TextAnalysis, type Station1Input, type Station1Output } from './stations/station1/station1-text-analysis';
-import { Station2ConceptualAnalysis, type Station2Input, type Station2Output } from './stations/station2/station2-conceptual-analysis';
-import { Station3NetworkBuilder, type Station3Input, type Station3Output } from './stations/station3/station3-network-builder';
-import { apiKeyAuth } from './middleware/auth';
-import { aiAnalysisLimiter } from './middleware/rate-limit';
-import { sanitizeInput, requireJsonContent } from './middleware/sanitize';
-import healthRouter from './routes/health';
-import logger from './utils/logger';
-import type { StationConfig } from './core/pipeline/base-station';
-
-const GEMINI_API_KEY = process.env.GEMINI_API_KEY ?? '';
-
-if (!GEMINI_API_KEY) {
-  logger.warn('⚠️  GEMINI_API_KEY is not set. Text analysis will fail.');
-  logger.warn('Please set GEMINI_API_KEY in your environment variables.');
-}
-
-const geminiService = new GeminiService({
-  apiKey: GEMINI_API_KEY,
-  defaultModel: GeminiModel.PRO,
-  fallbackModel: GeminiModel.FLASH,
-  maxRetries: 3,
-  timeout: 60_000,
-});
-
-const analysisPipeline = new AnalysisPipeline({
-  apiKey: GEMINI_API_KEY,
-  geminiService,
-});
-
-const station1 = new Station1TextAnalysis(createStationConfig<Station1Input, Station1Output>(1, 'Text Analysis'), geminiService);
-const station2 = new Station2ConceptualAnalysis(createStationConfig<Station2Input, Station2Output>(2, 'Conceptual Analysis'), geminiService);
-const station3 = new Station3NetworkBuilder(createStationConfig<Station3Input, Station3Output>(3, 'Network Builder'), geminiService);
-
-export async function registerRoutes(app: Express): Promise<Server> {
-  app.use('/', healthRouter);
-
-  app.post(
-    '/api/analyze-text',
-    requireJsonContent,
-    apiKeyAuth,
-    aiAnalysisLimiter,
-    sanitizeInput,
-    async (req, res) => {
-      try {
-        const validatedData = analyzeTextSchema.parse(req.body);
-
-        const station1Result = await station1.execute({
-          fullText: validatedData.fullText,
-          projectName: validatedData.projectName,
-          proseFilePath: validatedData.proseFilePath,
-        });
-
-        const station2Result = await station2.execute({
-          station1Output: station1Result.output,
-          fullText: validatedData.fullText,
-        });
-
-        const station3Result = await station3.execute({
-          station1Output: station1Result.output,
-          station2Output: station2Result.output,
-          fullText: validatedData.fullText,
-        });
-
-        const response: Station1Output = station1Result.output;
-
-        res.json({
-          station1: {
-            majorCharacters: response.majorCharacters,
-            characterAnalysis: Object.fromEntries(response.characterAnalysis),
-            relationshipAnalysis: response.relationshipAnalysis,
-            narrativeStyleAnalysis: response.narrativeStyleAnalysis,
-            metadata: {
-              analysisTimestamp: response.metadata.analysisTimestamp.toISOString(),
-              status: response.metadata.status,
-            },
-          },
-          station2: {
-            storyStatement: station2Result.output.storyStatement,
-            elevatorPitch: station2Result.output.elevatorPitch,
-            hybridGenre: station2Result.output.hybridGenre,
-          },
-          station3: {
-            networkSummary: station3Result.output.networkSummary,
-          },
-        });
-      } catch (error) {
-        if (error instanceof ZodError) {
-          res.status(400).json({
-            error: 'بيانات غير صالحة',
-            message: error.flatten(),
-          });
-          return;
-        }
-
-        logger.error('Error analyzing text', {
-          error: error instanceof Error ? error.message : 'Unknown error',
-        });
-
-        res.status(500).json({
-          error: 'فشل تحليل النص',
-          message: error instanceof Error ? error.message : 'Unknown error',
-        });
-      }
-    },
-  );
-
-  app.post(
-    '/api/analyze-full-pipeline',
-    requireJsonContent,
-    apiKeyAuth,
-    aiAnalysisLimiter,
-    sanitizeInput,
-    async (req, res) => {
-      try {
-        const validatedData = analyzeTextSchema.parse(req.body);
-
-        const result = await analysisPipeline.runFullAnalysis({
-          fullText: validatedData.fullText,
-          projectName: validatedData.projectName,
-          proseFilePath: validatedData.proseFilePath,
-        });
-
-        res.json({
-          success: true,
-          data: toSerializable(result.stationOutputs),
-          metadata: result.pipelineMetadata,
-          message: `تم إنجاز ${result.pipelineMetadata.stationsCompleted} محطات من أصل 7`,
-          executionTime: `${(result.pipelineMetadata.totalExecutionTime / 1000).toFixed(1)} ثانية`,
-        });
-      } catch (error) {
-        if (error instanceof ZodError) {
-          res.status(400).json({
-            success: false,
-            error: 'بيانات غير صالحة',
-            message: error.flatten(),
-          });
-          return;
-        }
-
-        logger.error('Error in full pipeline', {
-          error: error instanceof Error ? error.message : 'Unknown error',
-        });
-
-        res.status(500).json({
-          success: false,
-          error: 'فشل تشغيل Pipeline الشامل',
-          message: error instanceof Error ? error.message : 'Unknown error',
-        });
-      }
-    },
-  );
-
-  app.get('/api/stations-status', (_req, res) => {
-    const status = analysisPipeline.getStationStatus();
-    const values = Object.values(status);
-
-    res.json({
-      success: true,
-      stations: status,
-      totalStations: values.length,
-      availableStations: values.filter((value) => value === 'completed').length,
-    });
-  });
-
-  const httpServer = createServer(app);
-
-  return httpServer;
-}
-
-function createStationConfig<TInput, TOutput>(
-  stationNumber: number,
-  stationName: string,
-): StationConfig<TInput, TOutput> {
-  return {
-    stationNumber,
-    stationName,
-    cacheEnabled: false,
-    performanceTracking: true,
-    inputValidation: (input: TInput) => input !== undefined && input !== null,
-    outputValidation: (output: TOutput) => output !== undefined && output !== null,
-  };
-}
-
-function toSerializable(value: unknown): unknown {
-  if (value instanceof Map) {
-    return Object.fromEntries(Array.from(value.entries()).map(([key, mapValue]) => [key, toSerializable(mapValue)]));
-  }
-
-  if (value instanceof Date) {
-    return value.toISOString();
-  }
-
-  if (Array.isArray(value)) {
-    return value.map((item) => toSerializable(item));
-  }
-
-  if (value && typeof value === 'object') {
-    return Object.fromEntries(Object.entries(value).map(([key, entryValue]) => [key, toSerializable(entryValue)]));
-  }
-
-  return value;
-}
diff --git a/backup_20251003_052813/server/run-all-stations.ts b/backup_20251003_052813/server/run-all-stations.ts
deleted file mode 100644
index 552fb0e..0000000
--- a/backup_20251003_052813/server/run-all-stations.ts
+++ /dev/null
@@ -1,198 +0,0 @@
-import * as fs from 'fs';
-import * as path from 'path';
-import { Station1TextAnalysis, type Station1Input, type Station1Output } from './stations/station1/station1-text-analysis';
-import { Station2ConceptualAnalysis, type Station2Input, type Station2Output } from './stations/station2/station2-conceptual-analysis';
-import { Station3NetworkBuilder, type Station3Input, type Station3Output } from './stations/station3/station3-network-builder';
-import { Station4EfficiencyMetrics, type Station4Input, type Station4Output } from './stations/station4/station4-efficiency-metrics';
-import { Station5DynamicSymbolicStylistic, type Station5Input, type Station5Output } from './stations/station5/station5-dynamic-symbolic-stylistic';
-import { Station6DiagnosticsAndTreatment, type Station6Input, type Station6Output } from './stations/station6/station6-diagnostics-treatment';
-import { Station7Finalization, type Station7Input, type Station7Output } from './stations/station7/station7-finalization';
-import { GeminiService, GeminiModel } from './services/ai/gemini-service';
-import { type StationConfig } from './core/pipeline/base-station';
-import logger from './utils/logger';
-
-export interface PipelineInput {
-  fullText: string;
-  projectName: string;
-  proseFilePath?: string;
-}
-
-export interface PipelineRunResult {
-  stationOutputs: {
-    station1: Station1Output;
-    station2: Station2Output;
-    station3: Station3Output;
-    station4: Station4Output;
-    station5: Station5Output;
-    station6: Station6Output;
-    station7: Station7Output;
-  };
-  pipelineMetadata: {
-    stationsCompleted: number;
-    totalExecutionTime: number;
-    startedAt: string;
-    finishedAt: string;
-  };
-}
-
-export type StationStatus = 'pending' | 'running' | 'completed' | 'error';
-
-interface AnalysisPipelineConfig {
-  apiKey: string;
-  outputDir?: string;
-  geminiService?: GeminiService;
-}
-
-export class AnalysisPipeline {
-  private readonly geminiService: GeminiService;
-  private readonly stationStatuses = new Map<number, StationStatus>();
-  private readonly station1: Station1TextAnalysis;
-  private readonly station2: Station2ConceptualAnalysis;
-  private readonly station3: Station3NetworkBuilder;
-  private readonly station4: Station4EfficiencyMetrics;
-  private readonly station5: Station5DynamicSymbolicStylistic;
-  private readonly station6: Station6DiagnosticsAndTreatment;
-  private readonly station7: Station7Finalization;
-  private readonly outputDirectory: string;
-
-  constructor(config: AnalysisPipelineConfig) {
-    if (!config.apiKey) {
-      throw new Error('GEMINI_API_KEY is required to initialise the analysis pipeline.');
-    }
-
-    this.geminiService = config.geminiService ?? new GeminiService({
-      apiKey: config.apiKey,
-      defaultModel: GeminiModel.PRO,
-      fallbackModel: GeminiModel.FLASH,
-      maxRetries: 3,
-      timeout: 60_000,
-    });
-
-    this.outputDirectory = config.outputDir ?? path.join(process.cwd(), 'analysis_output');
-    if (!fs.existsSync(this.outputDirectory)) {
-      fs.mkdirSync(this.outputDirectory, { recursive: true });
-    }
-
-    this.station1 = new Station1TextAnalysis(this.createStationConfig<Station1Input, Station1Output>(1, 'Text Analysis'), this.geminiService);
-    this.station2 = new Station2ConceptualAnalysis(this.createStationConfig<Station2Input, Station2Output>(2, 'Conceptual Analysis'), this.geminiService);
-    this.station3 = new Station3NetworkBuilder(this.createStationConfig<Station3Input, Station3Output>(3, 'Network Builder'), this.geminiService);
-    this.station4 = new Station4EfficiencyMetrics(this.createStationConfig<Station4Input, Station4Output>(4, 'Efficiency Metrics'), this.geminiService);
-    this.station5 = new Station5DynamicSymbolicStylistic(this.createStationConfig<Station5Input, Station5Output>(5, 'Dynamic/Symbolic/Stylistic Analysis'), this.geminiService);
-    this.station6 = new Station6DiagnosticsAndTreatment(this.createStationConfig<Station6Input, Station6Output>(6, 'Diagnostics & Treatment'), this.geminiService);
-    this.station7 = new Station7Finalization(
-      this.createStationConfig<Station7Input, Station7Output>(7, 'Finalization & Visualization'),
-      this.geminiService,
-      this.outputDirectory,
-    );
-
-    for (let i = 1; i <= 7; i += 1) {
-      this.stationStatuses.set(i, 'pending');
-    }
-  }
-
-  getStationStatus(): Record<string, string> {
-    const status: Record<string, string> = {};
-    this.stationStatuses.forEach((value, key) => {
-      status[`station${key}`] = value;
-    });
-    return status;
-  }
-
-  async runFullAnalysis(input: PipelineInput): Promise<PipelineRunResult> {
-    const startedAt = Date.now();
-    let stationsCompleted = 0;
-    const stationData = new Map<number, unknown>();
-
-    const runStation = async <TOutput>(
-      stationNumber: number,
-      execute: () => Promise<{ output: TOutput }>,
-    ): Promise<TOutput> => {
-      this.stationStatuses.set(stationNumber, 'running');
-      try {
-        const { output } = await execute();
-        this.stationStatuses.set(stationNumber, 'completed');
-        stationsCompleted += 1;
-        stationData.set(stationNumber, output);
-        return output;
-      } catch (error) {
-        this.stationStatuses.set(stationNumber, 'error');
-        logger.error(`Station ${stationNumber} failed`, {
-          error: error instanceof Error ? error.message : 'Unknown error',
-        });
-        throw error;
-      }
-    };
-
-    const station1Output = await runStation(1, () => this.station1.execute({
-      fullText: input.fullText,
-      projectName: input.projectName,
-      proseFilePath: input.proseFilePath,
-    }));
-
-    const station2Output = await runStation(2, () => this.station2.execute({
-      station1Output,
-      fullText: input.fullText,
-    }));
-
-    const station3Output = await runStation(3, () => this.station3.execute({
-      station1Output,
-      station2Output,
-      fullText: input.fullText,
-    }));
-
-    const station4Output = await runStation(4, () => this.station4.execute({
-      station3Output,
-    }));
-
-    const station5Output = await runStation(5, () => this.station5.execute({
-      conflictNetwork: station3Output.conflictNetwork,
-      station4Output,
-      fullText: input.fullText,
-    }));
-
-    const station6Output = await runStation(6, () => this.station6.execute({
-      conflictNetwork: station3Output.conflictNetwork,
-      station5Output,
-    }));
-
-    const station7Output = await runStation(7, () => this.station7.execute({
-      conflictNetwork: station3Output.conflictNetwork,
-      station6Output,
-      allPreviousStationsData: stationData,
-    }));
-
-    const finishedAt = Date.now();
-
-    return {
-      stationOutputs: {
-        station1: station1Output,
-        station2: station2Output,
-        station3: station3Output,
-        station4: station4Output,
-        station5: station5Output,
-        station6: station6Output,
-        station7: station7Output,
-      },
-      pipelineMetadata: {
-        stationsCompleted,
-        totalExecutionTime: finishedAt - startedAt,
-        startedAt: new Date(startedAt).toISOString(),
-        finishedAt: new Date(finishedAt).toISOString(),
-      },
-    };
-  }
-
-  private createStationConfig<TInput, TOutput>(
-    stationNumber: number,
-    stationName: string,
-  ): StationConfig<TInput, TOutput> {
-    return {
-      stationNumber,
-      stationName,
-      cacheEnabled: false,
-      performanceTracking: true,
-      inputValidation: (input: TInput) => input !== undefined && input !== null,
-      outputValidation: (output: TOutput) => output !== undefined && output !== null,
-    };
-  }
-}
diff --git a/backup_20251003_052813/server/services/ai/gemini-service.ts b/backup_20251003_052813/server/services/ai/gemini-service.ts
deleted file mode 100644
index 12fa47e..0000000
--- a/backup_20251003_052813/server/services/ai/gemini-service.ts
+++ /dev/null
@@ -1,145 +0,0 @@
-import { GoogleGenerativeAI } from '@google/generative-ai';
-import logger from '../../utils/logger';
-
-export enum GeminiModel {
-  PRO = 'gemini-2.5-pro',
-  FLASH = 'gemini-2.0-flash-lite',
-}
-
-export interface GeminiConfig {
-  apiKey: string;
-  defaultModel: GeminiModel;
-  maxRetries: number;
-  timeout: number;
-  fallbackModel?: GeminiModel;
-}
-
-export interface GeminiRequest {
-  prompt: string;
-  model: GeminiModel;
-  context?: string;
-  systemInstruction?: string;
-  temperature?: number;
-  maxTokens?: number;
-}
-
-export interface GeminiResponse<T> {
-  model: GeminiModel;
-  content: T;
-  usage: {
-    promptTokens: number;
-    completionTokens: number;
-    totalTokens: number;
-  };
-  metadata: {
-    timestamp: Date;
-    latency: number;
-  };
-}
-
-export class GeminiService {
-  private genAI: GoogleGenerativeAI;
-  private config: GeminiConfig;
-
-  constructor(config: GeminiConfig) {
-    this.config = config;
-    this.genAI = new GoogleGenerativeAI(config.apiKey);
-    this.validateModels();
-  }
-
-  private validateModels(): void {
-    const allowedModels = Object.values(GeminiModel);
-    if (!allowedModels.includes(this.config.defaultModel)) {
-      throw new Error(
-        `Invalid model: ${this.config.defaultModel}. ` +
-        `Only ${allowedModels.join(', ')} are allowed.`
-      );
-    }
-
-    if (this.config.fallbackModel && !allowedModels.includes(this.config.fallbackModel)) {
-      throw new Error(
-        `Invalid fallback model: ${this.config.fallbackModel}. ` +
-        `Only ${allowedModels.join(', ')} are allowed.`
-      );
-    }
-  }
-
-  async generate<T>(request: GeminiRequest): Promise<GeminiResponse<T>> {
-    this.validateModels();
-
-    const primaryModel = request.model ?? this.config.defaultModel;
-
-    try {
-      return await this.performRequest<T>({ ...request, model: primaryModel });
-    } catch (primaryError) {
-      if (
-        this.config.fallbackModel &&
-        this.config.fallbackModel !== primaryModel
-      ) {
-        logger.warn('Primary Gemini model failed. Falling back to secondary model.', {
-          primaryModel,
-          fallbackModel: this.config.fallbackModel,
-        });
-
-        return this.performRequest<T>({ ...request, model: this.config.fallbackModel });
-      }
-
-      return this.handleError<T>(primaryError, request);
-    }
-  }
-
-  private async performRequest<T>(request: GeminiRequest): Promise<GeminiResponse<T>> {
-    const startTime = Date.now();
-    const model = this.genAI.getGenerativeModel({ model: request.model });
-
-    const fullPrompt = `${request.systemInstruction || ''}\n\nContext: ${request.context || 'N/A'}\n\nPrompt: ${request.prompt}`;
-
-    const result = await model.generateContent(fullPrompt);
-    const response = result.response;
-    const text = response.text();
-
-    const usage = {
-      promptTokens: fullPrompt.length / 4,
-      completionTokens: text.length / 4,
-      totalTokens: (fullPrompt.length + text.length) / 4,
-    };
-
-    return {
-      model: request.model,
-      content: this.parseResponse<T>(text),
-      usage,
-      metadata: {
-        timestamp: new Date(),
-        latency: Date.now() - startTime,
-      },
-    };
-  }
-
-  private parseResponse<T>(responseText: string): T {
-    try {
-      // Clean the response to extract only the JSON part
-      const jsonMatch = responseText.match(/```json\n([\s\S]*?)\n```/);
-      if (jsonMatch && jsonMatch[1]) {
-        return JSON.parse(jsonMatch[1]) as T;
-      }
-      // Fallback for responses that might just be JSON without markdown
-      return JSON.parse(responseText) as T;
-    } catch (error) {
-      logger.warn('Failed to parse JSON from response. Returning raw text.', {
-        error: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return { raw: responseText } as unknown as T;
-    }
-  }
-
-  private async handleError<T>(
-    error: unknown,
-    request: GeminiRequest
-  ): Promise<never> {
-    const message = error instanceof Error ? error.message : 'Unknown error';
-    logger.error(`Failed to generate content with model ${request.model}`, {
-      error: message,
-    });
-    throw error instanceof Error ? error : new Error(message);
-  }
-}
\ No newline at end of file
diff --git a/backup_20251003_052813/server/services/ai/result-selector.ts b/backup_20251003_052813/server/services/ai/result-selector.ts
deleted file mode 100644
index ea91a48..0000000
--- a/backup_20251003_052813/server/services/ai/result-selector.ts
+++ /dev/null
@@ -1,66 +0,0 @@
-import { GeminiModel, GeminiResponse } from './gemini-service';
-
-export interface SelectionCriteria {
-  preferredModels: GeminiModel[];
-  validationFunction?: (result: any) => boolean;
-  scoreFunction?: (result: any) => number;
-}
-
-export class AIResultSelector {
-  selectBest<T>(
-    results: Map<GeminiModel, GeminiResponse<T>>,
-    criteria: SelectionCriteria
-  ): GeminiResponse<T> | null {
-    const validResults = this.filterValid(results, criteria);
-
-    if (validResults.size === 0) {
-      return null;
-    }
-
-    for (const model of criteria.preferredModels) {
-      if (validResults.has(model)) {
-        return validResults.get(model)!;
-      }
-    }
-
-    if (criteria.scoreFunction) {
-      return this.selectByScore(validResults, criteria.scoreFunction);
-    }
-
-    return Array.from(validResults.values())[0];
-  }
-
-  private filterValid<T>(
-    results: Map<GeminiModel, GeminiResponse<T>>,
-    criteria: SelectionCriteria
-  ): Map<GeminiModel, GeminiResponse<T>> {
-    const filtered = new Map<GeminiModel, GeminiResponse<T>>();
-
-    for (const [model, response] of Array.from(results.entries())) {
-      if (!criteria.validationFunction || 
-          criteria.validationFunction(response.content)) {
-        filtered.set(model, response);
-      }
-    }
-
-    return filtered;
-  }
-
-  private selectByScore<T>(
-    results: Map<GeminiModel, GeminiResponse<T>>,
-    scoreFunction: (result: any) => number
-  ): GeminiResponse<T> {
-    let bestScore = -Infinity;
-    let bestResult: GeminiResponse<T> | null = null;
-
-    for (const response of Array.from(results.values())) {
-      const score = scoreFunction(response.content);
-      if (score > bestScore) {
-        bestScore = score;
-        bestResult = response;
-      }
-    }
-
-    return bestResult!;
-  }
-}
diff --git a/backup_20251003_052813/server/stations/station1/station1-text-analysis.ts b/backup_20251003_052813/server/stations/station1/station1-text-analysis.ts
deleted file mode 100644
index 8b11483..0000000
--- a/backup_20251003_052813/server/stations/station1/station1-text-analysis.ts
+++ /dev/null
@@ -1,281 +0,0 @@
-import { BaseStation, type StationConfig } from '../../core/pipeline/base-station';
-import { GeminiService, GeminiModel } from '../../services/ai/gemini-service';
-
-type MajorCharactersResponse = {
-  major_characters?: string[];
-  raw?: unknown;
-};
-
-type CharacterAnalysisResponse = {
-  personality_traits?: string;
-  motivations_goals?: string;
-  key_relationships_brief?: string;
-  narrative_function?: string;
-  potential_arc_observation?: string;
-  raw?: unknown;
-};
-
-type RelationshipAnalysisResponse = {
-  key_relationships?: Array<{
-    characters?: [string, string];
-    dynamic?: string;
-    narrative_importance?: string;
-  }>;
-  raw?: unknown;
-};
-
-type NarrativeStyleResponse = {
-  overall_tone?: string;
-  pacing_analysis?: string;
-  language_style?: string;
-  raw?: unknown;
-};
-
-export interface Station1Input {
-  fullText: string;
-  projectName: string;
-  proseFilePath?: string;
-}
-
-export interface CharacterAnalysisResult {
-  personalityTraits: string;
-  motivationsGoals: string;
-  keyRelationshipsBrief: string;
-  narrativeFunction: string;
-  potentialArcObservation: string;
-}
-
-export interface RelationshipAnalysisResult {
-  keyRelationships: Array<{
-    characters: [string, string];
-    dynamic: string;
-    narrativeImportance: string;
-  }>;
-}
-
-export interface NarrativeStyleResult {
-  overallTone: string;
-  pacingAnalysis: string;
-  languageStyle: string;
-}
-
-export interface Station1Output {
-  majorCharacters: string[];
-  characterAnalysis: Map<string, CharacterAnalysisResult>;
-  relationshipAnalysis: RelationshipAnalysisResult;
-  narrativeStyleAnalysis: NarrativeStyleResult;
-  metadata: {
-    analysisTimestamp: Date;
-    status: 'Success' | 'Partial' | 'Failed';
-  };
-}
-
-export class Station1TextAnalysis extends BaseStation<Station1Input, Station1Output> {
-  
-  constructor(
-    config: StationConfig,
-    geminiService: GeminiService
-  ) {
-    super(config, geminiService);
-  }
-
-  protected async process(input: Station1Input): Promise<Station1Output> {
-    const [
-      majorCharacters,
-      relationshipAnalysis,
-      narrativeStyle
-    ] = await Promise.all([
-      this.identifyMajorCharacters(input.fullText),
-      this.analyzeRelationships(input.fullText),
-      this.analyzeNarrativeStyle(input.fullText)
-    ]);
-
-    const characterAnalysis = await this.analyzeCharactersInDepth(
-      input.fullText,
-      majorCharacters
-    );
-
-    return {
-      majorCharacters,
-      characterAnalysis,
-      relationshipAnalysis,
-      narrativeStyleAnalysis: narrativeStyle,
-      metadata: {
-        analysisTimestamp: new Date(),
-        status: 'Success'
-      }
-    };
-  }
-
-  private async identifyMajorCharacters(
-    fullText: string
-  ): Promise<string[]> {
-    const prompt = `
-بناءً على النص السردي الكامل المرفق، قم بتحليل النص وتحديد الشخصيات التي تبدو **الأكثر مركزية وأهمية** للحبكة وتطور الأحداث. 
-ركز على الشخصيات التي لها أدوار فاعلة، دوافع واضحة، وتظهر بشكل متكرر ومؤثر.
-أعد قائمة تتضمن **ما بين 3 إلى 7 شخصيات** تعتبرها الأكثر أهمية.
-
-أعد الإجابة **حصرياً** بتنسيق JSON صالح:
-{
-  "major_characters": ["اسم الشخصية 1", "اسم الشخصية 2", ...]
-}
-    `;
-
-    const result = await this.geminiService.generate<MajorCharactersResponse>({
-      prompt,
-      context: fullText.substring(0, 30000),
-      model: GeminiModel.PRO
-    });
-
-    return result.content.major_characters ?? [];
-  }
-
-  private async analyzeCharactersInDepth(
-    fullText: string,
-    characterNames: string[]
-  ): Promise<Map<string, CharacterAnalysisResult>> {
-    const analyses = new Map<string, CharacterAnalysisResult>();
-
-    const analysisPromises = characterNames.map(name =>
-      this.analyzeCharacter(fullText, name)
-    );
-
-    const results = await Promise.all(analysisPromises);
-
-    characterNames.forEach((name, index) => {
-      analyses.set(name, results[index]);
-    });
-
-    return analyses;
-  }
-
-  private async analyzeCharacter(
-    fullText: string,
-    characterName: string
-  ): Promise<CharacterAnalysisResult> {
-    const prompt = `
-بناءً على النص السردي الكامل المرفق، قم بإجراء تحليل **شامل ومعمق** للشخصية المحددة التالية: **${characterName}**.
-
-المطلوب تحليل الجوانب التالية لهذه الشخصية:
-1. السمات الشخصية البارزة (إيجابية وسلبية)
-2. الدوافع الأساسية والأهداف (الظاهرة والخفية)
-3. وصف موجز لأهم علاقاتها مع شخصيات أخرى
-4. الدور أو الوظيفة الرئيسية في القصة
-5. ملاحظات أولية حول قوس التطور المحتمل
-
-أعد الإجابة **حصرياً** بتنسيق JSON صالح:
-{
-  "personality_traits": "...",
-  "motivations_goals": "...",
-  "key_relationships_brief": "...",
-  "narrative_function": "...",
-  "potential_arc_observation": "..."
-}
-    `;
-
-    const result = await this.geminiService.generate<CharacterAnalysisResponse>({
-      prompt,
-      context: fullText.substring(0, 30000),
-      model: GeminiModel.PRO
-    });
-
-    return {
-      personalityTraits: result.content.personality_traits ?? 'N/A',
-      motivationsGoals: result.content.motivations_goals ?? 'N/A',
-      keyRelationshipsBrief: result.content.key_relationships_brief ?? 'N/A',
-      narrativeFunction: result.content.narrative_function ?? 'N/A',
-      potentialArcObservation: result.content.potential_arc_observation ?? 'N/A'
-    };
-  }
-
-  private async analyzeRelationships(
-    fullText: string
-  ): Promise<RelationshipAnalysisResult> {
-    const prompt = `
-بناءً على النص السردي الكامل المرفق، قم بتحليل وتحديد **العلاقات الرئيسية** بين الشخصيات.
-ركز على العلاقات التي لها تأثير واضح على الحبكة وتطور الأحداث.
-
-أعد الإجابة **حصرياً** بتنسيق JSON صالح:
-{
-  "key_relationships": [
-    {
-      "characters": ["الشخصية 1", "الشخصية 2"],
-      "dynamic": "وصف ديناميكية العلاقة",
-      "narrative_importance": "أهمية العلاقة في السرد"
-    }
-  ]
-}
-    `;
-
-    const result = await this.geminiService.generate<RelationshipAnalysisResponse>({
-      prompt,
-      context: fullText.substring(0, 30000),
-      model: GeminiModel.PRO
-    });
-
-    return {
-      keyRelationships: (result.content.key_relationships ?? []).map((rel) => ({
-        characters: rel?.characters ?? ['غير معروف', 'غير معروف'],
-        dynamic: rel?.dynamic ?? 'N/A',
-        narrativeImportance: rel?.narrative_importance ?? 'N/A'
-      }))
-    };
-  }
-
-  private async analyzeNarrativeStyle(
-    fullText: string
-  ): Promise<NarrativeStyleResult> {
-    const prompt = `
-بناءً على النص السردي الكامل المرفق، قم بتحليل **الأسلوب السردي** للنص.
-
-المطلوب تحليل:
-1. النغمة الإجمالية للنص (درامي، كوميدي، تراجيدي، إلخ)
-2. تحليل وتيرة السرد (سريع، بطيء، متنوع، إلخ)
-3. أسلوب اللغة المستخدمة (رسمي، عامي، شاعري، إلخ)
-
-أعد الإجابة **حصرياً** بتنسيق JSON صالح:
-{
-  "overall_tone": "...",
-  "pacing_analysis": "...",
-  "language_style": "..."
-}
-    `;
-
-    const result = await this.geminiService.generate<NarrativeStyleResponse>({
-      prompt,
-      context: fullText.substring(0, 30000),
-      model: GeminiModel.PRO
-    });
-
-    return {
-      overallTone: result.content.overall_tone ?? 'N/A',
-      pacingAnalysis: result.content.pacing_analysis ?? 'N/A',
-      languageStyle: result.content.language_style ?? 'N/A'
-    };
-  }
-
-  protected extractRequiredData(input: Station1Input): Record<string, unknown> {
-    return {
-      fullTextLength: input.fullText.length,
-      projectName: input.projectName,
-      hasProseFilePath: Boolean(input.proseFilePath)
-    };
-  }
-
-  protected getErrorFallback(): Station1Output {
-    return {
-      majorCharacters: [],
-      characterAnalysis: new Map(),
-      relationshipAnalysis: { keyRelationships: [] },
-      narrativeStyleAnalysis: {
-        overallTone: 'Error',
-        pacingAnalysis: 'Error',
-        languageStyle: 'Error'
-      },
-      metadata: {
-        analysisTimestamp: new Date(),
-        status: 'Failed'
-      }
-    };
-  }
-}
diff --git a/backup_20251003_052813/server/stations/station2/station2-conceptual-analysis.ts b/backup_20251003_052813/server/stations/station2/station2-conceptual-analysis.ts
deleted file mode 100644
index ff7cee5..0000000
--- a/backup_20251003_052813/server/stations/station2/station2-conceptual-analysis.ts
+++ /dev/null
@@ -1,336 +0,0 @@
-import { BaseStation, type StationConfig } from '../../core/pipeline/base-station';
-import { GeminiService, GeminiModel } from '../../services/ai/gemini-service';
-import { Station1Output } from '../station1/station1-text-analysis';
-
-export interface Station2Input {
-  station1Output: Station1Output;
-  fullText: string;
-}
-
-export interface ThreeDMapResult {
-  horizontalEventsAxis: Array<{
-    event: string;
-    sceneRef: string;
-  }>;
-  verticalMeaningAxis: Array<{
-    eventRef: string;
-    symbolicLayer: string;
-  }>;
-  temporalDevelopmentAxis: {
-    pastInfluence: string;
-    presentChoices: string;
-    futureExpectations: string;
-    heroArcConnection: string;
-  };
-}
-
-export interface GenreMatrixResult {
-  [genreName: string]: {
-    conflictContribution: string;
-    pacingContribution: string;
-    visualCompositionContribution: string;
-    soundMusicContribution: string;
-    charactersContribution: string;
-  };
-}
-
-export interface DynamicToneResult {
-  [stageName: string]: {
-    visualAtmosphereDescribed: string;
-    writtenPacing: string;
-    dialogueStructure: string;
-    soundIndicationsDescribed: string;
-  };
-}
-
-export interface ArtisticReferencesResult {
-  visualReferences: Array<{
-    work: string;
-    reason: string;
-  }>;
-  musicalMood: string;
-}
-
-export interface Station2Output {
-  storyStatement: string;
-  threeDMap: ThreeDMapResult;
-  elevatorPitch: string;
-  hybridGenre: string;
-  genreContributionMatrix: GenreMatrixResult;
-  dynamicTone: DynamicToneResult;
-  artisticReferences: ArtisticReferencesResult;
-  metadata: {
-    analysisTimestamp: Date;
-    status: 'Success' | 'Partial' | 'Failed';
-  };
-}
-
-export class Station2ConceptualAnalysis extends BaseStation<Station2Input, Station2Output> {
-  
-  constructor(
-    config: StationConfig,
-    geminiService: GeminiService
-  ) {
-    super(config, geminiService);
-  }
-
-  protected async process(input: Station2Input): Promise<Station2Output> {
-    const context = this.buildContextFromStation1(input.station1Output);
-    
-    const [
-      storyStatements,
-      threeDMap,
-      hybridGenreOptions
-    ] = await Promise.all([
-      this.generateStoryStatements(context, input.fullText),
-      this.generate3DMap(context, input.fullText),
-      this.generateHybridGenre(context, input.fullText)
-    ]);
-
-    const storyStatement = storyStatements[0];
-    const hybridGenre = hybridGenreOptions[0];
-
-    const [
-      elevatorPitch,
-      genreMatrix,
-      dynamicTone,
-      artisticReferences
-    ] = await Promise.all([
-      this.generateElevatorPitch(storyStatement),
-      this.generateGenreMatrix(hybridGenre, context, input.fullText),
-      this.generateDynamicTone(hybridGenre, context, input.fullText),
-      this.generateArtisticReferences(hybridGenre, context, input.fullText)
-    ]);
-
-    return {
-      storyStatement,
-      threeDMap,
-      elevatorPitch,
-      hybridGenre,
-      genreContributionMatrix: genreMatrix,
-      dynamicTone,
-      artisticReferences,
-      metadata: {
-        analysisTimestamp: new Date(),
-        status: 'Success'
-      }
-    };
-  }
-
-  private buildContextFromStation1(s1Output: Station1Output): Record<string, unknown> {
-    return {
-      majorCharacters: s1Output.majorCharacters,
-      characterProfiles: Array.from(s1Output.characterAnalysis.entries()).map(([name, analysis]) => ({
-        name,
-        traits: analysis.personalityTraits,
-        motivations: analysis.motivationsGoals
-      })),
-      keyRelationships: s1Output.relationshipAnalysis.keyRelationships,
-      narrativeStyle: s1Output.narrativeStyleAnalysis
-    };
-  }
-
-  private async generateStoryStatements(context: Record<string, unknown>, fullText: string): Promise<string[]> {
-    const prompt = `
-بصفتك مساعد كتابة سيناريو خبير، ومستندًا إلى ملخص السيناريو الأولي والنص الكامل المرفقين، 
-اقترح **ثلاثة (3)** بدائل متميزة لـ "بيان القصة" (Story Statement).
-
-كل بيان يجب أن يتكون من **أربع جمل**، تغطي:
-1. الحدث المحوري الجامع أو نقطة الانطلاق
-2. الصراعات المتشابكة أو الدوافع المتقاطعة
-3. العالم القصصي المميز والموحد
-4. الثيمة أو السؤال الفلسفي الجامع
-
-السياق: ${JSON.stringify(context, null, 2)}
-
-أعد الإجابة **حصرياً** بتنسيق JSON:
-{
-  "story_statement_alternatives": [
-    "بيان القصة الأول (4 جمل)...",
-    "بيان القصة الثاني (4 جمل)...",
-    "بيان القصة الثالث (4 جمل)..."
-  ]
-}
-    `;
-
-    const result = await this.geminiService.generate<{
-      story_statement_alternatives: string[];
-    }>({
-      prompt,
-      context: fullText.substring(0, 25000),
-      model: GeminiModel.PRO,
-      temperature: 0.8
-    });
-
-    return result.content.story_statement_alternatives || ['فشل توليد بيان القصة'];
-  }
-
-  private async generate3DMap(context: Record<string, unknown>, fullText: string): Promise<ThreeDMapResult> {
-    const prompt = `
-بناءً على السياق: ${JSON.stringify(context, null, 2)}
-
-قم بإنشاء **"خريطة ثلاثية الأبعاد" (3D Map)** للقصة:
-
-أعد النتائج بتنسيق JSON:
-{
-  "horizontal_events_axis": [
-    {"event": "حدث مختصر", "scene_ref": "رقم المشهد"},
-    ...
-  ],
-  "vertical_meaning_axis": [
-    {"event_ref": "وصف الحدث", "symbolic_layer": "الطبقة الرمزية"},
-    ...
-  ],
-  "temporal_development_axis": {
-    "past_influence": "تأثير الماضي...",
-    "present_choices": "خيارات الحاضر...",
-    "future_expectations": "توقعات المستقبل...",
-    "hero_arc_connection": "ارتباط بقوس البطل..."
-  }
-}
-    `;
-
-    const result = await this.geminiService.generate<ThreeDMapResult>({
-      prompt,
-      context: fullText.substring(0, 25000),
-      model: GeminiModel.PRO,
-      temperature: 0.7
-    });
-
-    return result.content || this.getDefault3DMap();
-  }
-
-  private async generateElevatorPitch(storyStatement: string): Promise<string> {
-    const prompt = `
-بناءً على بيان القصة: "${storyStatement}"
-
-صغ "Elevator Pitch" جذاب وموجز (لا يتجاوز 40 كلمة).
-
-أعد الإجابة بتنسيق JSON:
-{
-  "elevator_pitch": "النص هنا..."
-}
-    `;
-
-    const result = await this.geminiService.generate<{
-      elevator_pitch: string;
-    }>({
-      prompt,
-      model: GeminiModel.PRO,
-      temperature: 0.9
-    });
-
-    return result.content.elevator_pitch || 'فشل توليد العرض المختصر';
-  }
-
-  private async generateHybridGenre(context: any, fullText: string): Promise<string[]> {
-    const prompt = `
-بناءً على السياق والنص الكامل، اقترح **ما بين 3 إلى 5 بدائل** 
-لتركيبة **"نوع هجين" (Hybrid Genre)** دقيقة ومناسبة.
-
-السياق: ${JSON.stringify(context, null, 2)}
-
-أعد الإجابة بتنسيق JSON:
-{
-  "hybrid_genre_alternatives": [
-    "النوع الهجين الأول مع الشرح...",
-    "النوع الهجين الثاني مع الشرح...",
-    ...
-  ]
-}
-    `;
-
-    const result = await this.geminiService.generate<{
-      hybrid_genre_alternatives: string[];
-    }>({
-      prompt,
-      context: fullText.substring(0, 20000),
-      model: GeminiModel.PRO,
-      temperature: 0.8
-    });
-
-    return result.content.hybrid_genre_alternatives || ['Drama-Thriller'];
-  }
-
-  private async generateGenreMatrix(hybridGenre: string, context: any, fullText: string): Promise<GenreMatrixResult> {
-    const prompt = `
-بناءً على النوع الهجين المعتمد: "${hybridGenre}"
-
-أنشئ **"مصفوفة مساهمة النوع"** توضح كيف يُثري كل نوع أساسي:
-
-أعد النتائج بتنسيق JSON:
-{
-  "genre_contribution_matrix": {
-    "النوع الأول": {
-      "conflict_contribution": "...",
-      "pacing_contribution": "...",
-      "visual_composition_contribution": "...",
-      "sound_music_contribution": "...",
-      "characters_contribution": "..."
-    }
-  }
-}
-    `;
-
-    const result = await this.geminiService.generate<{
-      genre_contribution_matrix: GenreMatrixResult;
-    }>({
-      prompt,
-      context: fullText.substring(0, 15000),
-      model: GeminiModel.PRO,
-      temperature: 0.7
-    });
-
-    return result.content.genre_contribution_matrix || {};
-  }
-
-  private async generateDynamicTone(hybridGenre: string, context: Record<string, unknown>, fullText: string): Promise<DynamicToneResult> {
-    return {};
-  }
-
-  private async generateArtisticReferences(hybridGenre: string, context: Record<string, unknown>, fullText: string): Promise<ArtisticReferencesResult> {
-    return {
-      visualReferences: [],
-      musicalMood: ''
-    };
-  }
-
-  private getDefault3DMap(): ThreeDMapResult {
-    return {
-      horizontalEventsAxis: [],
-      verticalMeaningAxis: [],
-      temporalDevelopmentAxis: {
-        pastInfluence: '',
-        presentChoices: '',
-        futureExpectations: '',
-        heroArcConnection: ''
-      }
-    };
-  }
-
-  protected extractRequiredData(input: Station2Input): Record<string, unknown> {
-    return {
-      majorCharacters: input.station1Output.majorCharacters.slice(0, 5),
-      fullTextLength: input.fullText.length
-    };
-  }
-
-  protected getErrorFallback(): Station2Output {
-    return {
-      storyStatement: 'Error',
-      threeDMap: this.getDefault3DMap(),
-      elevatorPitch: 'Error',
-      hybridGenre: 'Error',
-      genreContributionMatrix: {},
-      dynamicTone: {},
-      artisticReferences: {
-        visualReferences: [],
-        musicalMood: ''
-      },
-      metadata: {
-        analysisTimestamp: new Date(),
-        status: 'Failed'
-      }
-    };
-  }
-}
\ No newline at end of file
diff --git a/backup_20251003_052813/server/stations/station3/station3-network-builder.ts b/backup_20251003_052813/server/stations/station3/station3-network-builder.ts
deleted file mode 100644
index 6040b43..0000000
--- a/backup_20251003_052813/server/stations/station3/station3-network-builder.ts
+++ /dev/null
@@ -1,403 +0,0 @@
-import { BaseStation, type StationConfig } from '../../core/pipeline/base-station';
-import { GeminiService, GeminiModel } from '../../services/ai/gemini-service';
-import { 
-  Character, 
-  Relationship, 
-  Conflict, 
-  ConflictNetwork, 
-  ConflictNetworkImpl,
-  RelationshipType,
-  RelationshipNature,
-  RelationshipDirection,
-  ConflictSubject,
-  ConflictScope,
-  ConflictPhase
-} from '../../core/models/base-entities';
-import { Station1Output } from '../station1/station1-text-analysis';
-import { Station2Output } from '../station2/station2-conceptual-analysis';
-import logger from '../../utils/logger';
-
-export interface Station3Input {
-  station1Output: Station1Output;
-  station2Output: Station2Output;
-  fullText: string;
-}
-
-export interface Station3Output {
-  conflictNetwork: ConflictNetwork;
-  networkSummary: {
-    charactersCount: number;
-    relationshipsCount: number;
-    conflictsCount: number;
-    snapshotsCount: number;
-  };
-  metadata: {
-    analysisTimestamp: Date;
-    status: 'Success' | 'Partial' | 'Failed';
-    buildTime: number;
-  };
-}
-
-class RelationshipInferenceEngine {
-  constructor(
-    private geminiService: GeminiService
-  ) {}
-
-  async inferRelationships(
-    characters: Character[],
-    s1RelationshipsHints: any,
-    s2Context: any,
-    fullText: string
-  ): Promise<Relationship[]> {
-    const charactersList = characters.map(c => 
-      `'${c.name}' (ID: ${c.id})`
-    ).join(', ');
-
-    const prompt = `
-استنادًا إلى السياق المقدم، قم باستنتاج العلاقات الرئيسية بين الشخصيات.
-
-الشخصيات المتاحة: ${charactersList}
-
-لكل علاقة رئيسية:
-1. حدد الشخصيتين (بالاسم أو ID)
-2. اقترح نوع العلاقة (${Object.values(RelationshipType).join(', ')})
-3. اقترح طبيعة العلاقة (${Object.values(RelationshipNature).join(', ')})
-4. وصف موجز للعلاقة
-5. قوة العلاقة (1-10)
-6. اتجاه العلاقة (${Object.values(RelationshipDirection).join(', ')})
-7. المحفزات المؤثرة
-
-أعد الإجابة بتنسيق JSON:
-{
-  "inferred_relationships": [
-    {
-      "character1_name_or_id": "...",
-      "character2_name_or_id": "...",
-      "relationship_type": "...",
-      "relationship_nature": "...",
-      "description_rationale": "...",
-      "strength": 7,
-      "direction": "...",
-      "triggers": ["محفز 1", "محفز 2"]
-    }
-  ]
-}
-    `;
-
-    const result = await this.geminiService.generate<{
-      inferred_relationships: any[];
-    }>({
-      prompt,
-      context: fullText.substring(0, 25000),
-      model: GeminiModel.PRO,
-      temperature: 0.7
-    });
-
-    const inferredData = result.content.inferred_relationships || [];
-    
-    return this.convertToRelationships(inferredData, characters);
-  }
-
-  private convertToRelationships(inferredData: any[], characters: Character[]): Relationship[] {
-    const relationships: Relationship[] = [];
-    const charNameToId = new Map(characters.map(c => [c.name, c.id]));
-
-    for (const data of inferredData) {
-      const sourceId = charNameToId.get(data.character1_name_or_id) || data.character1_name_or_id;
-      const targetId = charNameToId.get(data.character2_name_or_id) || data.character2_name_or_id;
-
-      if (!sourceId || !targetId || sourceId === targetId) {
-        continue;
-      }
-
-      try {
-        const relationship: Relationship = {
-          id: `rel_${sourceId}_${targetId}_${Date.now()}`,
-          source: sourceId,
-          target: targetId,
-          type: this.parseRelationshipType(data.relationship_type),
-          nature: this.parseRelationshipNature(data.relationship_nature),
-          direction: this.parseRelationshipDirection(data.direction),
-          strength: parseInt(data.strength) || 5,
-          description: data.description_rationale || '',
-          triggers: data.triggers || [],
-          metadata: {
-            source: 'AI_Inference_Engine',
-            inferenceTimestamp: new Date().toISOString()
-          }
-        };
-
-        relationships.push(relationship);
-      } catch (error) {
-        logger.error('Error parsing relationship', {
-          error: error instanceof Error ? error.message : 'Unknown error',
-        });
-      }
-    }
-
-    return relationships;
-  }
-
-  private parseRelationshipType(typeStr: string): RelationshipType {
-    const normalized = typeStr?.toUpperCase().replace(/[- ]/g, '_');
-    return RelationshipType[normalized as keyof typeof RelationshipType] || RelationshipType.OTHER;
-  }
-
-  private parseRelationshipNature(natureStr: string): RelationshipNature {
-    const normalized = natureStr?.toUpperCase().replace(/[- ]/g, '_');
-    return RelationshipNature[normalized as keyof typeof RelationshipNature] || RelationshipNature.NEUTRAL;
-  }
-
-  private parseRelationshipDirection(dirStr: string): RelationshipDirection {
-    const normalized = dirStr?.toUpperCase().replace(/[- ]/g, '_');
-    return RelationshipDirection[normalized as keyof typeof RelationshipDirection] || RelationshipDirection.BIDIRECTIONAL;
-  }
-}
-
-class ConflictInferenceEngine {
-  constructor(
-    private geminiService: GeminiService
-  ) {}
-
-  async inferConflicts(
-    characters: Character[],
-    relationships: Relationship[],
-    s2Context: any,
-    fullText: string
-  ): Promise<Conflict[]> {
-    const charactersSummary = characters.map(c => ({
-      id: c.id,
-      name: c.name,
-      description: c.description
-    }));
-
-    const relationshipsSummary = relationships.slice(0, 5).map(r => {
-      const source = characters.find(c => c.id === r.source);
-      const target = characters.find(c => c.id === r.target);
-      return {
-        characters: [source?.name, target?.name],
-        type: r.type,
-        nature: r.nature
-      };
-    });
-
-    const prompt = `
-استنادًا إلى السياق، قم باستنتاج الصراعات الرئيسية (3-5 صراعات).
-
-الشخصيات: ${JSON.stringify(charactersSummary, null, 2)}
-العلاقات: ${JSON.stringify(relationshipsSummary, null, 2)}
-
-لكل صراع:
-1. اسم الصراع
-2. الشخصيات المشاركة (أسماء أو IDs)
-3. موضوع الصراع (${Object.values(ConflictSubject).join(', ')})
-4. نطاق الصراع (${Object.values(ConflictScope).join(', ')})
-5. المرحلة الأولية (${Object.values(ConflictPhase).join(', ')})
-6. وصف ودليل
-7. قوة الصراع (1-10)
-8. نقاط التحول المحورية
-
-أعد الإجابة بتنسيق JSON:
-{
-  "inferred_conflicts": [
-    {
-      "conflict_name": "...",
-      "involved_character_names_or_ids": ["...", "..."],
-      "subject": "...",
-      "scope": "...",
-      "initial_phase": "...",
-      "description_rationale": "...",
-      "strength": 8,
-      "related_relationships": [],
-      "pivot_points": ["نقطة 1", "نقطة 2"]
-    }
-  ]
-}
-    `;
-
-    const result = await this.geminiService.generate<{
-      inferred_conflicts: any[];
-    }>({
-      prompt,
-      context: fullText.substring(0, 25000),
-      model: GeminiModel.PRO,
-      temperature: 0.7
-    });
-
-    const inferredData = result.content.inferred_conflicts || [];
-    
-    return this.convertToConflicts(inferredData, characters);
-  }
-
-  private convertToConflicts(inferredData: any[], characters: Character[]): Conflict[] {
-    const conflicts: Conflict[] = [];
-    const charNameToId = new Map(characters.map(c => [c.name, c.id]));
-
-    for (const data of inferredData) {
-      const involvedIds = (data.involved_character_names_or_ids || [])
-        .map((ref: string) => charNameToId.get(ref) || ref)
-        .filter((id: string) => id);
-
-      if (involvedIds.length === 0) {
-        continue;
-      }
-
-      try {
-        const conflict: Conflict = {
-          id: `conflict_${Date.now()}_${Math.random()}`,
-          name: data.conflict_name || 'Unnamed Conflict',
-          description: data.description_rationale || '',
-          involvedCharacters: involvedIds,
-          subject: this.parseConflictSubject(data.subject),
-          scope: this.parseConflictScope(data.scope),
-          phase: this.parseConflictPhase(data.initial_phase),
-          strength: parseInt(data.strength) || 5,
-          relatedRelationships: data.related_relationships || [],
-          pivotPoints: data.pivot_points || [],
-          timestamps: [new Date()],
-          metadata: {
-            source: 'AI_Inference_Engine',
-            inferenceTimestamp: new Date().toISOString()
-          }
-        };
-
-        conflicts.push(conflict);
-      } catch (error) {
-        logger.error('Error parsing conflict', {
-          error: error instanceof Error ? error.message : 'Unknown error',
-        });
-      }
-    }
-
-    return conflicts;
-  }
-
-  private parseConflictSubject(subjectStr: string): ConflictSubject {
-    const normalized = subjectStr?.toUpperCase().replace(/[- ]/g, '_');
-    return ConflictSubject[normalized as keyof typeof ConflictSubject] || ConflictSubject.OTHER;
-  }
-
-  private parseConflictScope(scopeStr: string): ConflictScope {
-    const normalized = scopeStr?.toUpperCase().replace(/[- ]/g, '_');
-    return ConflictScope[normalized as keyof typeof ConflictScope] || ConflictScope.PERSONAL;
-  }
-
-  private parseConflictPhase(phaseStr: string): ConflictPhase {
-    const normalized = phaseStr?.toUpperCase().replace(/[- ]/g, '_');
-    return ConflictPhase[normalized as keyof typeof ConflictPhase] || ConflictPhase.EMERGING;
-  }
-}
-
-export class Station3NetworkBuilder extends BaseStation<Station3Input, Station3Output> {
-  private relationshipEngine: RelationshipInferenceEngine;
-  private conflictEngine: ConflictInferenceEngine;
-
-  constructor(
-    config: StationConfig,
-    geminiService: GeminiService
-  ) {
-    super(config, geminiService);
-    this.relationshipEngine = new RelationshipInferenceEngine(geminiService);
-    this.conflictEngine = new ConflictInferenceEngine(geminiService);
-  }
-
-  protected async process(input: Station3Input): Promise<Station3Output> {
-    const startTime = Date.now();
-    
-    // إنشاء الشبكة
-    const network = new ConflictNetworkImpl(
-      `network_${Date.now()}`,
-      `${input.station2Output.storyStatement.substring(0, 50)}...`
-    );
-
-    // إنشاء الشخصيات من المحطة الأولى
-    const characters = this.createCharactersFromStation1(input.station1Output);
-    characters.forEach(char => network.addCharacter(char));
-
-    // استنتاج العلاقات
-    const relationships = await this.relationshipEngine.inferRelationships(
-      characters,
-      input.station1Output.relationshipAnalysis,
-      input.station2Output,
-      input.fullText
-    );
-    relationships.forEach(rel => network.addRelationship(rel));
-
-    // استنتاج الصراعات
-    const conflicts = await this.conflictEngine.inferConflicts(
-      characters,
-      relationships,
-      input.station2Output,
-      input.fullText
-    );
-    conflicts.forEach(conflict => network.addConflict(conflict));
-
-    // إنشاء لقطة أولية
-    network.createSnapshot('Initial network state after AI inference');
-
-    const buildTime = Date.now() - startTime;
-
-    return {
-      conflictNetwork: network,
-      networkSummary: {
-        charactersCount: network.characters.size,
-        relationshipsCount: network.relationships.size,
-        conflictsCount: network.conflicts.size,
-        snapshotsCount: network.snapshots.length
-      },
-      metadata: {
-        analysisTimestamp: new Date(),
-        status: 'Success',
-        buildTime
-      }
-    };
-  }
-
-  private createCharactersFromStation1(s1Output: Station1Output): Character[] {
-    return s1Output.majorCharacters.map((name, index) => {
-      const analysis = s1Output.characterAnalysis.get(name);
-      
-      return {
-        id: `char_${index + 1}`,
-        name,
-        description: analysis?.narrativeFunction || 'شخصية رئيسية',
-        profile: {
-          personalityTraits: analysis?.personalityTraits || '',
-          motivationsGoals: analysis?.motivationsGoals || '',
-          potentialArc: analysis?.potentialArcObservation || ''
-        },
-        metadata: {
-          source: 'Station1_Analysis',
-          analysisTimestamp: s1Output.metadata.analysisTimestamp.toISOString()
-        }
-      };
-    });
-  }
-
-  protected extractRequiredData(input: Station3Input): Record<string, unknown> {
-    return {
-      station1Characters: input.station1Output.majorCharacters.slice(0, 5),
-      station2StoryStatement: input.station2Output.storyStatement,
-      fullTextLength: input.fullText.length
-    };
-  }
-
-  protected getErrorFallback(): Station3Output {
-    const emptyNetwork = new ConflictNetworkImpl('error_network', 'Error Network');
-    
-    return {
-      conflictNetwork: emptyNetwork,
-      networkSummary: {
-        charactersCount: 0,
-        relationshipsCount: 0,
-        conflictsCount: 0,
-        snapshotsCount: 0
-      },
-      metadata: {
-        analysisTimestamp: new Date(),
-        status: 'Failed',
-        buildTime: 0
-      }
-    };
-  }
-}
\ No newline at end of file
diff --git a/backup_20251003_052813/server/stations/station4/station4-efficiency-metrics.ts b/backup_20251003_052813/server/stations/station4/station4-efficiency-metrics.ts
deleted file mode 100644
index fca3775..0000000
--- a/backup_20251003_052813/server/stations/station4/station4-efficiency-metrics.ts
+++ /dev/null
@@ -1,168 +0,0 @@
-import { BaseStation, type StationConfig } from '../../core/pipeline/base-station';
-import { GeminiService, GeminiModel } from '../../services/ai/gemini-service';
-import { EfficiencyAnalyzer, EfficiencyMetrics } from '../../analysis_modules/efficiency-metrics';
-import { Station3Output } from '../station3/station3-network-builder';
-import type { ConflictNetwork } from '../../core/models/base-entities';
-
-export interface Station4Input {
-  station3Output: Station3Output;
-}
-
-export interface Station4Output {
-  efficiencyMetrics: EfficiencyMetrics;
-  recommendations: {
-    priorityActions: string[];
-    quickFixes: string[];
-    structuralRevisions: string[];
-  };
-  metadata: {
-    analysisTimestamp: Date;
-    status: 'Success' | 'Partial' | 'Failed';
-    analysisTime: number;
-  };
-}
-
-export class Station4EfficiencyMetrics extends BaseStation<Station4Input, Station4Output> {
-  private efficiencyAnalyzer: EfficiencyAnalyzer;
-
-  constructor(
-    config: StationConfig,
-    geminiService: GeminiService
-  ) {
-    super(config, geminiService);
-    this.efficiencyAnalyzer = new EfficiencyAnalyzer();
-  }
-
-  protected async process(input: Station4Input): Promise<Station4Output> {
-    const startTime = Date.now();
-    
-    // حساب مقاييس الكفاءة
-    const efficiencyMetrics = this.efficiencyAnalyzer.calculateEfficiencyMetrics(
-      input.station3Output.conflictNetwork
-    );
-
-    // توليد التوصيات بناءً على النتائج
-    const recommendations = await this.generateRecommendations(
-      efficiencyMetrics,
-      input.station3Output.conflictNetwork
-    );
-
-    const analysisTime = Date.now() - startTime;
-
-    return {
-      efficiencyMetrics,
-      recommendations,
-      metadata: {
-        analysisTimestamp: new Date(),
-        status: 'Success',
-        analysisTime
-      }
-    };
-  }
-
-  private async generateRecommendations(
-    metrics: EfficiencyMetrics,
-    _network: ConflictNetwork
-  ): Promise<{
-    priorityActions: string[];
-    quickFixes: string[];
-    structuralRevisions: string[];
-  }> {
-    const context = {
-      overallScore: metrics.overallEfficiencyScore,
-      rating: metrics.overallRating,
-      conflictCohesion: metrics.conflictCohesion,
-      dramaticBalance: metrics.dramaticBalance.balanceScore,
-      narrativeEfficiency: metrics.narrativeEfficiency,
-      redundancy: metrics.redundancyMetrics
-    };
-
-    const prompt = `
-بناءً على تحليل كفاءة الشبكة الدرامية التالي:
-
-النتيجة الإجمالية: ${metrics.overallEfficiencyScore.toFixed(1)}/100
-التصنيف: ${metrics.overallRating}
-تماسك الصراع: ${metrics.conflictCohesion.toFixed(2)}
-التوازن الدرامي: ${metrics.dramaticBalance.balanceScore.toFixed(2)}
-
-اقترح توصيات محددة وعملية لتحسين الشبكة:
-
-أعد الإجابة بتنسيق JSON:
-{
-  "priority_actions": [
-    "إجراء عالي الأولوية 1",
-    "إجراء عالي الأولوية 2",
-    "إجراء عالي الأولوية 3"
-  ],
-  "quick_fixes": [
-    "إصلاح سريع 1",
-    "إصلاح سريع 2",
-    "إصلاح سريع 3"
-  ],
-  "structural_revisions": [
-    "مراجعة هيكلية 1",
-    "مراجعة هيكلية 2"
-  ]
-}
-    `;
-
-    const result = await this.geminiService.generate<{
-      priority_actions?: string[];
-      quick_fixes?: string[];
-      structural_revisions?: string[];
-    }>({
-      prompt,
-      model: GeminiModel.PRO,
-      temperature: 0.7
-    });
-
-    return {
-      priorityActions: result.content.priority_actions ?? [],
-      quickFixes: result.content.quick_fixes ?? [],
-      structuralRevisions: result.content.structural_revisions ?? []
-    };
-  }
-
-  protected extractRequiredData(input: Station4Input): Record<string, unknown> {
-    return {
-      charactersCount: input.station3Output.networkSummary.charactersCount,
-      relationshipsCount: input.station3Output.networkSummary.relationshipsCount,
-      conflictsCount: input.station3Output.networkSummary.conflictsCount
-    };
-  }
-
-  protected getErrorFallback(): Station4Output {
-    return {
-      efficiencyMetrics: {
-        overallEfficiencyScore: 0,
-        overallRating: 'Critical',
-        conflictCohesion: 0,
-        dramaticBalance: {
-          balanceScore: 0,
-          characterInvolvementGini: 1
-        },
-        narrativeEfficiency: {
-          characterEfficiency: 0,
-          relationshipEfficiency: 0,
-          conflictEfficiency: 0
-        },
-        narrativeDensity: 0,
-        redundancyMetrics: {
-          characterRedundancy: 0,
-          relationshipRedundancy: 0,
-          conflictRedundancy: 0
-        }
-      },
-      recommendations: {
-        priorityActions: ['خطأ في التحليل'],
-        quickFixes: ['خطأ في التحليل'],
-        structuralRevisions: ['خطأ في التحليل']
-      },
-      metadata: {
-        analysisTimestamp: new Date(),
-        status: 'Failed',
-        analysisTime: 0
-      }
-    };
-  }
-}
\ No newline at end of file
diff --git a/backup_20251003_052813/server/stations/station5/station5-dynamic-symbolic-stylistic.ts b/backup_20251003_052813/server/stations/station5/station5-dynamic-symbolic-stylistic.ts
deleted file mode 100644
index f480b76..0000000
--- a/backup_20251003_052813/server/stations/station5/station5-dynamic-symbolic-stylistic.ts
+++ /dev/null
@@ -1,1224 +0,0 @@
-import { BaseStation, type StationConfig } from '../../core/pipeline/base-station';
-import { ConflictNetwork, Conflict, Character, Relationship, ConflictPhase, NetworkSnapshot } from '../../core/models/base-entities';
-import { GeminiService, GeminiModel } from '../../services/ai/gemini-service';
-import { Station4Output } from '../station4/station4-efficiency-metrics';
-import * as fs from 'fs';
-import * as path from 'path';
-
-const safeGet = <T>(array: T[], index: number): T | undefined => {
-  if (index < 0 || index >= array.length) {
-    return undefined;
-  }
-
-  return array[index];
-};
-
-
-// Station 5 Interfaces
-interface Station5Input {
-  conflictNetwork: ConflictNetwork;
-  station4Output: Station4Output;
-  fullText: string;
-}
-
-interface Station5Output {
-  dynamicAnalysisResults: DynamicAnalysisResults;
-  episodicIntegrationResults: EpisodicIntegrationResults;
-  symbolicAnalysisResults: SymbolicAnalysisResults;
-  stylisticAnalysisResults: StylisticAnalysisResults;
-  metadata: {
-    analysisTimestamp: Date;
-    status: 'Success' | 'Partial' | 'Failed';
-    analysisTime: number;
-  };
-}
-
-interface DynamicAnalysisResults {
-  eventTimeline: TimelineEvent[];
-  networkEvolutionAnalysis: EvolutionAnalysis;
-  characterDevelopmentTracking: Map<string, CharacterEvolution>;
-  conflictProgressionTracking: Map<string, ConflictProgression>;
-}
-
-interface TimelineEvent {
-  timestamp: Date;
-  eventType: 'character_introduced' | 'relationship_formed' | 
-              'conflict_emerged' | 'conflict_escalated' | 
-              'conflict_resolved' | 'character_transformed' | 
-              'network_snapshot' | 'other';
-  description: string;
-  involvedEntities: {
-    characters?: string[];
-    relationships?: string[];
-    conflicts?: string[];
-  };
-  significance: number; // 1-10
-  narrativePhase: 'setup' | 'rising_action' | 'climax' | 
-                   'falling_action' | 'resolution';
-}
-
-interface EvolutionAnalysis {
-  overallGrowthRate: number;
-  complexityProgression: number[];
-  densityProgression: number[];
-  criticalTransitionPoints: Array<{
-    timestamp: Date;
-    description: string;
-    impactScore: number;
-  }>;
-  stabilityMetrics: {
-    structuralStability: number;
-    characterStability: number;
-    conflictStability: number;
-  };
-}
-
-interface CharacterEvolution {
-  characterId: string;
-  characterName: string;
-  developmentStages: Array<{
-    timestamp: Date;
-    stage: string;
-    traits: string[];
-    relationships: string[];
-    conflicts: string[];
-  }>;
-  arcType: 'positive' | 'negative' | 'flat' | 'complex';
-  transformationScore: number;
-  keyMoments: Array<{
-    timestamp: Date;
-    event: string;
-    impact: string;
-  }>;
-}
-
-interface ConflictProgression {
-  conflictId: string;
-  conflictName: string;
-  phaseTransitions: Array<{
-    timestamp: Date;
-    fromPhase: ConflictPhase;
-    toPhase: ConflictPhase;
-    catalyst: string;
-  }>;
-  intensityProgression: number[];
-  resolutionProbability: number;
-  stagnationRisk: number;
-}
-
-interface EpisodicIntegrationResults {
-  seriesStructure: SeriesStructure;
-  seasonBreakdown: Map<number, SeasonDetails>;
-  episodeDistribution: Map<string, EpisodeAssignment>;
-  balanceReport: EpisodicBalanceReport;
-}
-
-interface SeriesStructure {
-  totalSeasons: number;
-  episodesPerSeason: number;
-  totalEpisodes: number;
-  recommendedRuntime: number; // minutes per episode
-}
-
-interface SeasonDetails {
-  seasonNumber: number;
-  seasonTitle: string;
-  episodes: Episode[];
-  majorConflicts: string[];
-  seasonArc: string;
-  cliffhanger?: string;
-}
-
-interface Episode {
-  episodeNumber: number;
-  seasonNumber: number;
-  title: string;
-  assignedConflicts: string[];
-  featuredCharacters: string[];
-  estimatedIntensity: number;
-  narrativeFunction: 'setup' | 'development' | 'climax' | 'resolution';
-}
-
-interface EpisodeAssignment {
-  conflictId: string;
-  episodes: number[];
-  distributionQuality: number;
-}
-
-interface EpisodicBalanceReport {
-  overallBalance: number;
-  conflictDistributionScore: number;
-  characterAppearanceBalance: number;
-  intensityFlowScore: number;
-  recommendations: string[];
-}
-
-interface SymbolicAnalysisResults {
-  keySymbols: Array<{
-    symbol: string;
-    interpretation: string;
-    frequency: number;
-    contextualMeanings: string[];
-  }>;
-  recurringMotifs: Array<{
-    motif: string;
-    occurrences: number;
-    narrativeFunction: string;
-  }>;
-  centralThemesHintedBySymbols: string[];
-  symbolicNetworks: Array<{
-    primarySymbol: string;
-    relatedSymbols: string[];
-    thematicConnection: string;
-  }>;
-  depthScore: number;
-  consistencyScore: number;
-}
-
-interface StylisticAnalysisResults {
-  overallToneAssessment: {
-    primaryTone: string;
-    secondaryTones: string[];
-    toneConsistency: number;
-    explanation: string;
-  };
-  languageComplexity: {
-    level: 'simple' | 'moderate' | 'complex' | 'highly_complex';
-    readabilityScore: number;
-    vocabularyRichness: number;
-  };
-  pacingImpression: {
-    overallPacing: 'very_slow' | 'slow' | 'balanced' | 'fast' | 'very_fast';
-    pacingVariation: number;
-    sceneLengthDistribution: number[];
-  };
-  dialogueStyle: {
-    characterization: string;
-    naturalness: number;
-    effectiveness: number;
-    distinctiveness: number;
-  };
-  descriptiveRichness: {
-    visualDetailLevel: number;
-    sensoryEngagement: number;
-    atmosphericQuality: number;
-  };
-  stylisticConsistencyImpression: {
-    consistencyScore: number;
-    deviations: Array<{
-      location: string;
-      type: string;
-      description: string;
-    }>;
-  };
-  textBlobSentiment?: {
-    polarity: number;
-    subjectivity: number;
-  };
-}
-
-/**
- * Dynamic Analysis Engine
- */
-class DynamicAnalysisEngine {
-  constructEventTimeline(network: ConflictNetwork): TimelineEvent[] {
-    const events: TimelineEvent[] = [];
-    
-    for (const snapshot of network.snapshots) {
-      events.push({
-        timestamp: snapshot.timestamp,
-        eventType: 'network_snapshot',
-        description: snapshot.description,
-        involvedEntities: {},
-        significance: 5,
-        narrativePhase: this.inferNarrativePhase(
-          snapshot.timestamp,
-          network.snapshots
-        )
-      });
-    }
-    
-    for (const conflict of network.conflicts.values()) {
-      const legacyTimestamp = (conflict as Conflict & {
-        timestamp?: Date | Date[];
-      }).timestamp;
-
-      const rawTimestamps = legacyTimestamp ?? conflict.timestamps;
-      const timestamps = Array.isArray(rawTimestamps)
-        ? rawTimestamps
-        : rawTimestamps
-        ? [rawTimestamps]
-        : [];
-
-      for (const timestamp of timestamps) {
-        if (!timestamp) {
-          continue;
-        }
-
-        events.push({
-          timestamp,
-          eventType: 'conflict_emerged',
-          description: `Conflict emerged: ${conflict.name}`,
-          involvedEntities: {
-            characters: conflict.involvedCharacters,
-            conflicts: [conflict.id]
-          },
-          significance: conflict.strength,
-          narrativePhase: this.inferNarrativePhase(
-            timestamp,
-            network.snapshots
-          )
-        });
-      }
-    }
-    
-    events.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());
-    
-    return events;
-  }
-  
-  private inferNarrativePhase(
-    timestamp: Date,
-    snapshots: NetworkSnapshot[]
-  ): 'setup' | 'rising_action' | 'climax' | 'falling_action' | 'resolution' {
-    if (!timestamp || !snapshots || snapshots.length === 0) {
-        return 'setup';
-    }
-
-    const firstSnapshot = safeGet(snapshots, 0);
-    const lastSnapshot = safeGet(snapshots, snapshots.length - 1);
-
-    if (!firstSnapshot?.timestamp || !lastSnapshot?.timestamp) {
-        return 'setup';
-    }
-
-    const firstTime = firstSnapshot.timestamp.getTime();
-    const lastTime = lastSnapshot.timestamp.getTime();
-    const totalDuration = lastTime - firstTime;
-
-    if (totalDuration === 0) {
-        return 'setup';
-    }
-
-    const position = (timestamp.getTime() - firstTime) / totalDuration;
-
-    if (position < 0.2) return 'setup';
-    if (position < 0.5) return 'rising_action';
-    if (position < 0.7) return 'climax';
-    if (position < 0.9) return 'falling_action';
-    return 'resolution';
-  }
-  
-  analyzeNetworkEvolution(
-    network: ConflictNetwork,
-    timeline: TimelineEvent[]
-  ): EvolutionAnalysis {
-    const complexityProgression: number[] = [];
-    const densityProgression: number[] = [];
-    const transitionPoints: Array<{
-      timestamp: Date;
-      description: string;
-      impactScore: number;
-    }> = [];
-    
-    for (const snapshot of network.snapshots) {
-      if (!snapshot.networkState.characters || 
-          !snapshot.networkState.relationships || 
-          !snapshot.networkState.conflicts) {
-        continue;
-      }
-      
-      const numChars = snapshot.networkState.characters.size;
-      const numRels = snapshot.networkState.relationships.size;
-      const numConflicts = snapshot.networkState.conflicts.size;
-      
-      const complexity = numChars + numRels + numConflicts;
-      complexityProgression.push(complexity);
-      
-      const maxPossibleRels = numChars * (numChars - 1) / 2;
-      const density = maxPossibleRels > 0 ? numRels / maxPossibleRels : 0;
-      densityProgression.push(density);
-    }
-    
-    for (let i = 1; i < complexityProgression.length; i++) {
-      const change = Math.abs(
-        complexityProgression[i] - complexityProgression[i - 1]
-      );
-      
-      if (change > 5) {
-        transitionPoints.push({
-          timestamp: network.snapshots[i].timestamp,
-          description: network.snapshots[i].description,
-          impactScore: change
-        });
-      }
-    }
-    
-    const overallGrowthRate = complexityProgression.length > 1
-      ? (complexityProgression[complexityProgression.length - 1] - 
-         complexityProgression) / complexityProgression.length
-      : 0;
-    
-    const stabilityMetrics = this.calculateStabilityMetrics(
-      complexityProgression,
-      densityProgression
-    );
-    
-    return {
-      overallGrowthRate,
-      complexityProgression,
-      densityProgression,
-      criticalTransitionPoints: transitionPoints,
-      stabilityMetrics
-    };
-  }
-  
-  private calculateStabilityMetrics(
-    complexityProgression: number[],
-    densityProgression: number[]
-  ): {
-    structuralStability: number;
-    characterStability: number;
-    conflictStability: number;
-  } {
-    const complexityVariance = this.calculateVariance(complexityProgression);
-    const densityVariance = this.calculateVariance(densityProgression);
-    
-    const structuralStability = 1 / (1 + complexityVariance);
-    
-    return {
-      structuralStability,
-      characterStability: 1 / (1 + densityVariance),
-      conflictStability: structuralStability
-    };
-  }
-  
-  private calculateVariance(values: number[]): number {
-    if (values.length <= 1) {
-      return 0;
-    }
-
-    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
-    const squaredDiffs = values.map(val => Math.pow(val - mean, 2));
-    return squaredDiffs.reduce((sum, val) => sum + val, 0) / values.length;
-  }
-  
-  trackCharacterDevelopment(
-    network: ConflictNetwork,
-    timeline: TimelineEvent[]
-  ): Map<string, CharacterEvolution> {
-    const evolutionMap = new Map<string, CharacterEvolution>();
-    
-    for (const [charId, character] of network.characters) {
-      const developmentStages: CharacterEvolution['developmentStages'] = [];
-      const keyMoments: CharacterEvolution['keyMoments'] = [];
-      
-      for (const snapshot of network.snapshots) {
-        if (!snapshot.networkState.characters?.has(charId)) continue;
-        
-        const charState = snapshot.networkState.characters.get(charId);
-        if (!charState) continue;
-        
-        const relationships: string[] = [];
-        const conflicts: string[] = [];
-        
-        if (snapshot.networkState.relationships) {
-          for (const [relId, rel] of snapshot.networkState.relationships) {
-            if (rel.source === charId || rel.target === charId) {
-              relationships.push(relId);
-            }
-          }
-        }
-        
-        if (snapshot.networkState.conflicts) {
-          for (const [confId, conf] of snapshot.networkState.conflicts) {
-            if (conf.involvedCharacters.includes(charId)) {
-              conflicts.push(confId);
-            }
-          }
-        }
-        
-        developmentStages.push({
-          timestamp: snapshot.timestamp,
-          stage: snapshot.description,
-          traits: [],
-          relationships,
-          conflicts
-        });
-      }
-      
-      for (const event of timeline) {
-        if (event.involvedEntities.characters?.includes(charId)) {
-          keyMoments.push({
-            timestamp: event.timestamp,
-            event: event.description,
-            impact: `Significance: ${event.significance}/10`
-          });
-        }
-      }
-      
-      const arcType = this.determineArcType(developmentStages);
-      
-      const transformationScore = this.calculateTransformationScore(
-        developmentStages
-      );
-      
-      evolutionMap.set(charId, {
-        characterId: charId,
-        characterName: character.name,
-        developmentStages,
-        arcType,
-        transformationScore,
-        keyMoments
-      });
-    }
-    
-    return evolutionMap;
-  }
-  
-  private determineArcType(
-    stages: CharacterEvolution['developmentStages']
-  ): 'positive' | 'negative' | 'flat' | 'complex' {
-    if (stages.length < 2) return 'flat';
-
-    const firstStage = safeGet(stages, 0);
-    const lastStage = safeGet(stages, stages.length - 1);
-
-    if (!firstStage || !lastStage) {
-      return 'flat';
-    }
-
-    const conflictChange =
-      lastStage.conflicts.length - firstStage.conflicts.length;
-    const relationshipChange =
-      lastStage.relationships.length - firstStage.relationships.length;
-    
-    const totalChange = conflictChange + relationshipChange;
-    
-    if (totalChange > 2) return 'positive';
-    if (totalChange < -2) return 'negative';
-    if (Math.abs(totalChange) > 4) return 'complex';
-    return 'flat';
-  }
-  
-  private calculateTransformationScore(
-    stages: CharacterEvolution['developmentStages']
-  ): number {
-    if (stages.length < 2) return 0;
-    
-    let totalChange = 0;
-    
-    for (let i = 1; i < stages.length; i++) {
-      const prev = stages[i - 1];
-      const curr = stages[i];
-      
-      const conflictChange = Math.abs(
-        curr.conflicts.length - prev.conflicts.length
-      );
-      const relationshipChange = Math.abs(
-        curr.relationships.length - prev.relationships.length
-      );
-      
-      totalChange += conflictChange + relationshipChange;
-    }
-    
-    return Math.min(10, totalChange / stages.length);
-  }
-  
-  trackConflictProgression(
-    network: ConflictNetwork,
-    timeline: TimelineEvent[]
-  ): Map<string, ConflictProgression> {
-    const progressionMap = new Map<string, ConflictProgression>();
-    
-    for (const [confId, conflict] of network.conflicts) {
-      const phaseTransitions: ConflictProgression['phaseTransitions'] = [];
-      const intensityProgression: number[] = [];
-      
-      let previousPhase: ConflictPhase | null = null;
-      
-      for (const snapshot of network.snapshots) {
-        if (!snapshot.networkState.conflicts?.has(confId)) continue;
-        
-        const confState = snapshot.networkState.conflicts.get(confId);
-        if (!confState) continue;
-        
-        intensityProgression.push(confState.strength);
-        
-        if (previousPhase !== null && confState.phase !== previousPhase) {
-          const catalyst = timeline.find(
-            event => 
-              event.timestamp.getTime() === snapshot.timestamp.getTime() &&
-              event.involvedEntities.conflicts?.includes(confId)
-          )?.description || 'Unknown catalyst';
-          
-          phaseTransitions.push({
-            timestamp: snapshot.timestamp,
-            fromPhase: previousPhase,
-            toPhase: confState.phase,
-            catalyst
-          });
-        }
-        
-        previousPhase = confState.phase;
-      }
-      
-      const resolutionProbability = this.calculateResolutionProbability(
-        conflict,
-        phaseTransitions
-      );
-      
-      const stagnationRisk = this.calculateStagnationRisk(
-        intensityProgression,
-        phaseTransitions
-      );
-      
-      progressionMap.set(confId, {
-        conflictId: confId,
-        conflictName: conflict.name,
-        phaseTransitions,
-        intensityProgression,
-        resolutionProbability,
-        stagnationRisk
-      });
-    }
-    
-    return progressionMap;
-  }
-  
-  private calculateResolutionProbability(
-    conflict: Conflict,
-    transitions: ConflictProgression['phaseTransitions']
-  ): number {
-    let probability = 0.5;
-    
-    if (conflict.phase === ConflictPhase.RESOLUTION) {
-      probability = 0.95;
-    } else if (conflict.phase === ConflictPhase.DEESCALATING) {
-      probability = 0.75;
-    } else if (conflict.phase === ConflictPhase.AFTERMATH) {
-      probability = 1.0;
-    } else if (conflict.phase === ConflictPhase.CLIMAX) {
-      probability = 0.6;
-    } else if (conflict.phase === ConflictPhase.LATENT) {
-      probability = 0.2;
-    }
-    
-    const transitionBonus = Math.min(0.3, transitions.length * 0.05);
-    probability += transitionBonus;
-    
-    return Math.max(0, Math.min(1, probability));
-  }
-  
-  private calculateStagnationRisk(
-    intensityProgression: number[],
-    transitions: ConflictProgression['phaseTransitions']
-  ): number {
-    if (intensityProgression.length < 3) return 0.5;
-    
-    const variance = this.calculateVariance(intensityProgression);
-    
-    const transitionFactor = transitions.length === 0 ? 0.8 : 
-                            transitions.length < 2 ? 0.5 : 0.2;
-    
-    const varianceFactor = variance < 1 ? 0.7 : 
-                          variance < 3 ? 0.4 : 0.1;
-    
-    const risk = (transitionFactor + varianceFactor) / 2;
-    
-    return Math.max(0, Math.min(1, risk));
-  }
-}
-
-/**
- * Episodic Integration Engine
- */
-class EpisodicIntegrationEngine {
-  createSeriesStructure(
-    network: ConflictNetwork,
-    targetEpisodesPerSeason: number = 10
-  ): SeriesStructure {
-    const numConflicts = network.conflicts.size;
-    
-    const estimatedEpisodes = Math.ceil(numConflicts / 2.5);
-    
-    const totalEpisodes = Math.max(
-      targetEpisodesPerSeason,
-      estimatedEpisodes
-    );
-    
-    const totalSeasons = Math.ceil(totalEpisodes / targetEpisodesPerSeason);
-    
-    return {
-      totalSeasons,
-      episodesPerSeason: targetEpisodesPerSeason,
-      totalEpisodes,
-      recommendedRuntime: 45
-    };
-  }
-  
-  distributeConflicts(
-    network: ConflictNetwork,
-    structure: SeriesStructure
-  ): Map<string, EpisodeAssignment> {
-    const assignments = new Map<string, EpisodeAssignment>();
-    const conflicts = Array.from(network.conflicts.values());
-    
-    conflicts.sort((a, b) => b.strength - a.strength);
-    
-    let currentEpisode = 1;
-    
-    for (const conflict of conflicts) {
-      const episodes: number[] = [];
-      
-      const episodeSpan = Math.ceil(conflict.strength / 3);
-      
-      for (let i = 0; i < episodeSpan; i++) {
-        if (currentEpisode <= structure.totalEpisodes) {
-          episodes.push(currentEpisode);
-          currentEpisode++;
-        }
-      }
-      
-      if (currentEpisode > structure.totalEpisodes) {
-        currentEpisode = 1;
-      }
-      
-      assignments.set(conflict.id, {
-        conflictId: conflict.id,
-        episodes,
-        distributionQuality: this.evaluateDistributionQuality(episodes)
-      });
-    }
-    
-    return assignments;
-  }
-  
-  private evaluateDistributionQuality(episodes: number[]): number {
-    if (episodes.length === 0) return 0;
-    if (episodes.length === 1) return 1;
-    
-    const gaps: number[] = [];
-    for (let i = 1; i < episodes.length; i++) {
-      gaps.push(episodes[i] - episodes[i - 1]);
-    }
-    
-    const avgGap = gaps.reduce((sum, gap) => sum + gap, 0) / gaps.length;
-    const variance = this.calculateVariance(gaps);
-    
-    const quality = 1 / (1 + variance);
-    
-    return Math.max(0, Math.min(1, quality));
-  }
-  
-  private calculateVariance(values: number[]): number {
-    if (values.length <= 1) {
-      return 0;
-    }
-
-    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
-    const squaredDiffs = values.map(val => Math.pow(val - mean, 2));
-    return squaredDiffs.reduce((sum, val) => sum + val, 0) / values.length;
-  }
-  
-  createSeasonBreakdown(
-    network: ConflictNetwork,
-    structure: SeriesStructure,
-    assignments: Map<string, EpisodeAssignment>
-  ): Map<number, SeasonDetails> {
-    const seasonMap = new Map<number, SeasonDetails>();
-    
-    for (let s = 1; s <= structure.totalSeasons; s++) {
-      const startEpisode = (s - 1) * structure.episodesPerSeason + 1;
-      const endEpisode = Math.min(
-        s * structure.episodesPerSeason,
-        structure.totalEpisodes
-      );
-      
-      const episodes: Episode[] = [];
-      const seasonConflicts = new Set<string>();
-      
-      for (let e = startEpisode; e <= endEpisode; e++) {
-        const episodeConflicts: string[] = [];
-        const featuredCharacters = new Set<string>();
-        
-        for (const [conflictId, assignment] of assignments) {
-          if (assignment.episodes.includes(e)) {
-            episodeConflicts.push(conflictId);
-            seasonConflicts.add(conflictId);
-            
-            const conflict = network.conflicts.get(conflictId);
-            if (conflict) {
-              conflict.involvedCharacters.forEach(charId => 
-                featuredCharacters.add(charId)
-              );
-            }
-          }
-        }
-        
-        let estimatedIntensity = 0;
-        for (const confId of episodeConflicts) {
-          const conflict = network.conflicts.get(confId);
-          if (conflict) {
-            estimatedIntensity += conflict.strength;
-          }
-        }
-        estimatedIntensity = Math.min(10, estimatedIntensity / episodeConflicts.length);
-        
-        const relativePosition = (e - startEpisode) / (endEpisode - startEpisode);
-        const narrativeFunction = 
-          relativePosition < 0.3 ? 'setup' :
-          relativePosition < 0.7 ? 'development' :
-          relativePosition < 0.9 ? 'climax' : 'resolution';
-        
-        episodes.push({
-          episodeNumber: e,
-          seasonNumber: s,
-          title: `Episode ${e}`,
-          assignedConflicts: episodeConflicts,
-          featuredCharacters: Array.from(featuredCharacters),
-          estimatedIntensity,
-          narrativeFunction
-        });
-      }
-      
-      seasonMap.set(s, {
-        seasonNumber: s,
-        seasonTitle: `Season ${s}`,
-        episodes,
-        majorConflicts: Array.from(seasonConflicts),
-        seasonArc: `Season ${s} arc description`,
-        cliffhanger: s < structure.totalSeasons 
-          ? `Cliffhanger for Season ${s}` 
-          : undefined
-      });
-    }
-    
-    return seasonMap;
-  }
-  
-  evaluateEpisodicBalance(
-    network: ConflictNetwork,
-    seasonBreakdown: Map<number, SeasonDetails>
-  ): EpisodicBalanceReport {
-    const allEpisodes: Episode[] = [];
-    for (const season of seasonBreakdown.values()) {
-      allEpisodes.push(...season.episodes);
-    }
-    
-    const conflictsPerEpisode = allEpisodes.map(ep => 
-      ep.assignedConflicts.length
-    );
-    const conflictDistributionScore = 1 - this.calculateVariance(
-      conflictsPerEpisode
-    ) / Math.max(...conflictsPerEpisode);
-    
-    const charAppearances = new Map<string, number>();
-    for (const episode of allEpisodes) {
-      for (const charId of episode.featuredCharacters) {
-        charAppearances.set(
-          charId,
-          (charAppearances.get(charId) || 0) + 1
-        );
-      }
-    }
-    
-    const appearanceCounts = Array.from(charAppearances.values());
-    const characterAppearanceBalance = appearanceCounts.length > 0
-      ? 1 - this.calculateVariance(appearanceCounts) / 
-        Math.max(...appearanceCounts)
-      : 0;
-    
-    const intensities = allEpisodes.map(ep => ep.estimatedIntensity);
-    const intensityFlowScore = this.evaluateIntensityFlow(intensities);
-    
-    const overallBalance = (
-      conflictDistributionScore * 0.4 +
-      characterAppearanceBalance * 0.3 +
-      intensityFlowScore * 0.3
-    );
-    
-    const recommendations = this.generateBalanceRecommendations({
-      conflictDistributionScore,
-      characterAppearanceBalance,
-      intensityFlowScore,
-      overallBalance
-    });
-    
-    return {
-      overallBalance,
-      conflictDistributionScore,
-      characterAppearanceBalance,
-      intensityFlowScore,
-      recommendations
-    };
-  }
-  
-  private evaluateIntensityFlow(intensities: number[]): number {
-    if (intensities.length < 2) return 1;
-    
-    let score = 1.0;
-    
-    const variance = this.calculateVariance(intensities);
-    if (variance < 1) {
-      score -= 0.3;
-    }
-    
-    const firstHalf = intensities.slice(0, Math.floor(intensities.length / 2));
-    const secondHalf = intensities.slice(Math.floor(intensities.length / 2));
-    
-    const firstHalfAvg = firstHalf.reduce((sum, val) => sum + val, 0) / firstHalf.length;
-    const secondHalfAvg = secondHalf.reduce((sum, val) => sum + val, 0) / secondHalf.length;
-    
-    if (secondHalfAvg > firstHalfAvg) {
-      score += 0.2;
-    }
-    
-    return Math.max(0, Math.min(1, score));
-  }
-  
-  private generateBalanceRecommendations(metrics: {
-    conflictDistributionScore: number;
-    characterAppearanceBalance: number;
-    intensityFlowScore: number;
-    overallBalance: number;
-  }): string[] {
-    const recommendations: string[] = [];
-    
-    if (metrics.conflictDistributionScore < 0.6) {
-      recommendations.push(
-        'Consider redistributing conflicts more evenly across episodes'
-      );
-    }
-    
-    if (metrics.characterAppearanceBalance < 0.5) {
-      recommendations.push(
-        'Some characters appear too frequently or too rarely - balance character screen time'
-      );
-    }
-    
-    if (metrics.intensityFlowScore < 0.5) {
-      recommendations.push(
-        'Intensity flow needs improvement - add more variation and build-up'
-      );
-    }
-    
-    if (metrics.overallBalance >= 0.8) {
-      recommendations.push(
-        'Excellent episodic balance - maintain current structure'
-      );
-    }
-    
-    return recommendations;
-  }
-}
-
-/**
- * Station 5: Dynamic, Symbolic, and Stylistic Analysis
- */
-export class Station5DynamicSymbolicStylistic extends BaseStation<Station5Input, Station5Output> {
-  private dynamicEngine: DynamicAnalysisEngine;
-  private episodicEngine: EpisodicIntegrationEngine;
-  
-  constructor(
-    config: StationConfig,
-    geminiService: GeminiService
-  ) {
-    super(config, geminiService);
-    this.dynamicEngine = new DynamicAnalysisEngine();
-    this.episodicEngine = new EpisodicIntegrationEngine();
-  }
-  
-  protected async process(input: Station5Input): Promise<Station5Output> {
-    const startTime = Date.now();
-    
-    const dynamicAnalysisResults = await this.performDynamicAnalysis(
-      input.conflictNetwork
-    );
-    
-    const episodicIntegrationResults = await this.performEpisodicIntegration(
-      input.conflictNetwork
-    );
-    
-    const symbolicAnalysisResults = await this.performSymbolicAnalysis(
-      input.fullText
-    );
-    
-    const stylisticAnalysisResults = await this.performStylisticAnalysis(
-      input.fullText
-    );
-    
-    const analysisTime = Date.now() - startTime;
-    
-    return {
-      dynamicAnalysisResults,
-      episodicIntegrationResults,
-      symbolicAnalysisResults,
-      stylisticAnalysisResults,
-      metadata: {
-        analysisTimestamp: new Date(),
-        status: 'Success',
-        analysisTime
-      }
-    };
-  }
-  
-  private async performDynamicAnalysis(
-    network: ConflictNetwork
-  ): Promise<DynamicAnalysisResults> {
-    const eventTimeline = this.dynamicEngine.constructEventTimeline(network);
-    
-    const networkEvolutionAnalysis = this.dynamicEngine.analyzeNetworkEvolution(
-      network,
-      eventTimeline
-    );
-    
-    const characterDevelopmentTracking = 
-      this.dynamicEngine.trackCharacterDevelopment(
-        network,
-        eventTimeline
-      );
-    
-    const conflictProgressionTracking = 
-      this.dynamicEngine.trackConflictProgression(
-        network,
-        eventTimeline
-      );
-    
-    return {
-      eventTimeline,
-      networkEvolutionAnalysis,
-      characterDevelopmentTracking,
-      conflictProgressionTracking
-    };
-  }
-  
-  private async performEpisodicIntegration(
-    network: ConflictNetwork
-  ): Promise<EpisodicIntegrationResults> {
-    const seriesStructure = this.episodicEngine.createSeriesStructure(
-      network,
-      10
-    );
-    
-    const episodeDistribution = this.episodicEngine.distributeConflicts(
-      network,
-      seriesStructure
-    );
-    
-    const seasonBreakdown = this.episodicEngine.createSeasonBreakdown(
-      network,
-      seriesStructure,
-      episodeDistribution
-    );
-    
-    const balanceReport = this.episodicEngine.evaluateEpisodicBalance(
-      network,
-      seasonBreakdown
-    );
-    
-    return {
-      seriesStructure,
-      seasonBreakdown,
-      episodeDistribution,
-      balanceReport
-    };
-  }
-  
-  private async performSymbolicAnalysis(
-    fullText: string
-  ): Promise<SymbolicAnalysisResults> {
-    const prompt = `
-    Based on the provided narrative text, analyze and identify the following:
-
-    1.  **key_symbols**: A list of 3-5 recurring or symbolically significant objects, places, or items. For each, provide:
-        - "symbol": The name of the symbol.
-        - "interpretation": A brief interpretation of its potential meaning.
-        - "frequency": An estimated number of appearances.
-        - "contextual_meanings": A list of different meanings in various contexts.
-
-    2.  **recurring_motifs**: A list of 2-3 recurring ideas, patterns, or situations (motifs). For each:
-        - "motif": A description of the motif.
-        - "occurrences": The number of times it appears.
-        - "narrative_function": Its narrative purpose.
-
-    3.  **central_themes_hinted_by_symbols**: A brief conclusion about the main themes suggested by these symbols and motifs (a list of strings).
-
-    4.  **symbolic_networks**: A list of dictionaries, each containing:
-        - "primary_symbol": The main symbol.
-        - "related_symbols": A list of associated symbols.
-        - "thematic_connection": The thematic link.
-
-    5.  **depth_score**: A score (0-10) for the depth of symbolic usage.
-
-    6.  **consistency_score**: A score (0-10) for the consistency of symbolic usage.
-
-    Respond **exclusively** in valid JSON format with the keys mentioned above.
-    `;
-    
-    const result = await this.geminiService.generate<SymbolicAnalysisResults>({
-      prompt,
-      context: fullText.substring(0, 30000),
-      model: GeminiModel.PRO,
-      temperature: 0.7
-    });
-    
-    return result.content || this.getDefaultSymbolicResults();
-  }
-  
-  private async performStylisticAnalysis(
-    fullText: string
-  ): Promise<StylisticAnalysisResults> {
-    const prompt = `
-    Based on the provided narrative text, analyze and provide an assessment of the following stylistic elements:
-
-    1.  **overall_tone_assessment**:
-        - "primary_tone": The main tone.
-        - "secondary_tones": A list of secondary tones.
-        - "tone_consistency": A score (0-10) for tone consistency.
-        - "explanation": A brief explanation.
-
-    2.  **language_complexity**:
-        - "level": The complexity level ("simple", "moderate", "complex", "highly_complex").
-        - "readability_score": A score (0-10) for readability.
-        - "vocabulary_richness": A score (0-10) for vocabulary richness.
-
-    3.  **pacing_impression**:
-        - "overall_pacing": The overall pacing ("very_slow", "slow", "balanced", "fast", "very_fast").
-        - "pacing_variation": A score (0-10) for pacing variation.
-        - "scene_length_distribution": An approximate list of scene lengths.
-
-    4.  **dialogue_style**:
-        - "characterization": A text description of how dialogue characterizes individuals.
-        - "naturalness": A score (0-10) for how natural the dialogue feels.
-        - "effectiveness": A score (0-10) for its effectiveness in advancing the plot.
-        - "distinctiveness": A score (0-10) for how distinct character voices are.
-
-    5.  **descriptive_richness**:
-        - "visual_detail_level": A score (0-10) for the level of visual detail.
-        - "sensory_engagement": A score (0-10) for sensory engagement.
-        - "atmospheric_quality": A score (0-10) for atmospheric quality.
-
-    6.  **stylistic_consistency_impression**:
-        - "consistency_score": A score (0-10) for consistency.
-        - "deviations": A list of any noticeable deviations, each with:
-          * "location": Approximate location.
-          * "type": Type of deviation.
-          * "description": Description of the deviation.
-
-    Respond **exclusively** in valid JSON format with the keys mentioned above.
-    `;
-    
-    const result = await this.geminiService.generate<StylisticAnalysisResults>({
-      prompt,
-      context: fullText.substring(0, 30000),
-      model: GeminiModel.PRO,
-      temperature: 0.6
-    });
-    
-    const stylisticResults = result.content || this.getDefaultStylisticResults();
-    
-    return stylisticResults;
-  }
-  
-  private getDefaultSymbolicResults(): SymbolicAnalysisResults {
-    return {
-      keySymbols: [],
-      recurringMotifs: [],
-      centralThemesHintedBySymbols: [],
-      symbolicNetworks: [],
-      depthScore: 0,
-      consistencyScore: 0
-    };
-  }
-  
-  private getDefaultStylisticResults(): StylisticAnalysisResults {
-    return {
-      overallToneAssessment: {
-        primaryTone: 'Unknown',
-        secondaryTones: [],
-        toneConsistency: 0,
-        explanation: 'Analysis failed'
-      },
-      languageComplexity: {
-        level: 'moderate',
-        readabilityScore: 5,
-        vocabularyRichness: 5
-      },
-      pacingImpression: {
-        overallPacing: 'balanced',
-        pacingVariation: 5,
-        sceneLengthDistribution: []
-      },
-      dialogueStyle: {
-        characterization: 'Unknown',
-        naturalness: 5,
-        effectiveness: 5,
-        distinctiveness: 5
-      },
-      descriptiveRichness: {
-        visualDetailLevel: 5,
-        sensoryEngagement: 5,
-        atmosphericQuality: 5
-      },
-      stylisticConsistencyImpression: {
-        consistencyScore: 5,
-        deviations: []
-      }
-    };
-  }
-  
-  protected extractRequiredData(input: Station5Input): Record<string, unknown> {
-    return {
-      charactersCount: input.conflictNetwork.characters.length,
-      conflictsCount: input.conflictNetwork.conflicts.length,
-      station4Score: input.station4Output.efficiencyMetrics.overallEfficiencyScore,
-      fullTextLength: input.fullText.length
-    };
-  }
-  
-  protected getErrorFallback(): Station5Output {
-    return {
-      dynamicAnalysisResults: {
-        eventTimeline: [],
-        networkEvolutionAnalysis: {
-          overallGrowthRate: 0,
-          complexityProgression: [],
-          densityProgression: [],
-          criticalTransitionPoints: [],
-          stabilityMetrics: {
-            structuralStability: 0,
-            characterStability: 0,
-            conflictStability: 0
-          }
-        },
-        characterDevelopmentTracking: new Map(),
-        conflictProgressionTracking: new Map()
-      },
-      episodicIntegrationResults: {
-        seriesStructure: {
-          totalSeasons: 0,
-          episodesPerSeason: 0,
-          totalEpisodes: 0,
-          recommendedRuntime: 0
-        },
-        seasonBreakdown: new Map(),
-        episodeDistribution: new Map(),
-        balanceReport: {
-          overallBalance: 0,
-          conflictDistributionScore: 0,
-          characterAppearanceBalance: 0,
-          intensityFlowScore: 0,
-          recommendations: ['Analysis failed']
-        }
-      },
-      symbolicAnalysisResults: this.getDefaultSymbolicResults(),
-      stylisticAnalysisResults: this.getDefaultStylisticResults(),
-      metadata: {
-        analysisTimestamp: new Date(),
-        status: 'Failed',
-        analysisTime: 0
-      }
-    };
-  }
-}
\ No newline at end of file
diff --git a/backup_20251003_052813/server/stations/station6/station6-diagnostics-treatment.ts b/backup_20251003_052813/server/stations/station6/station6-diagnostics-treatment.ts
deleted file mode 100644
index c503b50..0000000
--- a/backup_20251003_052813/server/stations/station6/station6-diagnostics-treatment.ts
+++ /dev/null
@@ -1,343 +0,0 @@
-import { BaseStation, type StationConfig } from '../../core/pipeline/base-station';
-import { GeminiService } from '../../services/ai/gemini-service';
-import type { ConflictNetwork } from '../../core/models/base-entities';
-import logger from '../../utils/logger';
-
-export interface Station6Input {
-  conflictNetwork: ConflictNetwork;
-  station5Output: unknown;
-}
-
-export interface DiagnosticIssue {
-  issueId: string;
-  severity: 'critical' | 'high' | 'medium' | 'low';
-  category: 'character' | 'conflict' | 'relationship' | 'structure' | 'pacing';
-  description: string;
-  affectedElements: string[];
-  suggestedFix: string;
-}
-
-export interface TreatmentRecommendation {
-  recommendationId: string;
-  targetIssue: string;
-  priority: number;
-  actionType: 'add' | 'modify' | 'remove' | 'strengthen' | 'weaken';
-  specificAction: string;
-  expectedImpact: string;
-  implementationNotes: string;
-}
-
-export interface Station6Output {
-  diagnosticsReport: {
-    overallHealthScore: number;
-    criticalIssues: DiagnosticIssue[];
-    warnings: DiagnosticIssue[];
-    suggestions: DiagnosticIssue[];
-  };
-  treatmentPlan: {
-    prioritizedRecommendations: TreatmentRecommendation[];
-    estimatedImprovementScore: number;
-    implementationComplexity: 'low' | 'medium' | 'high';
-  };
-  metadata: {
-    analysisTimestamp: Date;
-    totalIssuesFound: number;
-    status: 'Success' | 'Partial' | 'Failed';
-  };
-}
-
-export class Station6DiagnosticsAndTreatment extends BaseStation<Station6Input, Station6Output> {
-  constructor(config: StationConfig, geminiService: GeminiService) {
-    super(config, geminiService);
-  }
-
-  protected async process(input: Station6Input): Promise<Station6Output> {
-    try {
-      logger.info('Starting Station 6: Diagnostics & Treatment Analysis');
-
-      const diagnosticsReport = await this.runDiagnostics(input.conflictNetwork);
-      const treatmentPlan = await this.generateTreatmentPlan(diagnosticsReport);
-
-      return {
-        diagnosticsReport,
-        treatmentPlan,
-        metadata: {
-          analysisTimestamp: new Date(),
-          totalIssuesFound:
-            diagnosticsReport.criticalIssues.length +
-            diagnosticsReport.warnings.length +
-            diagnosticsReport.suggestions.length,
-          status: 'Success'
-        }
-      };
-    } catch (error) {
-      logger.error(
-        `Error in Station 6: ${error instanceof Error ? error.message : 'Unknown error'}`
-      );
-      throw error;
-    }
-  }
-
-  private async runDiagnostics(
-    network: ConflictNetwork
-  ): Promise<Station6Output['diagnosticsReport']> {
-    const issues: DiagnosticIssue[] = [];
-
-    issues.push(...this.diagnoseCharacterIssues(network));
-    issues.push(...this.diagnoseConflictIssues(network));
-    issues.push(...this.diagnoseRelationshipIssues(network));
-
-    const criticalIssues = issues.filter(issue => issue.severity === 'critical');
-    const warnings = issues.filter(issue => issue.severity === 'high' || issue.severity === 'medium');
-    const suggestions = issues.filter(issue => issue.severity === 'low');
-
-    const overallHealthScore = this.calculateHealthScore(
-      criticalIssues.length,
-      warnings.length,
-      suggestions.length
-    );
-
-    return {
-      overallHealthScore,
-      criticalIssues,
-      warnings,
-      suggestions
-    };
-  }
-
-  private diagnoseCharacterIssues(network: ConflictNetwork): DiagnosticIssue[] {
-    const issues: DiagnosticIssue[] = [];
-
-    network.characters.forEach((character, charId) => {
-      const hasRelationships = Array.from(network.relationships.values()).some(
-        relationship => relationship.source === charId || relationship.target === charId
-      );
-
-      if (!hasRelationships) {
-        issues.push({
-          issueId: `char-isolated-${charId}`,
-          severity: 'medium',
-          category: 'character',
-          description: `Character "${character.name}" has no relationships`,
-          affectedElements: [charId],
-          suggestedFix:
-            'Consider adding at least one meaningful relationship for this character'
-        });
-      }
-
-      const hasConflicts = Array.from(network.conflicts.values()).some(conflict =>
-        conflict.involvedCharacters.includes(charId)
-      );
-
-      if (!hasConflicts && network.conflicts.size > 0) {
-        issues.push({
-          issueId: `char-no-conflict-${charId}`,
-          severity: 'low',
-          category: 'character',
-          description: `Character "${character.name}" is not involved in any conflicts`,
-          affectedElements: [charId],
-          suggestedFix:
-            'Consider involving this character in at least one conflict or subplot'
-        });
-      }
-    });
-
-    return issues;
-  }
-
-  private diagnoseConflictIssues(network: ConflictNetwork): DiagnosticIssue[] {
-    const issues: DiagnosticIssue[] = [];
-
-    if (network.conflicts.size === 0) {
-      issues.push({
-        issueId: 'no-conflicts',
-        severity: 'critical',
-        category: 'conflict',
-        description: 'No conflicts detected in the story',
-        affectedElements: [],
-        suggestedFix: 'Add at least one central conflict to drive the narrative'
-      });
-    } else if (network.conflicts.size < 2) {
-      issues.push({
-        issueId: 'few-conflicts',
-        severity: 'medium',
-        category: 'conflict',
-        description: 'Story has very few conflicts',
-        affectedElements: [],
-        suggestedFix: 'Consider adding subplots or secondary conflicts for depth'
-      });
-    }
-
-    const strengths = Array.from(network.conflicts.values()).map(conflict => conflict.strength);
-    const averageStrength =
-      strengths.length > 0
-        ? strengths.reduce((sum, value) => sum + value, 0) / strengths.length
-        : 0;
-
-    if (averageStrength < 3) {
-      issues.push({
-        issueId: 'low-conflict-strength',
-        severity: 'medium',
-        category: 'conflict',
-        description: 'Overall conflict strength is low',
-        affectedElements: Array.from(network.conflicts.keys()),
-        suggestedFix: 'Consider raising the stakes or intensifying existing conflicts'
-      });
-    }
-
-    return issues;
-  }
-
-  private diagnoseRelationshipIssues(network: ConflictNetwork): DiagnosticIssue[] {
-    const issues: DiagnosticIssue[] = [];
-
-    const relationshipTypes = new Set(
-      Array.from(network.relationships.values()).map(relationship => relationship.type)
-    );
-
-    if (relationshipTypes.size < 3 && network.relationships.size > 5) {
-      issues.push({
-        issueId: 'low-relationship-diversity',
-        severity: 'low',
-        category: 'relationship',
-        description: 'Limited variety in relationship types',
-        affectedElements: [],
-        suggestedFix:
-          'Consider adding different types of relationships (friendship, rivalry, mentorship, etc.)'
-      });
-    }
-
-    return issues;
-  }
-
-  private calculateHealthScore(critical: number, warnings: number, suggestions: number): number {
-    let score = 100;
-
-    score -= critical * 20;
-    score -= warnings * 5;
-    score -= suggestions * 2;
-
-    return Math.max(0, Math.min(100, score));
-  }
-
-  private async generateTreatmentPlan(
-    diagnostics: Station6Output['diagnosticsReport']
-  ): Promise<Station6Output['treatmentPlan']> {
-    const recommendations: TreatmentRecommendation[] = [];
-
-    diagnostics.criticalIssues.forEach((issue, index) => {
-      recommendations.push({
-        recommendationId: `rec-critical-${index}`,
-        targetIssue: issue.issueId,
-        priority: 1,
-        actionType: 'add',
-        specificAction: issue.suggestedFix,
-        expectedImpact: 'High impact on story coherence',
-        implementationNotes: 'Address this immediately'
-      });
-    });
-
-    diagnostics.warnings.forEach((issue, index) => {
-      recommendations.push({
-        recommendationId: `rec-warning-${index}`,
-        targetIssue: issue.issueId,
-        priority: 2,
-        actionType: 'modify',
-        specificAction: issue.suggestedFix,
-        expectedImpact: 'Moderate impact on story quality',
-        implementationNotes: 'Address after critical issues'
-      });
-    });
-
-    diagnostics.suggestions.forEach((issue, index) => {
-      recommendations.push({
-        recommendationId: `rec-suggestion-${index}`,
-        targetIssue: issue.issueId,
-        priority: 3,
-        actionType: 'strengthen',
-        specificAction: issue.suggestedFix,
-        expectedImpact: 'Incremental improvement to story depth',
-        implementationNotes: 'Schedule when higher priority work is complete'
-      });
-    });
-
-    recommendations.sort((a, b) => a.priority - b.priority);
-
-    const potentialImprovement = this.estimateImprovement(diagnostics);
-    const estimatedImprovementScore = Math.min(
-      100,
-      diagnostics.overallHealthScore + potentialImprovement
-    );
-
-    const implementationComplexity = this.determineComplexity(recommendations);
-
-    return {
-      prioritizedRecommendations: recommendations,
-      estimatedImprovementScore,
-      implementationComplexity
-    };
-  }
-
-  private estimateImprovement(diagnostics: Station6Output['diagnosticsReport']): number {
-    let improvement = 0;
-    improvement += diagnostics.criticalIssues.length * 17;
-    improvement += diagnostics.warnings.length * 4;
-    improvement += diagnostics.suggestions.length * 1.5;
-    return improvement;
-  }
-
-  private determineComplexity(
-    recommendations: TreatmentRecommendation[]
-  ): 'low' | 'medium' | 'high' {
-    if (recommendations.length === 0) {
-      return 'low';
-    }
-
-    if (recommendations.length <= 3) {
-      return 'low';
-    }
-
-    if (recommendations.length <= 7) {
-      return 'medium';
-    }
-
-    return 'high';
-  }
-
-  protected extractRequiredData(input: Station6Input): Record<string, unknown> {
-    return {
-      networkSize: input.conflictNetwork.characters.size,
-      conflictsCount: input.conflictNetwork.conflicts.size
-    };
-  }
-
-  protected getErrorFallback(): Station6Output {
-    return {
-      diagnosticsReport: {
-        overallHealthScore: 0,
-        criticalIssues: [
-          {
-            issueId: 'error-occurred',
-            severity: 'critical',
-            category: 'structure',
-            description: 'Analysis failed due to an error',
-            affectedElements: [],
-            suggestedFix: 'Please retry the analysis'
-          }
-        ],
-        warnings: [],
-        suggestions: []
-      },
-      treatmentPlan: {
-        prioritizedRecommendations: [],
-        estimatedImprovementScore: 0,
-        implementationComplexity: 'high'
-      },
-      metadata: {
-        analysisTimestamp: new Date(),
-        totalIssuesFound: 1,
-        status: 'Failed'
-      }
-    };
-  }
-}
diff --git a/backup_20251003_052813/server/stations/station7/station7-finalization.ts b/backup_20251003_052813/server/stations/station7/station7-finalization.ts
deleted file mode 100644
index cc5826d..0000000
--- a/backup_20251003_052813/server/stations/station7/station7-finalization.ts
+++ /dev/null
@@ -1,403 +0,0 @@
-import { BaseStation, type StationConfig } from '../../core/pipeline/base-station';
-import { ConflictNetwork, Character, Relationship, Conflict } from '../../core/models/base-entities';
-import { GeminiService } from '../../services/ai/gemini-service';
-import { Station6Output } from '../station6/station6-diagnostics-treatment';
-import { promises as fsPromises } from 'fs';
-import * as path from 'path';
-import logger from '../../utils/logger';
-
-// Station 7 Interfaces
-interface Station7Input {
-  conflictNetwork: ConflictNetwork;
-  station6Output: Station6Output;
-  allPreviousStationsData: Map<number, unknown>;
-}
-
-interface Station7Output {
-  visualizationResults: VisualizationResults;
-  platformAdaptationSuggestions: PlatformAdaptationResults;
-  finalReport: FinalAnalysisReport;
-  exportPackage: ExportPackage;
-  metadata: {
-    analysisTimestamp: Date;
-    status: 'Success' | 'Partial' | 'Failed';
-    processingTime: number;
-    filesGenerated: number;
-  };
-}
-
-interface VisualizationResults {
-  networkGraphs: Map<string, VisualizationArtifact>;
-  timelineVisualizations: Map<string, VisualizationArtifact>;
-  statisticalCharts: Map<string, VisualizationArtifact>;
-  interactiveElements: InteractiveVisualization[];
-}
-
-interface VisualizationArtifact {
-  id: string;
-  type: 'static_image' | 'interactive_html' | 'vector_graphic' | 'd3_visualization';
-  format: 'png' | 'svg' | 'html' | 'json';
-  path: string;
-  metadata: {
-    title: string;
-    description: string;
-    dimensions: { width: number; height: number };
-    generatedAt: Date;
-  };
-}
-
-interface InteractiveVisualization {
-  id: string;
-  type: 'network_explorer' | 'timeline_navigator' | 'conflict_analyzer';
-  htmlPath: string;
-  dependencies: string[];
-  features: string[];
-}
-
-interface PlatformAdaptationResults {
-  episodicBreakdown: EpisodicAdaptation;
-  cinematicSuggestions: CinematicAdaptation;
-  serializedNovelStructure: SerializedAdaptation;
-  comparativeAnalysis: string;
-}
-
-interface EpisodicAdaptation {
-  series: {
-    totalSeasons: number;
-    episodesPerSeason: number;
-    recommendedRuntime: number; // minutes
-  };
-  seasonBreakdown: Map<number, SeasonPlan>;
-  cliffhangerSuggestions: Map<number, string[]>; // season -> cliffhangers
-  characterArcMapping: Map<string, string[]>; // characterId -> episode numbers
-}
-
-interface SeasonPlan {
-  seasonNumber: number;
-  mainConflicts: string[];
-  characterFocus: string[];
-  thematicProgression: string;
-  keyMilestones: string[];
-}
-
-interface CinematicAdaptation {
-  recommendedRuntime: number; // minutes
-  actBreakdown: {
-    act1: { duration: number; keyScenes: string[]; };
-    act2: { duration: number; keyScenes: string[]; };
-    act3: { duration: number; keyScenes: string[]; };
-  };
-  visualStyle: string;
-  pacingSuggestions: string;
-  condensationStrategy: string;
-}
-
-interface SerializedAdaptation {
-  recommendedChapterCount: number;
-  volumeStructure: Map<number, VolumeDetails>;
-  cliffhangerPlacement: number[];
-  narrativePacing: string;
-}
-
-interface VolumeDetails {
-  volumeNumber: number;
-  chapterRange: [number, number];
-  mainConflicts: string[];
-  thematicFocus: string;
-}
-
-interface FinalAnalysisReport {
-  executiveSummary: string;
-  strengthsAnalysis: string[];
-  weaknessesIdentified: string[];
-  opportunitiesForImprovement: string[];
-  threatsToCohesion: string[];
-  overallAssessment: {
-    narrativeQualityScore: number;
-    structuralIntegrityScore: number;
-    characterDevelopmentScore: number;
-    conflictEffectivenessScore: number;
-    overallScore: number;
-    rating: 'Excellent' | 'Good' | 'Fair' | 'Needs Improvement' | 'Critical';
-  };
-  detailedFindings: Map<string, any>; // from each station
-}
-
-interface ExportPackage {
-  formats: Map<string, ExportFormat>;
-  deliverables: string[];
-  packagePath: string;
-}
-
-interface ExportFormat {
-  formatType: 'json' | 'pdf' | 'html' | 'markdown' | 'excel';
-  filePath: string;
-  contentSummary: string;
-}
-
-// Dummy classes for engines until they are implemented
-class VisualizationEngine {
-    constructor(private network: ConflictNetwork, private outputDir: string) {}
-
-    private async ensureDirectories(): Promise<void> {
-        const directories = ['graphs', 'charts', 'interactive'].map(subDir =>
-            path.join(this.outputDir, subDir)
-        );
-
-        await Promise.all(
-            directories.map(async dir => {
-                try {
-                    await fsPromises.mkdir(dir, { recursive: true });
-                } catch (error) {
-                    logger.error(
-                        `Failed to create visualization directory ${dir}: ${
-                            error instanceof Error ? error.message : 'Unknown error'
-                        }`
-                    );
-                    throw error;
-                }
-            })
-        );
-    }
-
-    async generateAllVisualizations(): Promise<VisualizationResults> {
-        await this.ensureDirectories();
-
-        // Dummy implementation
-        return {
-            networkGraphs: new Map(),
-            timelineVisualizations: new Map(),
-            statisticalCharts: new Map(),
-            interactiveElements: [],
-        };
-    }
-}
-
-class PlatformAdaptationEngine {
-    constructor(private network: ConflictNetwork, private s2Conceptual: any) {}
-
-    async generateAllAdaptations(): Promise<PlatformAdaptationResults> {
-        // Dummy implementation
-        return {
-            episodicBreakdown: {} as EpisodicAdaptation,
-            cinematicSuggestions: {} as CinematicAdaptation,
-            serializedNovelStructure: {} as SerializedAdaptation,
-            comparativeAnalysis: "Comparative analysis not yet implemented.",
-        };
-    }
-}
-
-class FinalReportGenerator {
-    constructor(private network: ConflictNetwork, private allStationsData: Map<number, any>) {}
-
-    async generateComprehensiveReport(): Promise<FinalAnalysisReport> {
-        // Dummy implementation
-        return {
-            executiveSummary: "Executive summary not yet implemented.",
-            strengthsAnalysis: [],
-            weaknessesIdentified: [],
-            opportunitiesForImprovement: [],
-            threatsToCohesion: [],
-            overallAssessment: {
-                narrativeQualityScore: 0,
-                structuralIntegrityScore: 0,
-                characterDevelopmentScore: 0,
-                conflictEffectivenessScore: 0,
-                overallScore: 0,
-                rating: 'Fair',
-            },
-            detailedFindings: new Map(),
-        };
-    }
-}
-
-class ExportPackageGenerator {
-    constructor(private outputDir: string, private allStationsData: Map<number, any>, private finalReport: FinalAnalysisReport) {}
-
-    async generateExportPackage(): Promise<ExportPackage> {
-        // Dummy implementation
-        return {
-            formats: new Map(),
-            deliverables: [],
-            packagePath: this.outputDir,
-        };
-    }
-}
-
-
-export class Station7Finalization extends BaseStation<Station7Input, Station7Output> {
-    private visualizationEngine: VisualizationEngine;
-    private adaptationEngine: PlatformAdaptationEngine;
-    private reportGenerator: FinalReportGenerator;
-    private exportGenerator: ExportPackageGenerator;
-    private outputDir: string;
-
-    constructor(
-        config: StationConfig,
-        geminiService: GeminiService,
-        outputDir: string = 'analysis_output'
-    ) {
-        super(config, geminiService);
-        this.outputDir = outputDir;
-    }
-
-    protected async process(input: Station7Input): Promise<Station7Output> {
-        const startTime = Date.now();
-        logger.info("S7: Starting finalization and visualization...");
-
-        try {
-            await fsPromises.mkdir(this.outputDir, { recursive: true });
-        } catch (error) {
-            logger.error(
-                `S7: Failed to ensure output directory: ${
-                    error instanceof Error ? error.message : 'Unknown error'
-                }`
-            );
-            throw error;
-        }
-
-        // Initialize engines with necessary data
-        this.visualizationEngine = new VisualizationEngine(input.conflictNetwork, this.outputDir);
-        this.adaptationEngine = new PlatformAdaptationEngine(input.conflictNetwork, input.allPreviousStationsData.get(2));
-        this.reportGenerator = new FinalReportGenerator(input.conflictNetwork, input.allPreviousStationsData);
-
-        // 1. Generate Visualizations
-        const visualizationResults = await this.visualizationEngine.generateAllVisualizations();
-        logger.info("S7: Visualizations generated.");
-
-        // 2. Generate Platform Adaptation Suggestions
-        const platformAdaptationSuggestions = await this.adaptationEngine.generateAllAdaptations();
-        logger.info("S7: Platform adaptations suggested.");
-
-        // 3. Generate Final Report
-        const finalReport = await this.reportGenerator.generateComprehensiveReport();
-        logger.info("S7: Final report generated.");
-
-        // 4. Generate Export Package
-        this.exportGenerator = new ExportPackageGenerator(this.outputDir, input.allPreviousStationsData, finalReport);
-        const exportPackage = await this.exportGenerator.generateExportPackage();
-        logger.info("S7: Export package created.");
-
-        await this.saveOutputs(finalReport, visualizationResults);
-
-        const processingTime = Date.now() - startTime;
-        const filesGenerated = this.countGeneratedFiles(visualizationResults);
-
-        return {
-            visualizationResults,
-            platformAdaptationSuggestions,
-            finalReport,
-            exportPackage,
-            metadata: {
-                analysisTimestamp: new Date(),
-                status: 'Success',
-                processingTime,
-                filesGenerated,
-            },
-        };
-    }
-
-    private async saveOutputs(
-        finalReport: FinalAnalysisReport,
-        visualizationResults: VisualizationResults
-    ): Promise<void> {
-        try {
-            const reportPath = path.join(this.outputDir, 'final-report.json');
-            await fsPromises.writeFile(
-                reportPath,
-                JSON.stringify(finalReport, null, 2),
-                'utf-8'
-            );
-            logger.info(`S7: Saved final report to ${reportPath}`);
-
-            const visualizationPayload = {
-                networkGraphs: Array.from(visualizationResults.networkGraphs.entries()),
-                timelineVisualizations: Array.from(
-                    visualizationResults.timelineVisualizations.entries()
-                ),
-                statisticalCharts: Array.from(
-                    visualizationResults.statisticalCharts.entries()
-                ),
-                interactiveElements: visualizationResults.interactiveElements,
-            };
-
-            const visualizationPath = path.join(this.outputDir, 'visualizations.json');
-            await fsPromises.writeFile(
-                visualizationPath,
-                JSON.stringify(visualizationPayload, null, 2),
-                'utf-8'
-            );
-            logger.info(`S7: Saved visualizations to ${visualizationPath}`);
-        } catch (error) {
-            logger.error(
-                `S7: Failed to save outputs: ${
-                    error instanceof Error ? error.message : 'Unknown error'
-                }`
-            );
-            throw new Error('Output save operation failed');
-        }
-    }
-
-    private countGeneratedFiles(visualizationResults: VisualizationResults): number {
-        const visualizationCount =
-            visualizationResults.networkGraphs.size +
-            visualizationResults.timelineVisualizations.size +
-            visualizationResults.statisticalCharts.size +
-            visualizationResults.interactiveElements.length;
-
-        return visualizationCount + 2; // final report + visualization payload files
-    }
-
-    protected extractRequiredData(input: Station7Input): Record<string, unknown> {
-        return {
-            charactersCount: input.conflictNetwork.characters.length,
-            conflictsCount: input.conflictNetwork.conflicts.length,
-            station6Issues: input.station6Output.diagnosticsReport.criticalIssues.length,
-            stationsTracked: input.allPreviousStationsData.size,
-        };
-    }
-
-    protected getErrorFallback(): Station7Output {
-        return {
-            visualizationResults: {
-                networkGraphs: new Map(),
-                timelineVisualizations: new Map(),
-                statisticalCharts: new Map(),
-                interactiveElements: [],
-            },
-            platformAdaptationSuggestions: {
-                episodicBreakdown: {} as EpisodicAdaptation,
-                cinematicSuggestions: {} as CinematicAdaptation,
-                serializedNovelStructure: {} as SerializedAdaptation,
-                comparativeAnalysis: "Failed to generate comparative analysis.",
-            },
-            finalReport: {
-                executiveSummary: "Failed to generate final report.",
-                strengthsAnalysis: [],
-                weaknessesIdentified: [],
-                opportunitiesForImprovement: [],
-                threatsToCohesion: [],
-                overallAssessment: {
-                    narrativeQualityScore: 0,
-                    structuralIntegrityScore: 0,
-                    characterDevelopmentScore: 0,
-                    conflictEffectivenessScore: 0,
-                    overallScore: 0,
-                    rating: 'Critical',
-                },
-                detailedFindings: new Map(),
-            },
-            exportPackage: {
-                formats: new Map(),
-                deliverables: [],
-                packagePath: this.outputDir,
-            },
-            metadata: {
-                analysisTimestamp: new Date(),
-                status: 'Failed',
-                processingTime: 0,
-                filesGenerated: 0,
-            },
-        };
-    }
-}
\ No newline at end of file
diff --git a/backup_20251003_052813/server/storage.ts b/backup_20251003_052813/server/storage.ts
deleted file mode 100644
index ee25bd1..0000000
--- a/backup_20251003_052813/server/storage.ts
+++ /dev/null
@@ -1,38 +0,0 @@
-import { type User, type InsertUser } from "@shared/schema";
-import { randomUUID } from "crypto";
-
-// modify the interface with any CRUD methods
-// you might need
-
-export interface IStorage {
-  getUser(id: string): Promise<User | undefined>;
-  getUserByUsername(username: string): Promise<User | undefined>;
-  createUser(user: InsertUser): Promise<User>;
-}
-
-export class MemStorage implements IStorage {
-  private users: Map<string, User>;
-
-  constructor() {
-    this.users = new Map();
-  }
-
-  async getUser(id: string): Promise<User | undefined> {
-    return this.users.get(id);
-  }
-
-  async getUserByUsername(username: string): Promise<User | undefined> {
-    return Array.from(this.users.values()).find(
-      (user) => user.username === username,
-    );
-  }
-
-  async createUser(insertUser: InsertUser): Promise<User> {
-    const id = randomUUID();
-    const user: User = { ...insertUser, id };
-    this.users.set(id, user);
-    return user;
-  }
-}
-
-export const storage = new MemStorage();
diff --git a/backup_20251003_052813/server/types/contexts.ts b/backup_20251003_052813/server/types/contexts.ts
deleted file mode 100644
index 89b67ac..0000000
--- a/backup_20251003_052813/server/types/contexts.ts
+++ /dev/null
@@ -1,27 +0,0 @@
-export interface Station1Context {
-  fullText: string;
-  projectName: string;
-  proseFilePath?: string;
-}
-
-export interface Station2Context {
-  majorCharacters: string[];
-  relationshipSummary: string;
-  narrativeTone: string;
-  fullText: string;
-}
-
-export interface Station3Context {
-  majorCharacters: string[];
-  characterProfiles: Map<string, any>;
-  relationshipData: any[];
-  fullText: string;
-}
-
-export interface AIPromptContext {
-  systemInstruction?: string;
-  previousAnalysis?: string;
-  analysisGoal: string;
-  textSample: string;
-  constraints?: string[];
-}
diff --git a/backup_20251003_052813/server/utils/logger.ts b/backup_20251003_052813/server/utils/logger.ts
deleted file mode 100644
index 4571f35..0000000
--- a/backup_20251003_052813/server/utils/logger.ts
+++ /dev/null
@@ -1,62 +0,0 @@
-import winston from 'winston';
-import * as fs from 'fs';
-import * as path from 'path';
-
-const { combine, timestamp, printf, colorize, errors } = winston.format;
-
-// Ensure logs directory exists
-const logsDir = path.join(process.cwd(), 'logs');
-if (!fs.existsSync(logsDir)) {
-  fs.mkdirSync(logsDir, { recursive: true });
-}
-
-const customFormat = printf(({ level, message, timestamp, stack, ...meta }) => {
-  let log = `${timestamp} [${level}]: ${message}`;
-
-  if (Object.keys(meta).length > 0) {
-    log += ` ${JSON.stringify(meta)}`;
-  }
-
-  if (stack) {
-    log += `\n${stack}`;
-  }
-
-  return log;
-});
-
-const logger = winston.createLogger({
-  level: process.env.LOG_LEVEL || 'info',
-  format: combine(
-    errors({ stack: true }),
-    timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
-    customFormat
-  ),
-  transports: [
-    new winston.transports.Console({
-      format: combine(
-        colorize(),
-        customFormat
-      )
-    }),
-    new winston.transports.File({
-      filename: 'logs/error.log',
-      level: 'error',
-      maxsize: 5242880,
-      maxFiles: 5,
-    }),
-    new winston.transports.File({
-      filename: 'logs/combined.log',
-      maxsize: 5242880,
-      maxFiles: 5,
-    })
-  ],
-  exitOnError: false
-});
-
-export const stream = {
-  write: (message: string) => {
-    logger.info(message.trim());
-  }
-};
-
-export default logger;
diff --git a/backup_20251003_052813/server/vite.ts b/backup_20251003_052813/server/vite.ts
deleted file mode 100644
index 9338c14..0000000
--- a/backup_20251003_052813/server/vite.ts
+++ /dev/null
@@ -1,85 +0,0 @@
-import express, { type Express } from "express";
-import fs from "fs";
-import path from "path";
-import { createServer as createViteServer, createLogger } from "vite";
-import { type Server } from "http";
-import viteConfig from "../vite.config";
-import { nanoid } from "nanoid";
-
-const viteLogger = createLogger();
-
-export function log(message: string, source = "express") {
-  const formattedTime = new Date().toLocaleTimeString("en-US", {
-    hour: "numeric",
-    minute: "2-digit",
-    second: "2-digit",
-    hour12: true,
-  });
-
-  console.log(`${formattedTime} [${source}] ${message}`);
-}
-
-export async function setupVite(app: Express, server: Server) {
-  const serverOptions = {
-    middlewareMode: true,
-    hmr: { server },
-    allowedHosts: true as const,
-  };
-
-  const vite = await createViteServer({
-    ...viteConfig,
-    configFile: false,
-    customLogger: {
-      ...viteLogger,
-      error: (msg, options) => {
-        viteLogger.error(msg, options);
-        process.exit(1);
-      },
-    },
-    server: serverOptions,
-    appType: "custom",
-  });
-
-  app.use(vite.middlewares);
-  app.use("*", async (req, res, next) => {
-    const url = req.originalUrl;
-
-    try {
-      const clientTemplate = path.resolve(
-        import.meta.dirname,
-        "..",
-        "client",
-        "index.html",
-      );
-
-      // always reload the index.html file from disk incase it changes
-      let template = await fs.promises.readFile(clientTemplate, "utf-8");
-      template = template.replace(
-        `src="/src/main.tsx"`,
-        `src="/src/main.tsx?v=${nanoid()}"`,
-      );
-      const page = await vite.transformIndexHtml(url, template);
-      res.status(200).set({ "Content-Type": "text/html" }).end(page);
-    } catch (e) {
-      vite.ssrFixStacktrace(e as Error);
-      next(e);
-    }
-  });
-}
-
-export function serveStatic(app: Express) {
-  const distPath = path.resolve(import.meta.dirname, "public");
-
-  if (!fs.existsSync(distPath)) {
-    throw new Error(
-      `Could not find the build directory: ${distPath}, make sure to build the client first`,
-    );
-  }
-
-  app.use(express.static(distPath));
-
-  // fall through to index.html if the file doesn't exist
-  app.use("*", (_req, res) => {
-    res.sendFile(path.resolve(distPath, "index.html"));
-  });
-}
diff --git a/backup_20251003_052813/tsconfig.json b/backup_20251003_052813/tsconfig.json
deleted file mode 100644
index d00e754..0000000
--- a/backup_20251003_052813/tsconfig.json
+++ /dev/null
@@ -1,30 +0,0 @@
-{
-  "include": ["src/**/*", "shared/**/*", "server/**/*"],
-  "exclude": ["node_modules", "build", "dist", "**/*.test.ts", "**/*.spec.ts"],
-  "compilerOptions": {
-    "incremental": true,
-    "tsBuildInfoFile": "./node_modules/typescript/tsbuildinfo",
-    "noEmit": true,
-    "target": "ES2020",
-    "module": "ESNext",
-    "strict": true,
-    "lib": ["ES2020", "dom", "dom.iterable"],
-    "jsx": "preserve",
-    "esModuleInterop": true,
-    "skipLibCheck": true,
-    "allowImportingTsExtensions": true,
-    "moduleResolution": "bundler",
-    "downlevelIteration": true,
-    "allowSyntheticDefaultImports": true,
-    "forceConsistentCasingInFileNames": true,
-    "baseUrl": ".",
-    "types": ["node", "vite/client"],
-    "noUncheckedIndexedAccess": true,
-    "exactOptionalPropertyTypes": true,
-    "paths": {
-      "@/*": ["./src/*"],
-      "@shared/*": ["./shared/*"],
-      "@server/*": ["./server/*"]
-    }
-  }
-}
diff --git a/example_usage.py b/example_usage.py
deleted file mode 100644
index c5972db..0000000
--- a/example_usage.py
+++ /dev/null
@@ -1,353 +0,0 @@
-#!/usr/bin/env python3
-# -*- coding: utf-8 -*-
-"""
-مثال عملي شامل لاستخدام نظام تحليل النصوص الدرامية
-=======================================================
-
-هذا المثال يوضح كيفية استخدام النظام بشكل كامل من البداية للنهاية.
-
-المؤلف: نظام تحليل النصوص الدرامية
-الإصدار: 2.0.0
-"""
-
-import os
-import sys
-import json
-from pathlib import Path
-from datetime import datetime
-
-# إضافة المسار للوصول للمكتبات
-sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'backend'))
-
-# استيراد المكتبات الأساسية
-from core.base_entities import (
-    ConflictNetwork,
-    Character,
-    Relationship,
-    Conflict,
-    RelationshipType,
-    RelationshipNature,
-    ConflictPhase,
-    ConflictSubject,
-    ConflictScope
-)
-
-# استيراد وحدات التحليل
-from analysis_modules.network_diagnostics import NetworkDiagnostics, diagnose_network
-from analysis_modules.treatment_strategies import TreatmentStrategies, generate_treatments
-from analysis_modules.efficiency_metrics import EfficiencyMetrics
-
-
-def print_section(title):
-    """طباعة عنوان قسم منسق"""
-    print("\n" + "="*70)
-    print(f"  {title}")
-    print("="*70 + "\n")
-
-
-def example_1_basic_network_creation():
-    """
-    مثال 1: إنشاء شبكة صراع بسيطة يدوياً
-    """
-    print_section("مثال 1: إنشاء شبكة صراع بسيطة")
-    
-    # إنشاء الشبكة
-    network = ConflictNetwork("قصة الحب والخيانة")
-    print(f"✓ تم إنشاء الشبكة: {network.name}")
-    
-    # إضافة شخصيات
-    char1 = Character(
-        id="char1",
-        name="علي",
-        description="شاب طموح يسعى للعدالة"
-    )
-    char1.profile = {
-        "personality_traits": "شجاع، متهور، مخلص",
-        "motivations_goals": "البحث عن الحقيقة والانتقام لوالده",
-        "potential_arc": "من الانتقام إلى العفو"
-    }
-    
-    char2 = Character(
-        id="char2",
-        name="فاطمة",
-        description="فتاة قوية وذكية"
-    )
-    char2.profile = {
-        "personality_traits": "ذكية، حذرة، عاطفية",
-        "motivations_goals": "حماية عائلتها وإنقاذ علي من نفسه",
-        "potential_arc": "من الخوف إلى الشجاعة"
-    }
-    
-    char3 = Character(
-        id="char3",
-        name="أحمد",
-        description="الخصم القوي"
-    )
-    char3.profile = {
-        "personality_traits": "قاسي، ذكي، مخادع",
-        "motivations_goals": "الحفاظ على السلطة بأي ثمن",
-        "potential_arc": "من القوة إلى السقوط"
-    }
-    
-    network.add_character(char1)
-    network.add_character(char2)
-    network.add_character(char3)
-    print(f"✓ تم إضافة {len(network.characters)} شخصيات")
-    
-    # إضافة علاقات
-    rel1 = Relationship(
-        id="rel1",
-        source="char1",
-        target="char2",
-        type=RelationshipType.LOVE,
-        nature=RelationshipNature.POSITIVE,
-        strength=8,
-        description="علاقة حب قوية"
-    )
-    
-    rel2 = Relationship(
-        id="rel2",
-        source="char1",
-        target="char3",
-        type=RelationshipType.ENMITY,
-        nature=RelationshipNature.NEGATIVE,
-        strength=9,
-        description="عداوة مستحكمة"
-    )
-    
-    network.add_relationship(rel1)
-    network.add_relationship(rel2)
-    print(f"✓ تم إضافة {len(network.relationships)} علاقات")
-    
-    # إضافة صراعات
-    conflict1 = Conflict(
-        id="conf1",
-        name="الصراع على العدالة",
-        description="علي يسعى لفضح أحمد وتحقيق العدالة",
-        involved_characters=["char1", "char3"],
-        subject=ConflictSubject.VALUE,
-        scope=ConflictScope.PERSONAL,
-        phase=ConflictPhase.ESCALATING,
-        strength=8
-    )
-    conflict1.related_relationships = ["rel2"]
-    conflict1.timestamps = [datetime.now()]
-    
-    network.add_conflict(conflict1)
-    print(f"✓ تم إضافة {len(network.conflicts)} صراعات")
-    
-    # إنشاء لقطة
-    network.create_snapshot("الحالة الأولية للشبكة")
-    print(f"✓ تم إنشاء لقطة زمنية")
-    
-    # عرض ملخص
-    print("\nملخص الشبكة:")
-    print(f"  • الشخصيات: {len(network.characters)}")
-    print(f"  • العلاقات: {len(network.relationships)}")
-    print(f"  • الصراعات: {len(network.conflicts)}")
-    print(f"  • اللقطات: {len(network.snapshots)}")
-    
-    return network
-
-
-def example_2_network_diagnostics(network):
-    """
-    مثال 2: تشخيص الشبكة
-    """
-    print_section("مثال 2: تشخيص شامل للشبكة")
-    
-    # تشغيل التشخيص
-    print("🔍 جاري تشغيل التشخيص الشامل...")
-    diagnostics = NetworkDiagnostics(network)
-    report = diagnostics.run_all_diagnostics()
-    
-    # عرض النتائج
-    print(f"\n📊 درجة الصحة: {report['overall_health_score']:.1f}/100")
-    print(f"⚠️  مستوى الخطورة: {report['criticality_level']}")
-    
-    print(f"\n📋 المشاكل المكتشفة:")
-    print(f"  • مشاكل هيكلية: {len(report['structural_issues'])}")
-    print(f"  • شخصيات معزولة: {report['isolated_characters']['total_isolated']}")
-    print(f"  • صراعات مهملة: {report['abandoned_conflicts']['total_abandoned']}")
-    print(f"  • شخصيات محملة: {report['overloaded_characters']['total_overloaded']}")
-    print(f"  • اتصالات ضعيفة: {report['weak_connections']['total_weak']}")
-    print(f"  • تكرارات: {report['redundancy_issues']['total_redundant']}")
-    
-    # عرض الملخص
-    print(f"\n{report['summary']}")
-    
-    return report
-
-
-def example_3_treatment_strategies(network, diagnostics_report):
-    """
-    مثال 3: توليد استراتيجيات العلاج
-    """
-    print_section("مثال 3: استراتيجيات العلاج المقترحة")
-    
-    # توليد الاستراتيجيات
-    print("💡 جاري توليد استراتيجيات العلاج...")
-    treatment = TreatmentStrategies(network, diagnostics_report)
-    recommendations = treatment.analyze_and_recommend_treatments()
-    
-    # عرض الإجراءات ذات الأولوية
-    print(f"\n🎯 الإجراءات ذات الأولوية ({len(recommendations['prioritized_actions'])}):")
-    for i, action in enumerate(recommendations['prioritized_actions'][:3], 1):
-        print(f"\n  {i}. [{action['priority'].upper()}] {action['description']}")
-        print(f"     الوقت المقدر: {action['estimated_time']}")
-        print(f"     الجهد: {action['effort']}")
-    
-    # عرض الإصلاحات السريعة
-    if recommendations['quick_fixes']:
-        print(f"\n⚡ إصلاحات سريعة ({len(recommendations['quick_fixes'])}):")
-        for i, fix in enumerate(recommendations['quick_fixes'][:2], 1):
-            print(f"\n  {i}. {fix['description']}")
-            print(f"     الوقت: {fix['estimated_time']}")
-    
-    # عرض الملخص الموحد
-    print(f"\n{recommendations['consolidated_summary']}")
-    
-    return recommendations
-
-
-def example_4_efficiency_metrics(network):
-    """
-    مثال 4: قياس مقاييس الكفاءة
-    """
-    print_section("مثال 4: مقاييس الكفاءة والفعالية")
-    
-    # حساب المقاييس
-    print("📈 جاري حساب مقاييس الكفاءة...")
-    efficiency = EfficiencyMetrics(network)
-    metrics = efficiency.analyze_efficiency()
-    
-    # عرض النتائج
-    print(f"\n📊 النتائج:")
-    print(f"  • الدرجة الإجمالية: {metrics.get('overall_efficiency_score', 0):.2f}")
-    print(f"  • التصنيف: {metrics.get('overall_rating', 'N/A')}")
-    print(f"  • تماسك الصراع: {metrics.get('conflict_cohesion', 0):.2f}")
-    
-    if 'dramatic_balance' in metrics:
-        balance = metrics['dramatic_balance']
-        print(f"  • التوازن الدرامي: {balance.get('balance_score', 0):.2f}")
-        print(f"  • معامل جيني: {balance.get('character_involvement_gini', 0):.2f}")
-    
-    if 'narrative_efficiency' in metrics:
-        eff = metrics['narrative_efficiency']
-        print(f"  • كفاءة السرد: {eff.get('narrative_efficiency_score', 0):.2f}")
-    
-    return metrics
-
-
-def example_5_export_results(network, diagnostics, treatments, metrics):
-    """
-    مثال 5: تصدير النتائج
-    """
-    print_section("مثال 5: تصدير النتائج")
-    
-    # إنشاء مجلد المخرجات
-    output_dir = Path("example_output")
-    output_dir.mkdir(exist_ok=True)
-    print(f"✓ تم إنشاء مجلد المخرجات: {output_dir}")
-    
-    # تصدير ملخص الشبكة
-    network_summary = {
-        "network_name": network.name,
-        "characters": {char.id: char.name for char in network.characters.values()},
-        "relationships_count": len(network.relationships),
-        "conflicts_count": len(network.conflicts),
-        "created_at": datetime.now().isoformat()
-    }
-    
-    with open(output_dir / "network_summary.json", 'w', encoding='utf-8') as f:
-        json.dump(network_summary, f, ensure_ascii=False, indent=2)
-    print("✓ تم حفظ: network_summary.json")
-    
-    # تصدير التشخيص
-    with open(output_dir / "diagnostics_report.json", 'w', encoding='utf-8') as f:
-        json.dump(diagnostics, f, ensure_ascii=False, indent=2, default=str)
-    print("✓ تم حفظ: diagnostics_report.json")
-    
-    # تصدير التوصيات
-    with open(output_dir / "treatment_recommendations.json", 'w', encoding='utf-8') as f:
-        json.dump(treatments, f, ensure_ascii=False, indent=2)
-    print("✓ تم حفظ: treatment_recommendations.json")
-    
-    # تصدير المقاييس
-    with open(output_dir / "efficiency_metrics.json", 'w', encoding='utf-8') as f:
-        json.dump(metrics, f, ensure_ascii=False, indent=2, default=str)
-    print("✓ تم حفظ: efficiency_metrics.json")
-    
-    # إنشاء تقرير Markdown
-    report_md = f"""# تقرير التحليل الشامل
-
-## معلومات الشبكة
-- **الاسم**: {network.name}
-- **الشخصيات**: {len(network.characters)}
-- **العلاقات**: {len(network.relationships)}
-- **الصراعات**: {len(network.conflicts)}
-- **تاريخ التحليل**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
-
-## نتائج التشخيص
-- **درجة الصحة**: {diagnostics['overall_health_score']:.1f}/100
-- **مستوى الخطورة**: {diagnostics['criticality_level']}
-
-## التوصيات الرئيسية
-- إجمالي التوصيات: {treatments['total_recommendations']}
-- إجراءات ذات أولوية: {len(treatments['prioritized_actions'])}
-- إصلاحات سريعة: {len(treatments['quick_fixes'])}
-
-## مقاييس الكفاءة
-- الدرجة الإجمالية: {metrics.get('overall_efficiency_score', 0):.2f}
-- التصنيف: {metrics.get('overall_rating', 'N/A')}
-
----
-تم التوليد بواسطة: نظام تحليل النصوص الدرامية v2.0.0
-"""
-    
-    with open(output_dir / "full_report.md", 'w', encoding='utf-8') as f:
-        f.write(report_md)
-    print("✓ تم حفظ: full_report.md")
-    
-    print(f"\n✅ تم تصدير جميع النتائج إلى: {output_dir.absolute()}")
-
-
-def main():
-    """
-    الدالة الرئيسية لتشغيل جميع الأمثلة
-    """
-    print("\n" + "="*70)
-    print("  🎭 مثال عملي شامل لنظام تحليل النصوص الدرامية")
-    print("="*70)
-    
-    try:
-        # مثال 1: إنشاء شبكة
-        network = example_1_basic_network_creation()
-        
-        # مثال 2: تشخيص الشبكة
-        diagnostics = example_2_network_diagnostics(network)
-        
-        # مثال 3: استراتيجيات العلاج
-        treatments = example_3_treatment_strategies(network, diagnostics)
-        
-        # مثال 4: مقاييس الكفاءة
-        metrics = example_4_efficiency_metrics(network)
-        
-        # مثال 5: تصدير النتائج
-        example_5_export_results(network, diagnostics, treatments, metrics)
-        
-        print_section("اكتمل التنفيذ بنجاح! ✅")
-        print("🎉 تم تشغيل جميع الأمثلة بنجاح!")
-        print("\n💡 نصيحة: راجع المخرجات في مجلد 'example_output'")
-        
-    except Exception as e:
-        print(f"\n❌ خطأ: {str(e)}")
-        import traceback
-        traceback.print_exc()
-        return 1
-    
-    return 0
-
-
-if __name__ == "__main__":
-    sys.exit(main())
diff --git a/requirements.txt b/requirements.txt
deleted file mode 100644
index 47935a9..0000000
--- a/requirements.txt
+++ /dev/null
@@ -1,125 +0,0 @@
-# ======================================
-# نظام تحليل النصوص الدرامية المتقدم
-# ملف التبعيات الرئيسية
-# ======================================
-
-# --- Core AI/ML Libraries ---
-openai>=1.12.0                  # OpenAI GPT models integration
-google-generativeai>=0.3.2      # Google Gemini models
-anthropic>=0.18.0               # Anthropic Claude models (optional)
-
-# --- Network Analysis ---
-networkx>=3.2.1                 # Graph/network analysis and visualization
-python-louvain>=0.16            # Community detection in networks
-
-# --- Data Processing & Analysis ---
-numpy>=1.24.0                   # Numerical computing
-pandas>=2.0.0                   # Data manipulation and analysis
-scipy>=1.10.0                   # Scientific computing
-
-# --- Visualization ---
-matplotlib>=3.7.0               # Plotting and visualization
-seaborn>=0.12.0                 # Statistical data visualization
-plotly>=5.17.0                  # Interactive plots
-pyvis>=0.3.2                    # Interactive network visualizations
-
-# --- Natural Language Processing ---
-nltk>=3.8.1                     # Natural language toolkit
-spacy>=3.7.0                    # Advanced NLP (optional, requires model download)
-transformers>=4.35.0            # Hugging Face transformers (optional for advanced NLP)
-
-# --- Configuration & Serialization ---
-pyyaml>=6.0.1                   # YAML configuration files
-python-dotenv>=1.0.0            # Environment variable management
-toml>=0.10.2                    # TOML configuration support
-
-# --- Caching & Performance ---
-joblib>=1.3.2                   # Efficient serialization and caching
-redis>=5.0.0                    # Redis client for distributed caching (optional)
-diskcache>=5.6.3                # Simple disk caching
-
-# --- Async & Concurrency ---
-asyncio>=3.4.3                  # Asynchronous I/O
-aiohttp>=3.9.0                  # Async HTTP client/server
-aiofiles>=23.2.1                # Async file operations
-
-# --- Progress & Logging ---
-tqdm>=4.66.0                    # Progress bars
-colorlog>=6.8.0                 # Colored terminal logs
-loguru>=0.7.2                   # Advanced logging (alternative)
-
-# --- File Handling ---
-python-docx>=1.1.0              # Microsoft Word document handling
-openpyxl>=3.1.2                 # Excel file handling
-pypdf>=3.17.0                   # PDF reading and manipulation
-pillow>=10.1.0                  # Image processing
-
-# --- HTTP & API ---
-requests>=2.31.0                # HTTP library
-urllib3>=2.1.0                  # HTTP client
-httpx>=0.25.0                   # Modern HTTP client
-
-# --- Testing ---
-pytest>=7.4.3                   # Testing framework
-pytest-cov>=4.1.0               # Test coverage
-pytest-asyncio>=0.21.1          # Async testing support
-pytest-mock>=3.12.0             # Mocking for tests
-
-# --- Code Quality ---
-black>=23.12.0                  # Code formatter
-flake8>=6.1.0                   # Linting
-mypy>=1.7.0                     # Static type checking
-pylint>=3.0.0                   # Code analysis
-
-# --- Documentation ---
-sphinx>=7.2.6                   # Documentation generator
-sphinx-rtd-theme>=2.0.0         # Read the Docs theme
-
-# --- Utilities ---
-python-dateutil>=2.8.2          # Date/time utilities
-pytz>=2023.3                    # Timezone support
-click>=8.1.7                    # CLI creation
-rich>=13.7.0                    # Rich terminal output
-
-# --- Security ---
-cryptography>=41.0.7            # Cryptographic recipes
-pyjwt>=2.8.0                    # JSON Web Tokens
-
-# --- Optional: Advanced Features ---
-# langchain>=0.1.0              # LLM orchestration framework
-# chromadb>=0.4.0               # Vector database for embeddings
-# sentence-transformers>=2.2.0  # Sentence embeddings
-# fastapi>=0.104.0              # Web framework for API
-# uvicorn>=0.24.0               # ASGI server
-
-# --- Development Tools ---
-ipython>=8.18.0                 # Enhanced Python shell
-jupyter>=1.0.0                  # Jupyter notebooks
-notebook>=7.0.6                 # Jupyter notebook interface
-
-# --- Platform-specific (Windows) ---
-# pywin32>=306                  # Windows API access (Windows only)
-
-# ======================================
-# Installation Instructions:
-# 
-# 1. Basic installation:
-#    pip install -r requirements.txt
-#
-# 2. With development tools:
-#    pip install -r requirements.txt -r requirements-dev.txt
-#
-# 3. Specific versions:
-#    pip install -r requirements.txt --upgrade
-#
-# 4. Virtual environment (recommended):
-#    python -m venv venv
-#    source venv/bin/activate  # Linux/Mac
-#    venv\Scripts\activate     # Windows
-#    pip install -r requirements.txt
-# ======================================
-
-# Version Information:
-# Python Version: >= 3.8
-# Last Updated: 2025-01-02
-# Compatibility: Linux, macOS, Windows
