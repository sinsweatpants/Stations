

Edit2 / 2Ø§Ù„Ø³ÙŠØ§Ù‚ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ Ù„Ø¨Ù†Ø§Ø¡ Ù†Ø¸Ø§Ù… ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù†ØµÙˆØµ Ø§Ù„Ø¯Ø±Ø§Ù…ÙŠØ©
ğŸ“‹ Ù†Ø¸Ø±Ø© Ø¹Ø§Ù…Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹
Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠ
Ø¨Ù†Ø§Ø¡ Ù†Ø¸Ø§Ù… Ù…ØªÙƒØ§Ù…Ù„ Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù†ØµÙˆØµ Ø§Ù„Ø³Ø±Ø¯ÙŠØ© ÙˆØ§Ù„Ø¯Ø±Ø§Ù…ÙŠØ© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… TypeScriptØŒ ÙŠØªÙƒÙˆÙ† Ù…Ù† 7 Ù…Ø­Ø·Ø§Øª Ù…ØªØ³Ù„Ø³Ù„Ø©ØŒ ÙƒÙ„ Ù…Ù†Ù‡Ø§ Ù…ØªØ®ØµØµØ© ÙÙŠ Ø¬Ø§Ù†Ø¨ Ù…Ø­Ø¯Ø¯ Ù…Ù† Ø§Ù„ØªØ­Ù„ÙŠÙ„ØŒ Ù…Ø¹ Ø¶Ù…Ø§Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù†Ù…Ø§Ø°Ø¬ Gemini 2.5 Ø­ØµØ±ÙŠÙ‹Ø§.

ğŸ—ï¸ Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„Ù…Ø¹Ù…Ø§Ø±ÙŠØ© Ø§Ù„Ø´Ø§Ù…Ù„Ø©
Ø§Ù„Ù†Ù…Ø· Ø§Ù„Ù…Ø¹Ù…Ø§Ø±ÙŠ: Pipeline Architecture
typescriptinterface PipelineStage<TInput, TOutput> {
  stageName: string;
  process(input: TInput): Promise<TOutput>;
  validate(output: TOutput): boolean;
}

// ØªØ¯ÙÙ‚ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
Text â†’ S1 â†’ S2 â†’ S3 â†’ S4 â†’ S5 â†’ S6 â†’ S7 â†’ Final Output
Ø§Ù„Ù…Ø¨Ø§Ø¯Ø¦ Ø§Ù„Ù…Ø¹Ù…Ø§Ø±ÙŠØ© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©

Single Responsibility Principle: ÙƒÙ„ Ù…Ø­Ø·Ø© Ù…Ø³Ø¤ÙˆÙ„Ø© Ø¹Ù† Ù…Ù‡Ù…Ø© ØªØ­Ù„ÙŠÙ„ÙŠØ© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø·
Open/Closed Principle: Ø§Ù„Ù…Ø­Ø·Ø§Øª Ù…ÙØªÙˆØ­Ø© Ù„Ù„ØªÙˆØ³Ø¹ØŒ Ù…ØºÙ„Ù‚Ø© Ù„Ù„ØªØ¹Ø¯ÙŠÙ„
Dependency Inversion: Ø§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯ Ø¹Ù„Ù‰ ÙˆØ§Ø¬Ù‡Ø§Øª Ù…Ø¬Ø±Ø¯Ø© ÙˆÙ„ÙŠØ³ ØªØ·Ø¨ÙŠÙ‚Ø§Øª Ù…Ø­Ø¯Ø¯Ø©
Interface Segregation: ÙˆØ§Ø¬Ù‡Ø§Øª ØµØºÙŠØ±Ø© ÙˆÙ…ØªØ®ØµØµØ© Ù„ÙƒÙ„ ÙˆØ­Ø¯Ø©


ğŸ¯ Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ù„Ù„Ù†Ø¸Ø§Ù…
1. Ø·Ø¨Ù‚Ø© Ø§Ù„Ù†Ù…Ø§Ø°Ø¬ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© (Core Models Layer)
typescript// core/models/base-entities.ts

/**
 * Ø§Ù„ÙƒÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ø§Ù„Ù…Ø´ØªØ±ÙƒØ© Ø¹Ø¨Ø± Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø­Ø·Ø§Øª
 */

// ØªÙ…Ø«ÙŠÙ„ Ø§Ù„Ø´Ø®ØµÙŠØ©
interface Character {
  id: string;
  name: string;
  description: string;
  profile: {
    personalityTraits: string;
    motivationsGoals: string;
    potentialArc: string;
  };
  metadata: Record<string, any>;
}

// ØªÙ…Ø«ÙŠÙ„ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø©
enum RelationshipType {
  LOVE = 'LOVE',
  RIVALRY = 'RIVALRY',
  ALLIANCE = 'ALLIANCE',
  FAMILY = 'FAMILY',
  MENTORSHIP = 'MENTORSHIP',
  ENMITY = 'ENMITY',
  OTHER = 'OTHER'
}

enum RelationshipNature {
  POSITIVE = 'POSITIVE',
  NEGATIVE = 'NEGATIVE',
  NEUTRAL = 'NEUTRAL',
  AMBIVALENT = 'AMBIVALENT',
  OTHER = 'OTHER'
}

enum RelationshipDirection {
  DIRECTED = 'DIRECTED',
  BIDIRECTIONAL = 'BIDIRECTIONAL'
}

interface Relationship {
  id: string;
  source: string; // Character ID
  target: string; // Character ID
  type: RelationshipType;
  nature: RelationshipNature;
  direction: RelationshipDirection;
  strength: number; // 1-10
  description: string;
  triggers: string[];
  metadata: Record<string, any>;
}

// ØªÙ…Ø«ÙŠÙ„ Ø§Ù„ØµØ±Ø§Ø¹
enum ConflictSubject {
  VALUE = 'VALUE',
  MATERIAL = 'MATERIAL',
  POWER = 'POWER',
  PSYCHOLOGICAL = 'PSYCHOLOGICAL',
  RELATIONSHIP = 'RELATIONSHIP',
  INFORMATIONAL = 'INFORMATIONAL',
  SURVIVAL = 'SURVIVAL',
  OTHER = 'OTHER'
}

enum ConflictScope {
  INTERNAL = 'INTERNAL',
  PERSONAL = 'PERSONAL',
  GROUP = 'GROUP',
  SOCIETAL = 'SOCIETAL',
  UNIVERSAL = 'UNIVERSAL'
}

enum ConflictPhase {
  LATENT = 'LATENT',
  EMERGING = 'EMERGING',
  ESCALATING = 'ESCALATING',
  STALEMATE = 'STALEMATE',
  CLIMAX = 'CLIMAX',
  DEESCALATING = 'DEESCALATING',
  RESOLUTION = 'RESOLUTION',
  AFTERMATH = 'AFTERMATH',
  OTHER = 'OTHER'
}

interface Conflict {
  id: string;
  name: string;
  description: string;
  involvedCharacters: string[]; // Character IDs
  subject: ConflictSubject;
  scope: ConflictScope;
  phase: ConflictPhase;
  strength: number; // 1-10
  relatedRelationships: string[]; // Relationship IDs
  pivotPoints: string[];
  timestamps: Date[];
  metadata: Record<string, any>;
}

// Ø´Ø¨ÙƒØ© Ø§Ù„ØµØ±Ø§Ø¹
interface ConflictNetwork {
  id: string;
  name: string;
  characters: Map<string, Character>;
  relationships: Map<string, Relationship>;
  conflicts: Map<string, Conflict>;
  snapshots: NetworkSnapshot[];
  metadata: Record<string, any>;
  
  // Methods
  addCharacter(character: Character): void;
  addRelationship(relationship: Relationship): void;
  addConflict(conflict: Conflict): void;
  createSnapshot(description: string): void;
}

interface NetworkSnapshot {
  timestamp: Date;
  description: string;
  networkState: Partial<ConflictNetwork>;
}

2. Ø·Ø¨Ù‚Ø© Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ (AI Services Layer)
typescript// services/ai/gemini-service.ts

/**
 * Ø®Ø¯Ù…Ø© Ù…ÙˆØ­Ø¯Ø© Ù„Ù„ØªÙØ§Ø¹Ù„ Ù…Ø¹ Ù†Ù…Ø§Ø°Ø¬ Gemini 2.5
 * âœ… Ø§Ù„Ø§Ù„ØªØ²Ø§Ù… Ø§Ù„ØµØ§Ø±Ù… Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… gemini-2.5-pro Ùˆ gemini-2.5-flash ÙÙ‚Ø·
 */

enum GeminiModel {
  PRO = 'gemini-2.5-pro',
  FLASH = 'gemini-2.5-flash'
}

interface GeminiConfig {
  apiKey: string;
  defaultModel: GeminiModel;
  maxRetries: number;
  timeout: number;
  fallbackModel?: GeminiModel;
}

interface GeminiRequest {
  prompt: string;
  model: GeminiModel;
  context?: string;
  systemInstruction?: string;
  temperature?: number;
  maxTokens?: number;
}

interface GeminiResponse<T = any> {
  model: GeminiModel;
  content: T;
  usage: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
  metadata: {
    timestamp: Date;
    latency: number;
  };
}

class GeminiService {
  private config: GeminiConfig;
  
  constructor(config: GeminiConfig) {
    this.config = config;
    this.validateModels();
  }
  
  /**
   * Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù†Ù…Ø§Ø°Ø¬ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© ÙÙ‚Ø·
   */
  private validateModels(): void {
    const allowedModels = [GeminiModel.PRO, GeminiModel.FLASH];
    if (!allowedModels.includes(this.config.defaultModel)) {
      throw new Error(
        `Invalid model: ${this.config.defaultModel}. ` +
        `Only ${allowedModels.join(', ')} are allowed.`
      );
    }
  }
  
  /**
   * Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨ Ø¥Ù„Ù‰ Gemini Ù…Ø¹ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
   */
  async generate<T>(request: GeminiRequest): Promise<GeminiResponse<T>> {
    this.validateModels(); // ØªØ£ÙƒÙŠØ¯ Ø¥Ø¶Ø§ÙÙŠ
    
    try {
      const startTime = Date.now();
      
      // Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ API Ø§Ù„ÙØ¹Ù„ÙŠ
      const response = await this.callGeminiAPI(request);
      
      return {
        model: request.model,
        content: this.parseResponse<T>(response),
        usage: this.extractUsage(response),
        metadata: {
          timestamp: new Date(),
          latency: Date.now() - startTime
        }
      };
    } catch (error) {
      return this.handleError(error, request);
    }
  }
  
  /**
   * Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ù…ØªØ¹Ø¯Ø¯ Ù„Ù„Ù†Ù…Ø§Ø°Ø¬ Ù…Ø¹ Ù†Ø¸Ø§Ù… Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ§Øª
   */
  async generateMultiModel<T>(
    request: GeminiRequest,
    models: GeminiModel[] = [GeminiModel.PRO, GeminiModel.FLASH]
  ): Promise<Map<GeminiModel, GeminiResponse<T>>> {
    const results = new Map<GeminiModel, GeminiResponse<T>>();
    
    for (const model of models) {
      try {
        const response = await this.generate<T>({
          ...request,
          model
        });
        results.set(model, response);
      } catch (error) {
        console.error(`Model ${model} failed:`, error);
      }
    }
    
    return results;
  }
  
  private async callGeminiAPI(request: GeminiRequest): Promise<any> {
    // Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙØ¹Ù„ÙŠ Ù„Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Google AI API
    // Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… @google/generative-ai
  }
  
  private parseResponse<T>(response: any): T {
    // Ø§Ø³ØªØ®Ø±Ø§Ø¬ ÙˆØªØ­Ù„ÙŠÙ„ JSON Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø©
  }
  
  private extractUsage(response: any) {
    // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…
  }
  
  private async handleError(
    error: any,
    request: GeminiRequest
  ): Promise<GeminiResponse<any>> {
    // Ù…Ù†Ø·Ù‚ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© ÙˆØ§Ù„ØªØ±Ø§Ø¬Ø¹
  }
}

3. Ø·Ø¨Ù‚Ø© Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù†ØªØ§Ø¦Ø¬ (Result Selection Layer)
typescript// services/ai/result-selector.ts

/**
 * Ù†Ø¸Ø§Ù… Ø°ÙƒÙŠ Ù„Ø§Ø®ØªÙŠØ§Ø± Ø£ÙØ¶Ù„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ù…Ù† Ø§Ø³ØªØ¯Ø¹Ø§Ø¡Ø§Øª Ù…ØªØ¹Ø¯Ø¯Ø© Ù„Ù„Ù†Ù…Ø§Ø°Ø¬
 */

interface SelectionCriteria {
  preferredModels: GeminiModel[];
  validationFunction?: (result: any) => boolean;
  scoreFunction?: (result: any) => number;
}

class AIResultSelector {
  /**
   * Ø§Ø®ØªÙŠØ§Ø± Ø£ÙØ¶Ù„ Ù†ØªÙŠØ¬Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ§Øª ÙˆØ§Ù„Ù…Ø¹Ø§ÙŠÙŠØ±
   */
  selectBest<T>(
    results: Map<GeminiModel, GeminiResponse<T>>,
    criteria: SelectionCriteria
  ): GeminiResponse<T> | null {
    // 1. ÙÙ„ØªØ±Ø© Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„ØµØ§Ù„Ø­Ø©
    const validResults = this.filterValid(results, criteria);
    
    if (validResults.size === 0) {
      return null;
    }
    
    // 2. Ø§Ø®ØªÙŠØ§Ø± Ù…Ù† Ø§Ù„Ù†Ù…Ø§Ø°Ø¬ Ø§Ù„Ù…ÙØ¶Ù„Ø© Ø£ÙˆÙ„Ø§Ù‹
    for (const model of criteria.preferredModels) {
      if (validResults.has(model)) {
        return validResults.get(model)!;
      }
    }
    
    // 3. Ø§Ø®ØªÙŠØ§Ø± Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…
    if (criteria.scoreFunction) {
      return this.selectByScore(validResults, criteria.scoreFunction);
    }
    
    // 4. Ø¥Ø±Ø¬Ø§Ø¹ Ø£ÙˆÙ„ Ù†ØªÙŠØ¬Ø© ØµØ§Ù„Ø­Ø©
    return Array.from(validResults.values())[0];
  }
  
  private filterValid<T>(
    results: Map<GeminiModel, GeminiResponse<T>>,
    criteria: SelectionCriteria
  ): Map<GeminiModel, GeminiResponse<T>> {
    const filtered = new Map<GeminiModel, GeminiResponse<T>>();
    
    for (const [model, response] of results) {
      if (!criteria.validationFunction || 
          criteria.validationFunction(response.content)) {
        filtered.set(model, response);
      }
    }
    
    return filtered;
  }
  
  private selectByScore<T>(
    results: Map<GeminiModel, GeminiResponse<T>>,
    scoreFunction: (result: any) => number
  ): GeminiResponse<T> {
    let bestScore = -Infinity;
    let bestResult: GeminiResponse<T> | null = null;
    
    for (const response of results.values()) {
      const score = scoreFunction(response.content);
      if (score > bestScore) {
        bestScore = score;
        bestResult = response;
      }
    }
    
    return bestResult!;
  }
}

ğŸš‚ ØªØµÙ…ÙŠÙ… Ø§Ù„Ù…Ø­Ø·Ø§Øª Ø§Ù„Ø³Ø¨Ø¹
Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ù„Ù„Ù…Ø­Ø·Ø©
typescript// core/pipeline/base-station.ts

/**
 * Ø§Ù„ÙØ¦Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ø§Ù„Ù…Ø¬Ø±Ø¯Ø© Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø­Ø·Ø§Øª
 */

interface StationConfig {
  stationNumber: number;
  stationName: string;
  inputValidation: (input: any) => boolean;
  outputValidation: (output: any) => boolean;
  cacheEnabled: boolean;
  performanceTracking: boolean;
}

interface StationMetadata {
  executionTime: number;
  timestamp: Date;
  modelUsed: GeminiModel;
  cacheHit: boolean;
  errorOccurred: boolean;
  errorDetails?: string;
}

abstract class BaseStation<TInput, TOutput> {
  protected config: StationConfig;
  protected geminiService: GeminiService;
  protected resultSelector: AIResultSelector;
  protected cache: Map<string, TOutput>;
  
  constructor(
    config: StationConfig,
    geminiService: GeminiService,
    resultSelector: AIResultSelector
  ) {
    this.config = config;
    this.geminiService = geminiService;
    this.resultSelector = resultSelector;
    this.cache = new Map();
  }
  
  /**
   * Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù„ØªÙ†ÙÙŠØ° Ø§Ù„Ù…Ø­Ø·Ø©
   */
  async execute(input: TInput): Promise<{
    output: TOutput;
    metadata: StationMetadata;
  }> {
    const startTime = Date.now();
    
    try {
      // 1. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª
      this.validateInput(input);
      
      // 2. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù…Ø¤Ù‚ØªØ©
      const cachedResult = this.checkCache(input);
      if (cachedResult) {
        return {
          output: cachedResult,
          metadata: this.createMetadata(startTime, true)
        };
      }
      
      // 3. ØªÙ†ÙÙŠØ° Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ÙØ¹Ù„ÙŠØ©
      const output = await this.process(input);
      
      // 4. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ù…Ø®Ø±Ø¬Ø§Øª
      this.validateOutput(output);
      
      // 5. Ø­ÙØ¸ ÙÙŠ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù…Ø¤Ù‚ØªØ©
      this.saveToCache(input, output);
      
      return {
        output,
        metadata: this.createMetadata(startTime, false)
      };
      
    } catch (error) {
      return this.handleError(error, startTime);
    }
  }
  
  /**
   * Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ÙØ¹Ù„ÙŠØ© - ÙŠØ¬Ø¨ ØªÙ†ÙÙŠØ°Ù‡Ø§ ÙÙŠ ÙƒÙ„ Ù…Ø­Ø·Ø©
   */
  protected abstract process(input: TInput): Promise<TOutput>;
  
  /**
   * Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù…Ù† Ø§Ù„Ù…Ø­Ø·Ø§Øª Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©
   */
  protected abstract extractRequiredData(input: TInput): any;
  
  protected validateInput(input: TInput): void {
    if (!this.config.inputValidation(input)) {
      throw new Error(
        `Invalid input for ${this.config.stationName}`
      );
    }
  }
  
  protected validateOutput(output: TOutput): void {
    if (!this.config.outputValidation(output)) {
      throw new Error(
        `Invalid output from ${this.config.stationName}`
      );
    }
  }
  
  protected checkCache(input: TInput): TOutput | null {
    if (!this.config.cacheEnabled) return null;
    
    const cacheKey = this.generateCacheKey(input);
    return this.cache.get(cacheKey) || null;
  }
  
  protected saveToCache(input: TInput, output: TOutput): void {
    if (!this.config.cacheEnabled) return;
    
    const cacheKey = this.generateCacheKey(input);
    this.cache.set(cacheKey, output);
  }
  
  protected generateCacheKey(input: TInput): string {
    return JSON.stringify(input);
  }
  
  protected createMetadata(
    startTime: number,
    cacheHit: boolean
  ): StationMetadata {
    return {
      executionTime: Date.now() - startTime,
      timestamp: new Date(),
      modelUsed: GeminiModel.PRO, // Ø³ÙŠØªÙ… ØªØ­Ø¯ÙŠØ«Ù‡ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
      cacheHit,
      errorOccurred: false
    };
  }
  
  protected handleError(error: any, startTime: number): any {
    console.error(
      `Error in ${this.config.stationName}:`,
      error
    );
    
    return {
      output: this.getErrorFallback(),
      metadata: {
        ...this.createMetadata(startTime, false),
        errorOccurred: true,
        errorDetails: error.message
      }
    };
  }
  
  protected abstract getErrorFallback(): TOutput;
}

Ø§Ù„Ù…Ø­Ø·Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰: ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù†Øµ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
typescript// stations/station1/station1-text-analysis.ts

interface Station1Input {
  fullText: string;
  projectName: string;
  proseFilePath: string;
}

interface Station1Output {
  majorCharacters: string[];
  characterAnalysis: Map<string, CharacterAnalysisResult>;
  relationshipAnalysis: RelationshipAnalysisResult;
  narrativeStyleAnalysis: NarrativeStyleResult;
  metadata: {
    analysisTimestamp: Date;
    status: 'Success' | 'Partial' | 'Failed';
  };
}

interface CharacterAnalysisResult {
  personalityTraits: string;
  motivationsGoals: string;
  keyRelationshipsBrief: string;
  narrativeFunction: string;
  potentialArcObservation: string;
}

interface RelationshipAnalysisResult {
  keyRelationships: Array<{
    characters: [string, string];
    dynamic: string;
    narrativeImportance: string;
  }>;
}

interface NarrativeStyleResult {
  overallTone: string;
  pacingAnalysis: string;
  languageStyle: string;
}

class Station1TextAnalysis extends BaseStation<Station1Input, Station1Output> {
  
  protected async process(input: Station1Input): Promise<Station1Output> {
    // ØªÙ†ÙÙŠØ° Ù…ØªÙˆØ§Ø²ÙŠ Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª
    const [
      majorCharacters,
      relationshipAnalysis,
      narrativeStyle
    ] = await Promise.all([
      this.identifyMajorCharacters(input.fullText),
      this.analyzeRelationships(input.fullText),
      this.analyzeNarrativeStyle(input.fullText)
    ]);
    
    // ØªØ­Ù„ÙŠÙ„ Ù…Ø¹Ù…Ù‚ Ù„Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
    const characterAnalysis = await this.analyzeCharactersInDepth(
      input.fullText,
      majorCharacters
    );
    
    return {
      majorCharacters,
      characterAnalysis,
      relationshipAnalysis,
      narrativeStyleAnalysis: narrativeStyle,
      metadata: {
        analysisTimestamp: new Date(),
        status: 'Success'
      }
    };
  }
  
  /**
   * ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© (3-7 Ø´Ø®ØµÙŠØ§Øª)
   */
  private async identifyMajorCharacters(
    fullText: string
  ): Promise<string[]> {
    const prompt = `
Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù†Øµ Ø§Ù„Ø³Ø±Ø¯ÙŠ Ø§Ù„ÙƒØ§Ù…Ù„ Ø§Ù„Ù…Ø±ÙÙ‚ØŒ Ù‚Ù… Ø¨ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù†Øµ ÙˆØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„ØªÙŠ ØªØ¨Ø¯Ùˆ **Ø§Ù„Ø£ÙƒØ«Ø± Ù…Ø±ÙƒØ²ÙŠØ© ÙˆØ£Ù‡Ù…ÙŠØ©** Ù„Ù„Ø­Ø¨ÙƒØ© ÙˆØªØ·ÙˆØ± Ø§Ù„Ø£Ø­Ø¯Ø§Ø«. 
Ø±ÙƒØ² Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„ØªÙŠ Ù„Ù‡Ø§ Ø£Ø¯ÙˆØ§Ø± ÙØ§Ø¹Ù„Ø©ØŒ Ø¯ÙˆØ§ÙØ¹ ÙˆØ§Ø¶Ø­Ø©ØŒ ÙˆØªØ¸Ù‡Ø± Ø¨Ø´ÙƒÙ„ Ù…ØªÙƒØ±Ø± ÙˆÙ…Ø¤Ø«Ø±.
Ø£Ø¹Ø¯ Ù‚Ø§Ø¦Ù…Ø© ØªØªØ¶Ù…Ù† **Ù…Ø§ Ø¨ÙŠÙ† 3 Ø¥Ù„Ù‰ 7 Ø´Ø®ØµÙŠØ§Øª** ØªØ¹ØªØ¨Ø±Ù‡Ø§ Ø§Ù„Ø£ÙƒØ«Ø± Ø£Ù‡Ù…ÙŠØ©.

Ø£Ø¹Ø¯ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© **Ø­ØµØ±ÙŠØ§Ù‹** Ø¨ØªÙ†Ø³ÙŠÙ‚ JSON ØµØ§Ù„Ø­:
{
  "major_characters": ["Ø§Ø³Ù… Ø§Ù„Ø´Ø®ØµÙŠØ© 1", "Ø§Ø³Ù… Ø§Ù„Ø´Ø®ØµÙŠØ© 2", ...]
}
    `;
    
    const results = await this.geminiService.generateMultiModel<{
      major_characters: string[];
    }>({
      prompt,
      context: fullText.substring(0, 30000),
      model: GeminiModel.PRO
    }, [GeminiModel.PRO, GeminiModel.FLASH]);
    
    const selected = this.resultSelector.selectBest(results, {
      preferredModels: [GeminiModel.PRO, GeminiModel.FLASH],
      validationFunction: (result) => 
        Array.isArray(result.major_characters) && 
        result.major_characters.length >= 3 &&
        result.major_characters.length <= 7
    });
    
    return selected?.content.major_characters || [];
  }
  
  /**
   * ØªØ­Ù„ÙŠÙ„ Ù…Ø¹Ù…Ù‚ Ù„ÙƒÙ„ Ø´Ø®ØµÙŠØ© Ø±Ø¦ÙŠØ³ÙŠØ©
   */
  private async analyzeCharactersInDepth(
    fullText: string,
    characterNames: string[]
  ): Promise<Map<string, CharacterAnalysisResult>> {
    const analyses = new Map<string, CharacterAnalysisResult>();
    
    // ØªØ­Ù„ÙŠÙ„ Ù…ØªÙˆØ§Ø²ÙŠ Ù„Ù„Ø´Ø®ØµÙŠØ§Øª
    const analysisPromises = characterNames.map(name =>
      this.analyzeCharacter(fullText, name)
    );
    
    const results = await Promise.all(analysisPromises);
    
    characterNames.forEach((name, index) => {
      analyses.set(name, results[index]);
    });
    
    return analyses;
  }
  
  private async analyzeCharacter(
    fullText: string,
    characterName: string
  ): Promise<CharacterAnalysisResult> {
    const prompt = `
Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù†Øµ Ø§Ù„Ø³Ø±Ø¯ÙŠ Ø§Ù„ÙƒØ§Ù…Ù„ Ø§Ù„Ù…Ø±ÙÙ‚ØŒ Ù‚Ù… Ø¨Ø¥Ø¬Ø±Ø§Ø¡ ØªØ­Ù„ÙŠÙ„ **Ø´Ø§Ù…Ù„ ÙˆÙ…Ø¹Ù…Ù‚** Ù„Ù„Ø´Ø®ØµÙŠØ© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø© Ø§Ù„ØªØ§Ù„ÙŠØ©: **${characterName}**.

Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¬ÙˆØ§Ù†Ø¨ Ø§Ù„ØªØ§Ù„ÙŠØ© Ù„Ù‡Ø°Ù‡ Ø§Ù„Ø´Ø®ØµÙŠØ©:
1. Ø§Ù„Ø³Ù…Ø§Øª Ø§Ù„Ø´Ø®ØµÙŠØ© Ø§Ù„Ø¨Ø§Ø±Ø²Ø© (Ø¥ÙŠØ¬Ø§Ø¨ÙŠØ© ÙˆØ³Ù„Ø¨ÙŠØ©)
2. Ø§Ù„Ø¯ÙˆØ§ÙØ¹ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ÙˆØ§Ù„Ø£Ù‡Ø¯Ø§Ù (Ø§Ù„Ø¸Ø§Ù‡Ø±Ø© ÙˆØ§Ù„Ø®ÙÙŠØ©)
3. ÙˆØµÙ Ù…ÙˆØ¬Ø² Ù„Ø£Ù‡Ù… Ø¹Ù„Ø§Ù‚Ø§ØªÙ‡Ø§ Ù…Ø¹ Ø´Ø®ØµÙŠØ§Øª Ø£Ø®Ø±Ù‰
4. Ø§Ù„Ø¯ÙˆØ± Ø£Ùˆ Ø§Ù„ÙˆØ¸ÙŠÙØ© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© ÙÙŠ Ø§Ù„Ù‚ØµØ©
5. Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø£ÙˆÙ„ÙŠØ© Ø­ÙˆÙ„ Ù‚ÙˆØ³ Ø§Ù„ØªØ·ÙˆØ± Ø§Ù„Ù…Ø­ØªÙ…Ù„

Ø£Ø¹Ø¯ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© **Ø­ØµØ±ÙŠØ§Ù‹** Ø¨ØªÙ†Ø³ÙŠÙ‚ JSON ØµØ§Ù„Ø­:
{
  "personality_traits": "...",
  "motivations_goals": "...",
  "key_relationships_brief": "...",
  "narrative_function": "...",
  "potential_arc_observation": "..."
}
    `;
    
    const results = await this.geminiService.generateMultiModel({
      prompt,
      context: fullText.substring(0, 30000),
      model: GeminiModel.PRO
    });
    
    const selected = this.resultSelector.selectBest(results, {
      preferredModels: [GeminiModel.PRO, GeminiModel.FLASH],
      validationFunction: (result) => 
        result.personality_traits &&
        result.motivations_goals &&
        result.narrative_function
    });
    
    const content = selected?.content || {};
    
    return {
      personalityTraits: content.personality_traits || 'N/A',
      motivationsGoals: content.motivations_goals || 'N/A',
      keyRelationshipsBrief: content.key_relationships_brief || 'N/A',
      narrativeFunction: content.narrative_function || 'N/A',
      potentialArcObservation: content.potential_arc_observation || 'N/A'
    };
  }
  
  private async analyzeRelationships(
    fullText: string
  ): Promise<RelationshipAnalysisResult> {
    // ØªØ·Ø¨ÙŠÙ‚ Ù…Ø´Ø§Ø¨Ù‡ Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
    // ...
  }
  
  private async analyzeNarrativeStyle(
    fullText: string
  ): Promise<NarrativeStyleResult> {
    // ØªØ·Ø¨ÙŠÙ‚ Ù…Ø´Ø§Ø¨Ù‡ Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ø³Ù„ÙˆØ¨ Ø§Ù„Ø³Ø±Ø¯ÙŠ
    // ...
  }
  
  protected extractRequiredData(input: Station1Input): any {
    return { fullText: input.fullText };
  }
  
  protected getErrorFallback(): Station1Output {
    return {
      majorCharacters: [],
      characterAnalysis: new Map(),
      relationshipAnalysis: { keyRelationships: [] },
      narrativeStyleAnalysis: {
        overallTone: 'Error',
        pacingAnalysis: 'Error',
        languageStyle: 'Error'
      },
      metadata: {
        analysisTimestamp: new Date(),
        status: 'Failed'
      }
    };
  }
}

Ø§Ù„Ù…Ø­Ø·Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©: Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…ÙØ§Ù‡ÙŠÙ…ÙŠ
typescript// stations/station2/station2-conceptual-analysis.ts

interface Station2Input {
  station1Output: Station1Output;
  fullText: string;
}

interface Station2Output {
  storyStatement: string;
  threeDMap: ThreeDMapResult;
  elevatorPitch: string;
  hybridGenre: string;
  genreContributionMatrix: GenreMatrixResult;
  dynamicTone: DynamicToneResult;
  artisticReferences: ArtisticReferencesResult;
  metadata: {
    analysisTimestamp: Date;
    status: 'Success' | 'Partial' | 'Failed';
  };
}

interface ThreeDMapResult {
  horizontalEventsAxis: Array<{
    event: string;
    sceneRef: string;
  }>;
  verticalMeaningAxis: Array<{
    eventRef: string;
    symbolicLayer: string;
  }>;
  temporalDevelopmentAxis: {
    pastInfluence: string;
    presentChoices: string;
    futureExpectations: string;
    heroArcConnection: string;
  };
}

interface GenreMatrixResult {
  [genreName: string]: {
    conflictContribution: string;
    pacingContribution: string;
    visualCompositionContribution: string;
    soundMusicContribution: string;
    charactersContribution: string;
  };
}

interface DynamicToneResult {
  [stageName: string]: {
    visualAtmosphereDescribed: string;
    writtenPacing: string;
    dialogueStructure: string;
    soundIndicationsDescribed: string;
  };
}

interface ArtisticReferencesResult {
  visualReferences: Array<{
    work: string;
    reason: string;
  }>;
  musicalMood: string;
}

class Station2ConceptualAnalysis extends BaseStation<Station2Input, Station2Output> {
  
  protected async process(input: Station2Input): Promise<Station2Output> {
    // Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø³ÙŠØ§Ù‚ Ù…Ù† Ø§Ù„Ù…Ø­Ø·Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰
    const context = this.buildContextFromStation1(input.station1Output);
    
    // 1. ØªÙˆÙ„ÙŠØ¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‚ØµØ©
    const storyStatements = await this.generateStoryStatements(
      context,
      input.fullText
    );
    const storyStatement = storyStatements[0]; // Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø£ÙˆÙ„
    
    // 2. Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø®Ø±ÙŠØ·Ø© Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯
    const threeDMap = await this.generate3DMap(
      context,
      storyStatement,
      input.fullText
    );
    
    // 3. ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø®ØªØµØ±
    const elevatorPitch = await this.generateElevatorPitch(
      storyStatement
    );
    
    // 4. ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù†ÙˆØ¹ Ø§Ù„Ù‡Ø¬ÙŠÙ†
    const hybridGenreOptions = await this.generateHybridGenre(
      context,
      storyStatement,
      input.fullText
    );
    const hybridGenre = hybridGenreOptions[0];
    
    // 5. Ø¨Ù†Ø§Ø¡ Ù…ØµÙÙˆÙØ© Ù…Ø³Ø§Ù‡Ù…Ø© Ø§Ù„Ù†ÙˆØ¹
    const genreMatrix = await this.generateGenreMatrix(
      hybridGenre,
      context,
      input.fullText
    );
    
    // 6. ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù†ØºÙ…Ø© Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©
    const dynamicTone = await this.generateDynamicTone(
      hybridGenre,
      context,
      input.fullText
    );
    
    // 7. Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹ Ø§Ù„ÙÙ†ÙŠØ©
    const artisticReferences = await this.generateArtisticReferences(
      hybridGenre,
      context,
      input.fullText
    );
    
    return {
      storyStatement,
      threeDMap,
      elevatorPitch,
      hybridGenre,
      genreContributionMatrix: genreMatrix,
      dynamicTone,
      artisticReferences,
      metadata: {
        analysisTimestamp: new Date(),
        status: 'Success'
      }
    };
  }
  
  private buildContextFromStation1(s1Output: Station1Output): any {
    return {
      majorCharacters: s1Output.majorCharacters,
      characterProfiles: Array.from(
        s1Output.characterAnalysis.entries()
      ).map(([name, analysis]) => ({
        name,
        traits: analysis.personalityTraits,
        motivations: analysis.motivationsGoals
      })),
      keyRelationships: s1Output.relationshipAnalysis.keyRelationships,
      narrativeStyle: s1Output.narrativeStyleAnalysis
    };
  }RetryAContinueEdittypescript  /**
   * ØªÙˆÙ„ÙŠØ¯ 3 Ø¨Ø¯Ø§Ø¦Ù„ Ù„Ø¨ÙŠØ§Ù† Ø§Ù„Ù‚ØµØ©
   */
  private async generateStoryStatements(
    context: any,
    fullText: string
  ): Promise<string[]> {
    const prompt = `
Ø¨ØµÙØªÙƒ Ù…Ø³Ø§Ø¹Ø¯ ÙƒØªØ§Ø¨Ø© Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆ Ø®Ø¨ÙŠØ±ØŒ ÙˆÙ…Ø³ØªÙ†Ø¯Ù‹Ø§ Ø¥Ù„Ù‰ Ù…Ù„Ø®Øµ Ø§Ù„Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆ Ø§Ù„Ø£ÙˆÙ„ÙŠ ÙˆØ§Ù„Ù†Øµ Ø§Ù„ÙƒØ§Ù…Ù„ Ø§Ù„Ù…Ø±ÙÙ‚ÙŠÙ†ØŒ 
Ø§Ù‚ØªØ±Ø­ **Ø«Ù„Ø§Ø«Ø© (3)** Ø¨Ø¯Ø§Ø¦Ù„ Ù…ØªÙ…ÙŠØ²Ø© Ù„Ù€ "Ø¨ÙŠØ§Ù† Ø§Ù„Ù‚ØµØ©" (Story Statement).

ÙƒÙ„ Ø¨ÙŠØ§Ù† ÙŠØ¬Ø¨ Ø£Ù† ÙŠØªÙƒÙˆÙ† Ù…Ù† **Ø£Ø±Ø¨Ø¹ Ø¬Ù…Ù„**ØŒ ØªØºØ·ÙŠ:
1. Ø§Ù„Ø­Ø¯Ø« Ø§Ù„Ù…Ø­ÙˆØ±ÙŠ Ø§Ù„Ø¬Ø§Ù…Ø¹ Ø£Ùˆ Ù†Ù‚Ø·Ø© Ø§Ù„Ø§Ù†Ø·Ù„Ø§Ù‚
2. Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„Ù…ØªØ´Ø§Ø¨ÙƒØ© Ø£Ùˆ Ø§Ù„Ø¯ÙˆØ§ÙØ¹ Ø§Ù„Ù…ØªÙ‚Ø§Ø·Ø¹Ø©
3. Ø§Ù„Ø¹Ø§Ù„Ù… Ø§Ù„Ù‚ØµØµÙŠ Ø§Ù„Ù…Ù…ÙŠØ² ÙˆØ§Ù„Ù…ÙˆØ­Ø¯
4. Ø§Ù„Ø«ÙŠÙ…Ø© Ø£Ùˆ Ø§Ù„Ø³Ø¤Ø§Ù„ Ø§Ù„ÙÙ„Ø³ÙÙŠ Ø§Ù„Ø¬Ø§Ù…Ø¹

Ø§Ù„Ø³ÙŠØ§Ù‚: ${JSON.stringify(context, null, 2)}

Ø£Ø¹Ø¯ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© **Ø­ØµØ±ÙŠØ§Ù‹** Ø¨ØªÙ†Ø³ÙŠÙ‚ JSON:
{
  "story_statement_alternatives": [
    "Ø¨ÙŠØ§Ù† Ø§Ù„Ù‚ØµØ© Ø§Ù„Ø£ÙˆÙ„ (4 Ø¬Ù…Ù„)...",
    "Ø¨ÙŠØ§Ù† Ø§Ù„Ù‚ØµØ© Ø§Ù„Ø«Ø§Ù†ÙŠ (4 Ø¬Ù…Ù„)...",
    "Ø¨ÙŠØ§Ù† Ø§Ù„Ù‚ØµØ© Ø§Ù„Ø«Ø§Ù„Ø« (4 Ø¬Ù…Ù„)..."
  ]
}
    `;
    
    const results = await this.geminiService.generateMultiModel<{
      story_statement_alternatives: string[];
    }>({
      prompt,
      context: fullText.substring(0, 25000),
      model: GeminiModel.PRO,
      temperature: 0.8
    });
    
    const selected = this.resultSelector.selectBest(results, {
      preferredModels: [GeminiModel.PRO, GeminiModel.FLASH],
      validationFunction: (result) => 
        Array.isArray(result.story_statement_alternatives) &&
        result.story_statement_alternatives.length === 3
    });
    
    return selected?.content.story_statement_alternatives || 
      ['ÙØ´Ù„ ØªÙˆÙ„ÙŠØ¯ Ø¨ÙŠØ§Ù† Ø§Ù„Ù‚ØµØ©'];
  }
  
  /**
   * Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø®Ø±ÙŠØ·Ø© Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯
   */
  private async generate3DMap(
    context: any,
    storyStatement: string,
    fullText: string
  ): Promise<ThreeDMapResult> {
    const prompt = `
Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù† Ø§Ù„Ù‚ØµØ© Ø§Ù„Ù…Ø¹ØªÙ…Ø¯: "${storyStatement}"
ÙˆØ§Ù„Ø³ÙŠØ§Ù‚: ${JSON.stringify(context, null, 2)}

Ù‚Ù… Ø¨Ø¥Ù†Ø´Ø§Ø¡ **"Ø®Ø±ÙŠØ·Ø© Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯" (3D Map)** Ù„Ù„Ù‚ØµØ©:

Ø£Ø¹Ø¯ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¨ØªÙ†Ø³ÙŠÙ‚ JSON:
{
  "horizontal_events_axis": [
    {"event": "Ø­Ø¯Ø« Ù…Ø®ØªØµØ±", "scene_ref": "Ø±Ù‚Ù… Ø§Ù„Ù…Ø´Ù‡Ø¯"},
    ...
  ],
  "vertical_meaning_axis": [
    {"event_ref": "ÙˆØµÙ Ø§Ù„Ø­Ø¯Ø«", "symbolic_layer": "Ø§Ù„Ø·Ø¨Ù‚Ø© Ø§Ù„Ø±Ù…Ø²ÙŠØ©"},
    ...
  ],
  "temporal_development_axis": {
    "past_influence": "ØªØ£Ø«ÙŠØ± Ø§Ù„Ù…Ø§Ø¶ÙŠ...",
    "present_choices": "Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ø­Ø§Ø¶Ø±...",
    "future_expectations": "ØªÙˆÙ‚Ø¹Ø§Øª Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„...",
    "hero_arc_connection": "Ø§Ø±ØªØ¨Ø§Ø· Ø¨Ù‚ÙˆØ³ Ø§Ù„Ø¨Ø·Ù„..."
  }
}
    `;
    
    const results = await this.geminiService.generateMultiModel<ThreeDMapResult>({
      prompt,
      context: fullText.substring(0, 25000),
      model: GeminiModel.PRO,
      temperature: 0.7
    });
    
    const selected = this.resultSelector.selectBest(results, {
      preferredModels: [GeminiModel.PRO, GeminiModel.FLASH],
      validationFunction: (result) => 
        result.horizontal_events_axis &&
        result.vertical_meaning_axis &&
        result.temporal_development_axis
    });
    
    return selected?.content || this.getDefault3DMap();
  }
  
  private async generateElevatorPitch(
    storyStatement: string
  ): Promise<string> {
    const prompt = `
Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù† Ø§Ù„Ù‚ØµØ©: "${storyStatement}"

ØµØº "Elevator Pitch" Ø¬Ø°Ø§Ø¨ ÙˆÙ…ÙˆØ¬Ø² (Ù„Ø§ ÙŠØªØ¬Ø§ÙˆØ² 40 ÙƒÙ„Ù…Ø©).

Ø£Ø¹Ø¯ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø¨ØªÙ†Ø³ÙŠÙ‚ JSON:
{
  "elevator_pitch": "Ø§Ù„Ù†Øµ Ù‡Ù†Ø§..."
}
    `;
    
    const results = await this.geminiService.generateMultiModel<{
      elevator_pitch: string;
    }>({
      prompt,
      model: GeminiModel.FLASH, // Ø§Ø³ØªØ®Ø¯Ø§Ù… FLASH Ù„Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ø£Ø¨Ø³Ø·
      temperature: 0.9
    });
    
    const selected = this.resultSelector.selectBest(results, {
      preferredModels: [GeminiModel.FLASH, GeminiModel.PRO],
      validationFunction: (result) => 
        result.elevator_pitch &&
        result.elevator_pitch.split(' ').length <= 45
    });
    
    return selected?.content.elevator_pitch || 
      'ÙØ´Ù„ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø®ØªØµØ±';
  }
  
  private async generateHybridGenre(
    context: any,
    storyStatement: string,
    fullText: string
  ): Promise<string[]> {
    const prompt = `
Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø³ÙŠØ§Ù‚ ÙˆØ§Ù„Ù†Øµ Ø§Ù„ÙƒØ§Ù…Ù„ØŒ Ø§Ù‚ØªØ±Ø­ **Ù…Ø§ Ø¨ÙŠÙ† 3 Ø¥Ù„Ù‰ 5 Ø¨Ø¯Ø§Ø¦Ù„** 
Ù„ØªØ±ÙƒÙŠØ¨Ø© **"Ù†ÙˆØ¹ Ù‡Ø¬ÙŠÙ†" (Hybrid Genre)** Ø¯Ù‚ÙŠÙ‚Ø© ÙˆÙ…Ù†Ø§Ø³Ø¨Ø©.

Ø§Ù„Ø³ÙŠØ§Ù‚: ${JSON.stringify(context, null, 2)}
Ø¨ÙŠØ§Ù† Ø§Ù„Ù‚ØµØ©: ${storyStatement}

Ø£Ø¹Ø¯ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø¨ØªÙ†Ø³ÙŠÙ‚ JSON:
{
  "hybrid_genre_alternatives": [
    "Ø§Ù„Ù†ÙˆØ¹ Ø§Ù„Ù‡Ø¬ÙŠÙ† Ø§Ù„Ø£ÙˆÙ„ Ù…Ø¹ Ø§Ù„Ø´Ø±Ø­...",
    "Ø§Ù„Ù†ÙˆØ¹ Ø§Ù„Ù‡Ø¬ÙŠÙ† Ø§Ù„Ø«Ø§Ù†ÙŠ Ù…Ø¹ Ø§Ù„Ø´Ø±Ø­...",
    ...
  ]
}
    `;
    
    const results = await this.geminiService.generateMultiModel<{
      hybrid_genre_alternatives: string[];
    }>({
      prompt,
      context: fullText.substring(0, 20000),
      model: GeminiModel.PRO,
      temperature: 0.8
    });
    
    const selected = this.resultSelector.selectBest(results, {
      preferredModels: [GeminiModel.PRO, GeminiModel.FLASH],
      validationFunction: (result) => 
        Array.isArray(result.hybrid_genre_alternatives) &&
        result.hybrid_genre_alternatives.length >= 3 &&
        result.hybrid_genre_alternatives.length <= 5
    });
    
    return selected?.content.hybrid_genre_alternatives || 
      ['Drama-Thriller'];
  }
  
  private async generateGenreMatrix(
    hybridGenre: string,
    context: any,
    fullText: string
  ): Promise<GenreMatrixResult> {
    const prompt = `
Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù†ÙˆØ¹ Ø§Ù„Ù‡Ø¬ÙŠÙ† Ø§Ù„Ù…Ø¹ØªÙ…Ø¯: "${hybridGenre}"

Ø£Ù†Ø´Ø¦ **"Ù…ØµÙÙˆÙØ© Ù…Ø³Ø§Ù‡Ù…Ø© Ø§Ù„Ù†ÙˆØ¹"** ØªÙˆØ¶Ø­ ÙƒÙŠÙ ÙŠÙØ«Ø±ÙŠ ÙƒÙ„ Ù†ÙˆØ¹ Ø£Ø³Ø§Ø³ÙŠ:

Ø£Ø¹Ø¯ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¨ØªÙ†Ø³ÙŠÙ‚ JSON:
{
  "genre_contribution_matrix": {
    "Ø§Ù„Ù†ÙˆØ¹ Ø§Ù„Ø£ÙˆÙ„": {
      "conflict_contribution": "...",
      "pacing_contribution": "...",
      "visual_composition_contribution": "...",
      "sound_music_contribution": "...",
      "characters_contribution": "..."
    },
    ...
  }
}
    `;
    
    const results = await this.geminiService.generateMultiModel<{
      genre_contribution_matrix: GenreMatrixResult;
    }>({
      prompt,
      context: fullText.substring(0, 15000),
      model: GeminiModel.PRO,
      temperature: 0.7
    });
    
    const selected = this.resultSelector.selectBest(results, {
      preferredModels: [GeminiModel.PRO, GeminiModel.FLASH],
      validationFunction: (result) => 
        result.genre_contribution_matrix &&
        Object.keys(result.genre_contribution_matrix).length > 0
    });
    
    return selected?.content.genre_contribution_matrix || {};
  }
  
  private async generateDynamicTone(
    hybridGenre: string,
    context: any,
    fullText: string
  ): Promise<DynamicToneResult> {
    // ØªØ·Ø¨ÙŠÙ‚ Ù…Ø´Ø§Ø¨Ù‡
    // ...
  }
  
  private async generateArtisticReferences(
    hybridGenre: string,
    context: any,
    fullText: string
  ): Promise<ArtisticReferencesResult> {
    // ØªØ·Ø¨ÙŠÙ‚ Ù…Ø´Ø§Ø¨Ù‡
    // ...
  }
  
  private getDefault3DMap(): ThreeDMapResult {
    return {
      horizontalEventsAxis: [],
      verticalMeaningAxis: [],
      temporalDevelopmentAxis: {
        pastInfluence: '',
        presentChoices: '',
        futureExpectations: '',
        heroArcConnection: ''
      }
    };
  }
  
  protected extractRequiredData(input: Station2Input): any {
    return {
      station1: input.station1Output,
      fullText: input.fullText
    };
  }
  
  protected getErrorFallback(): Station2Output {
    return {
      storyStatement: 'Error',
      threeDMap: this.getDefault3DMap(),
      elevatorPitch: 'Error',
      hybridGenre: 'Error',
      genreContributionMatrix: {},
      dynamicTone: {},
      artisticReferences: {
        visualReferences: [],
        musicalMood: ''
      },
      metadata: {
        analysisTimestamp: new Date(),
        status: 'Failed'
      }
    };
  }
}

Ø§Ù„Ù…Ø­Ø·Ø© Ø§Ù„Ø«Ø§Ù„Ø«Ø©: Ø¨Ù†Ø§Ø¡ Ø´Ø¨ÙƒØ© Ø§Ù„ØµØ±Ø§Ø¹
typescript// stations/station3/station3-network-builder.ts

interface Station3Input {
  station1Output: Station1Output;
  station2Output: Station2Output;
  fullText: string;
}

interface Station3Output {
  conflictNetwork: ConflictNetwork;
  networkSummary: {
    charactersCount: number;
    relationshipsCount: number;
    conflictsCount: number;
    snapshotsCount: number;
  };
  metadata: {
    analysisTimestamp: Date;
    status: 'Success' | 'Partial' | 'Failed';
    buildTime: number;
  };
}

/**
 * Ù…Ø­Ø±Ùƒ Ø§Ø³ØªØ¯Ù„Ø§Ù„ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
 */
class RelationshipInferenceEngine {
  constructor(
    private geminiService: GeminiService,
    private resultSelector: AIResultSelector
  ) {}
  
  async inferRelationships(
    characters: Character[],
    s1RelationshipsHints: any,
    s2Context: any,
    fullText: string
  ): Promise<Relationship[]> {
    const charactersList = characters.map(c => 
      `'${c.name}' (ID: ${c.id})`
    ).join(', ');
    
    const prompt = `
Ø§Ø³ØªÙ†Ø§Ø¯Ù‹Ø§ Ø¥Ù„Ù‰ Ø§Ù„Ø³ÙŠØ§Ù‚ Ø§Ù„Ù…Ù‚Ø¯Ù…ØŒ Ù‚Ù… Ø¨Ø§Ø³ØªÙ†ØªØ§Ø¬ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ø¨ÙŠÙ† Ø§Ù„Ø´Ø®ØµÙŠØ§Øª.

Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©: ${charactersList}

Ù„ÙƒÙ„ Ø¹Ù„Ø§Ù‚Ø© Ø±Ø¦ÙŠØ³ÙŠØ©:
1. Ø­Ø¯Ø¯ Ø§Ù„Ø´Ø®ØµÙŠØªÙŠÙ† (Ø¨Ø§Ù„Ø§Ø³Ù… Ø£Ùˆ ID)
2. Ø§Ù‚ØªØ±Ø­ Ù†ÙˆØ¹ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø© (${Object.values(RelationshipType).join(', ')})
3. Ø§Ù‚ØªØ±Ø­ Ø·Ø¨ÙŠØ¹Ø© Ø§Ù„Ø¹Ù„Ø§Ù‚Ø© (${Object.values(RelationshipNature).join(', ')})
4. ÙˆØµÙ Ù…ÙˆØ¬Ø² Ù„Ù„Ø¹Ù„Ø§Ù‚Ø©
5. Ù‚ÙˆØ© Ø§Ù„Ø¹Ù„Ø§Ù‚Ø© (1-10)
6. Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø© (${Object.values(RelationshipDirection).join(', ')})
7. Ø§Ù„Ù…Ø­ÙØ²Ø§Øª Ø§Ù„Ù…Ø¤Ø«Ø±Ø©

Ø£Ø¹Ø¯ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø¨ØªÙ†Ø³ÙŠÙ‚ JSON:
{
  "inferred_relationships": [
    {
      "character1_name_or_id": "...",
      "character2_name_or_id": "...",
      "relationship_type": "...",
      "relationship_nature": "...",
      "description_rationale": "...",
      "strength": 7,
      "direction": "...",
      "triggers": ["Ù…Ø­ÙØ² 1", "Ù…Ø­ÙØ² 2"]
    },
    ...
  ]
}
    `;
    
    const results = await this.geminiService.generateMultiModel<{
      inferred_relationships: any[];
    }>({
      prompt,
      context: fullText.substring(0, 25000),
      model: GeminiModel.PRO,
      temperature: 0.7
    });
    
    const selected = this.resultSelector.selectBest(results, {
      preferredModels: [GeminiModel.PRO, GeminiModel.FLASH],
      validationFunction: (result) => 
        Array.isArray(result.inferred_relationships) &&
        result.inferred_relationships.length > 0
    });
    
    const inferredData = selected?.content.inferred_relationships || [];
    
    return this.convertToRelationships(inferredData, characters);
  }
  
  private convertToRelationships(
    inferredData: any[],
    characters: Character[]
  ): Relationship[] {
    const relationships: Relationship[] = [];
    const charNameToId = new Map(
      characters.map(c => [c.name, c.id])
    );
    
    for (const data of inferredData) {
      const sourceId = charNameToId.get(data.character1_name_or_id) || 
                      data.character1_name_or_id;
      const targetId = charNameToId.get(data.character2_name_or_id) || 
                      data.character2_name_or_id;
      
      if (!sourceId || !targetId || sourceId === targetId) {
        continue;
      }
      
      try {
        const relationship: Relationship = {
          id: `rel_${sourceId}_${targetId}_${Date.now()}`,
          source: sourceId,
          target: targetId,
          type: this.parseRelationshipType(data.relationship_type),
          nature: this.parseRelationshipNature(data.relationship_nature),
          direction: this.parseRelationshipDirection(data.direction),
          strength: parseInt(data.strength) || 5,
          description: data.description_rationale || '',
          triggers: data.triggers || [],
          metadata: {
            source: 'AI_Inference_Engine',
            inferenceTimestamp: new Date().toISOString()
          }
        };
        
        relationships.push(relationship);
      } catch (error) {
        console.error('Error parsing relationship:', error);
      }
    }
    
    return relationships;
  }
  
  private parseRelationshipType(typeStr: string): RelationshipType {
    const normalized = typeStr?.toUpperCase().replace(/[- ]/g, '_');
    return RelationshipType[normalized as keyof typeof RelationshipType] || 
           RelationshipType.OTHER;
  }
  
  private parseRelationshipNature(natureStr: string): RelationshipNature {
    const normalized = natureStr?.toUpperCase().replace(/[- ]/g, '_');
    return RelationshipNature[normalized as keyof typeof RelationshipNature] || 
           RelationshipNature.NEUTRAL;
  }
  
  private parseRelationshipDirection(dirStr: string): RelationshipDirection {
    const normalized = dirStr?.toUpperCase().replace(/[- ]/g, '_');
    return RelationshipDirection[normalized as keyof typeof RelationshipDirection] || 
           RelationshipDirection.BIDIRECTIONAL;
  }
}

/**
 * Ù…Ø­Ø±Ùƒ Ø§Ø³ØªØ¯Ù„Ø§Ù„ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
 */
class ConflictInferenceEngine {
  constructor(
    private geminiService: GeminiService,
    private resultSelector: AIResultSelector
  ) {}
  
  async inferConflicts(
    characters: Character[],
    relationships: Relationship[],
    s2Context: any,
    fullText: string
  ): Promise<Conflict[]> {
    const charactersSummary = characters.map(c => ({
      id: c.id,
      name: c.name,
      description: c.description
    }));
    
    const relationshipsSummary = relationships.slice(0, 5).map(r => {
      const source = characters.find(c => c.id === r.source);
      const target = characters.find(c => c.id === r.target);
      return {
        characters: [source?.name, target?.name],
        type: r.type,
        nature: r.nature
      };
    });
    
    const prompt = `
Ø§Ø³ØªÙ†Ø§Ø¯Ù‹Ø§ Ø¥Ù„Ù‰ Ø§Ù„Ø³ÙŠØ§Ù‚ØŒ Ù‚Ù… Ø¨Ø§Ø³ØªÙ†ØªØ§Ø¬ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© (3-5 ØµØ±Ø§Ø¹Ø§Øª).

Ø§Ù„Ø´Ø®ØµÙŠØ§Øª: ${JSON.stringify(charactersSummary, null, 2)}
Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª: ${JSON.stringify(relationshipsSummary, null, 2)}

Ù„ÙƒÙ„ ØµØ±Ø§Ø¹:
1. Ø§Ø³Ù… Ø§Ù„ØµØ±Ø§Ø¹
2. Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ© (Ø£Ø³Ù…Ø§Ø¡ Ø£Ùˆ IDs)
3. Ù…ÙˆØ¶ÙˆØ¹ Ø§Ù„ØµØ±Ø§Ø¹ (${Object.values(ConflictSubject).join(', ')})
4. Ù†Ø·Ø§Ù‚ Ø§Ù„ØµØ±Ø§Ø¹ (${Object.values(ConflictScope).join(', ')})
5. Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø£ÙˆÙ„ÙŠØ© (${Object.values(ConflictPhase).join(', ')})
6. ÙˆØµÙ ÙˆØ¯Ù„ÙŠÙ„
7. Ù‚ÙˆØ© Ø§Ù„ØµØ±Ø§Ø¹ (1-10)
8. Ù†Ù‚Ø§Ø· Ø§Ù„ØªØ­ÙˆÙ„ Ø§Ù„Ù…Ø­ÙˆØ±ÙŠØ©

Ø£Ø¹Ø¯ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø¨ØªÙ†Ø³ÙŠÙ‚ JSON:
{
  "inferred_conflicts": [
    {
      "conflict_name": "...",
      "involved_character_names_or_ids": ["...", "..."],
      "subject": "...",
      "scope": "...",
      "initial_phase": "...",
      "description_rationale": "...",
      "strength": 8,
      "related_relationships": [],
      "pivot_points": ["Ù†Ù‚Ø·Ø© 1", "Ù†Ù‚Ø·Ø© 2"]
    },
    ...
  ]
}
    `;
    
    const results = await this.geminiService.generateMultiModel<{
      inferred_conflicts: any[];
    }>({
      prompt,
      context: fullText.substring(0, 25000),
      model: GeminiModel.PRO,
      temperature: 0.7
    });
    
    const selected = this.resultSelector.selectBest(results, {
      preferredModels: [GeminiModel.PRO, GeminiModel.FLASH],
      validationFunction: (result) => 
        Array.isArray(result.inferred_conflicts) &&
        result.inferred_conflicts.length > 0 &&
        result.inferred_conflicts.length <= 5
    });
    
    const inferredData = selected?.content.inferred_conflicts || [];
    
    return this.convertToConflicts(inferredData, characters);
  }
  
  private convertToConflicts(
    inferredData: any[],
    characters: Character[]
  ): Conflict[] {
    const conflicts: Conflict[] = [];
    const charNameToId = new Map(
      characters.map(c => [c.name, c.id])
    );
    
    for (const data of inferredData) {
      const involvedIds = (data.involved_character_names_or_ids || [])
        .map((ref: string) => charNameToId.get(ref) || ref)
        .filter((id: string) => id);
      
      if (involvedIds.length === 0) {
        continue;
      }
      
      try {
        const conflict: Conflict = {
          id: `conflict_${Date.now()}_${Math.random()}`,
          name: data.conflict_name || 'Unnamed Conflict',
          description: data.description_rationale || '',
          involvedCharacters: involvedIds,
          subject: this.parseConflictSubject(data.subject),
          scope: this.parseConflictScope(data.scope),
          phase: this.parseConflictPhase(data.initial_phase),
          strength: parseInt(data.strength) || 5,
          relatedRelationships: data.related_relationships || [],
          pivotPoints: data.pivot_points || [],
          timestamps: [new Date()],
          metadata: {
            source: 'AI_Inference_Engine',
            inferenceTimestamp: new Date().toISOString()
          }
        };
        
        conflicts.push(conflict);
      } catch (error) {
        console.error('Error parsing conflict:', error);
      }
    }
    
    return conflicts;
  }
  
  private parseConflictSubject(subjectStr: string): ConflictSubject {
    const normalized = subjectStr?.toUpperCase().replace(/[- ]/g, '_');
    return ConflictSubject[normalized as keyof typeof ConflictSubject] || 
           ConflictSubject.OTHER;
  }
  
  private parseConflictScope(scopeStr: string): ConflictScope {
    const normalized = scopeStr?.toUpperCase().replace(/[- ]/g, '_');
    return ConflictScope[normalized as keyof typeof ConflictScope] || 
           ConflictScope.PERSONAL;
  }
  
  private parseConflictPhase(phaseStr: string): ConflictPhase {
    const normalized = phaseStr?.toUpperCase().replace(/[- ]/g, '_');
    return ConflictPhase[normalized as keyof typeof ConflictPhase] || 
           ConflictPhase.EMERGING;
  }
}

/**
 * Ø§Ù„Ù…Ø­Ø·Ø© Ø§Ù„Ø«Ø§Ù„Ø«Ø©: Ø¨Ù†Ø§Ø¡ Ø´Ø¨ÙƒØ© Ø§Ù„ØµØ±Ø§Ø¹
 */
class Station3NetworkBuilder extends BaseStation<Station3Input, Station3Output> {
  private relationshipEngine: RelationshipInferenceEngine;
  private conflictEngine: ConflictInferenceEngine;
  
  constructor(
    config: StationConfig,
    geminiService: GeminiService,
    resultSelector: AIResultSelector
  ) {
    super(config, geminiService, resultSelector);
    this.relationshipEngine = new RelationshipInferenceEngine(
      geminiService,
      resultSelector
    );
    this.conflictEngine = new ConflictInferenceEngine(
      geminiService,
      resultSelector
    );
  }
  
  protected async process(input: Station3Input): Promise<Station3Output> {
    const startTime = Date.now();
    
    // 1. Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ù…Ù† Ø§Ù„Ù…Ø­Ø·Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰
    const characters = this.extractCharacters(input.station1Output);
    
    // 2. Ø¨Ù†Ø§Ø¡ Ø´Ø¨ÙƒØ© Ø§Ù„ØµØ±Ø§Ø¹
    const network: ConflictNetwork = {
      id: `network_${Date.now()}`,
      name: `ConflictNetwork_${input.station2Output.storyStatement.substring(0, 30)}`,
      characters: new Map(characters.map(c => [c.id, c])),
      relationships: new Map(),
      conflicts: new Map(),
      snapshots: [],
      metadata: {
        buildTimestamp: new Date().toISOString(),
        station1Source: 'Included',
        station2Source: 'Included'
      },
      addCharacter: function(character: Character): void {
        this.characters.set(character.id, character);
      },
      addRelationship: function(relationship: Relationship): void {
        this.relationships.set(relationship.id, relationship);
      },
      addConflict: function(conflict: Conflict): void {
        this.conflicts.set(conflict.id, conflict);
      },
      createSnapshot: function(description: string): void {
        this.snapshots.push({
          timestamp: new Date(),
          description,
          networkState: {
            characters: new Map(this.characters),
            relationships: new Map(this.relationships),
            conflicts: new Map(this.conflicts)
          }
        });
      }
    };
    
    // 3. Ø§Ø³ØªØ¯Ù„Ø§Ù„ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
    const relationships = await this.relationshipEngine.inferRelationships(
      characters,
      input.station1Output.relationshipAnalysis,
      input.station2Output,
      input.fullText
    );
    
    relationships.forEach(rel => network.addRelationship(rel));
    
    // 4. Ø§Ø³ØªØ¯Ù„Ø§Ù„ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
    const conflicts = await this.conflictEngine.inferConflicts(
      characters,
      relationships,
      input.station2Output,
      input.fullText
    );
    
    conflicts.forEach(conf => network.addConflict(conf));
    
    // 5. Ø¥Ù†Ø´Ø§Ø¡ Ù„Ù‚Ø·Ø© Ø£ÙˆÙ„ÙŠØ©
    network.createSnapshot('Initial network state after inference');
    
    const buildTime = Date.now() - startTime;
    
    return {
      conflictNetwork: network,
      networkSummary: {
        charactersCount: network.characters.size,
        relationshipsCount: network.relationships.size,
        conflictsCount: network.conflicts.size,
        snapshotsCount: network.snapshots.length
      },
      metadata: {
        analysisTimestamp: new Date(),
        status: 'Success',
        buildTime
      }
    };
  }
  
  private extractCharacters(s1Output: Station1Output): Character[] {
    const characters: Character[] = [];
    
    for (const [name, analysis] of s1Output.characterAnalysis) {
      const character: Character = {
        id: `char_${name.replace(/\s+/g, '_')}_${Date.now()}`,
        name,
        description: analysis.narrativeFunction,
        profile: {
          personalityTraits: analysis.personalityTraits,
          motivationsGoals: analysis.motivationsGoals,
          potentialArc: analysis.potentialArcObservation
        },
        metadata: {
          keyRelationshipsBrief: analysis.keyRelationshipsBrief,
          source: 'Station1_Analysis',
          extractionTimestamp: new Date().toISOString()
        }
      };
      
      characters.push(character);
    }
    
    return characters;
  }
  
  protected extractRequiredData(input: Station3Input): any {
    return {
      station1: input.station1Output,
      station2: input.station2Output,
      fullText: input.fullText
    };
  }
  
  protected getErrorFallback(): Station3Output {
    const emptyNetwork: ConflictNetwork = {
      id: 'error_network',
      name: 'ErrorNetwork',
      characters: new Map(),
      relationships: new Map(),
      conflicts: new Map(),
      snapshots: [],
      metadata: { error: 'Network building failed' },
      addCharacter: () => {},
      addRelationship: () => {},
      addConflict: () => {},
      createSnapshot: () => {}
    };
    
    return {
      conflictNetwork: emptyNetwork,
      networkSummary: {
        charactersCount: 0,
        relationshipsCount: 0,
        conflictsCount: 0,
        snapshotsCount: 0
      },
      metadata: {
        analysisTimestamp: new Date(),
        status: 'Failed',
        buildTime: 0
      }
    };
  }
}


---

## Ø§Ù„Ù…Ø­Ø·Ø© Ø§Ù„Ø±Ø§Ø¨Ø¹Ø©: Ù‚ÙŠØ§Ø³ Ø§Ù„ÙƒÙØ§Ø¡Ø© ÙˆØ§Ù„ÙØ¹Ø§Ù„ÙŠØ©

```typescript
// stations/station4/station4-efficiency-metrics.ts

interface Station4Input {
  conflictNetwork: ConflictNetwork;
  station3Output: Station3Output;
}

interface Station4Output {
  overallEfficiencyScore: number;
  overallRating: 'Excellent' | 'Good' | 'Fair' | 'Poor' | 'Critical';
  conflictCohesion: number;
  dramaticBalance: DramaticBalanceMetrics;
  narrativeEfficiency: NarrativeEfficiencyMetrics;
  redundancy: RedundancyMetrics;
  narrativeDensity: DensityMetrics;
  issues: EfficiencyIssue[];
  recommendations: string[];
  metadata: {
    analysisTimestamp: Date;
    status: 'Success' | 'Partial' | 'Failed';
    analysisTime: number;
  };
}

interface DramaticBalanceMetrics {
  balanceScore: number;
  balanceRating: string;
  characterInvolvementGini: number;
  conflictDistributionScore: number;
  details: {
    characterInvolvementStats: Map<string, number>;
    conflictTypeDistribution: Map<ConflictSubject, number>;
  };
}

interface NarrativeEfficiencyMetrics {
  narrativeEfficiencyScore: number;
  efficiencyRating: string;
  characterEfficiency: number;
  relationshipEfficiency: number;
  conflictEfficiency: number;
  details: {
    activeCharactersRatio: number;
    meaningfulRelationshipsRatio: number;
    resolvedConflictsRatio: number;
  };
}

interface RedundancyMetrics {
  redundancyScore: number;
  redundancyLevel: 'Low' | 'Moderate' | 'High' | 'Critical';
  duplicateRelationships: number;
  overlappingConflicts: number;
  details: {
    redundantPairs: Array<{
      type: 'relationship' | 'conflict';
      ids: [string, string];
      similarityScore: number;
    }>;
  };
}

interface DensityMetrics {
  densityScores: {
    storyDensity: number;
    characterDensity: number;
    conflictDensity: number;
  };
  densityRating: string;
  details: {
    averageConnectionsPerCharacter: number;
    averageConflictsPerCharacter: number;
    networkCentralization: number;
  };
}

interface EfficiencyIssue {
  type: 'structural' | 'balance' | 'redundancy' | 'density' | 'other';
  severity: 'critical' | 'major' | 'minor';
  description: string;
  affectedEntities: string[];
  suggestion: string;
}

/**
 * ÙˆØ­Ø¯Ø© Ù‚ÙŠØ§Ø³ Ø§Ù„ÙƒÙØ§Ø¡Ø©
 */
class EfficiencyMetricsAnalyzer {
  /**
   * Ø­Ø³Ø§Ø¨ ØªÙ…Ø§Ø³Ùƒ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
   */
  calculateConflictCohesion(network: ConflictNetwork): number {
    const conflicts = Array.from(network.conflicts.values());
    
    if (conflicts.length === 0) return 0;
    
    // Ø­Ø³Ø§Ø¨ Ø§Ù„ØªØ¯Ø§Ø®Ù„ Ø¨ÙŠÙ† Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
    let totalOverlap = 0;
    let comparisons = 0;
    
    for (let i = 0; i < conflicts.length; i++) {
      for (let j = i + 1; j < conflicts.length; j++) {
        const overlap = this.calculateConflictOverlap(
          conflicts[i],
          conflicts[j]
        );
        totalOverlap += overlap;
        comparisons++;
      }
    }
    
    return comparisons > 0 ? totalOverlap / comparisons : 0;
  }
  
  private calculateConflictOverlap(
    c1: Conflict,
    c2: Conflict
  ): number {
    const chars1 = new Set(c1.involvedCharacters);
    const chars2 = new Set(c2.involvedCharacters);
    
    const intersection = new Set(
      [...chars1].filter(x => chars2.has(x))
    );
    const union = new Set([...chars1, ...chars2]);
    
    return union.size > 0 ? intersection.size / union.size : 0;
  }
  
  /**
   * Ø­Ø³Ø§Ø¨ Ø§Ù„ØªÙˆØ§Ø²Ù† Ø§Ù„Ø¯Ø±Ø§Ù…ÙŠ
   */
  calculateDramaticBalance(
    network: ConflictNetwork
  ): DramaticBalanceMetrics {
    const characters = Array.from(network.characters.values());
    const conflicts = Array.from(network.conflicts.values());
    
    // Ø­Ø³Ø§Ø¨ Ù…Ø´Ø§Ø±ÙƒØ© ÙƒÙ„ Ø´Ø®ØµÙŠØ©
    const involvementMap = new Map<string, number>();
    
    for (const char of characters) {
      let involvement = 0;
      
      // Ù…Ù† Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
      for (const conflict of conflicts) {
        if (conflict.involvedCharacters.includes(char.id)) {
          involvement += conflict.strength;
        }
      }
      
      // Ù…Ù† Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
      for (const rel of network.relationships.values()) {
        if (rel.source === char.id || rel.target === char.id) {
          involvement += rel.strength * 0.5;
        }
      }
      
      involvementMap.set(char.id, involvement);
    }
    
    // Ø­Ø³Ø§Ø¨ Ù…Ø¹Ø§Ù…Ù„ Ø¬ÙŠÙ†ÙŠ Ù„Ù„ØªÙˆØ²ÙŠØ¹
    const gini = this.calculateGiniCoefficient(
      Array.from(involvementMap.values())
    );
    
    // Ø­Ø³Ø§Ø¨ ØªÙˆØ²ÙŠØ¹ Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
    const conflictTypeDistribution = new Map<ConflictSubject, number>();
    for (const conflict of conflicts) {
      conflictTypeDistribution.set(
        conflict.subject,
        (conflictTypeDistribution.get(conflict.subject) || 0) + 1
      );
    }
    
    // Ø¯Ø±Ø¬Ø© Ø§Ù„ØªÙˆØ§Ø²Ù† (ÙƒÙ„Ù…Ø§ Ù‚Ù„ Ø¬ÙŠÙ†ÙŠØŒ Ø²Ø§Ø¯ Ø§Ù„ØªÙˆØ§Ø²Ù†)
    const balanceScore = Math.max(0, 1 - gini);
    
    return {
      balanceScore,
      balanceRating: this.getRating(balanceScore),
      characterInvolvementGini: gini,
      conflictDistributionScore: this.calculateDistributionScore(
        conflictTypeDistribution
      ),
      details: {
        characterInvolvementStats: involvementMap,
        conflictTypeDistribution
      }
    };
  }
  
  /**
   * Ø­Ø³Ø§Ø¨ Ù…Ø¹Ø§Ù…Ù„ Ø¬ÙŠÙ†ÙŠ
   */
  private calculateGiniCoefficient(values: number[]): number {
    if (values.length === 0) return 0;
    
    const sorted = [...values].sort((a, b) => a - b);
    const n = sorted.length;
    const total = sorted.reduce((sum, val) => sum + val, 0);
    
    if (total === 0) return 0;
    
    let sum = 0;
    for (let i = 0; i < n; i++) {
      sum += (i + 1) * sorted[i];
    }
    
    return (2 * sum) / (n * total) - (n + 1) / n;
  }
  
  /**
   * Ø­Ø³Ø§Ø¨ Ø¯Ø±Ø¬Ø© Ø§Ù„ØªÙˆØ²ÙŠØ¹
   */
  private calculateDistributionScore(
    distribution: Map<any, number>
  ): number {
    const values = Array.from(distribution.values());
    const total = values.reduce((sum, val) => sum + val, 0);
    
    if (total === 0) return 0;
    
    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¥Ù†ØªØ±ÙˆØ¨ÙŠØ§ (Shannon Entropy)
    let entropy = 0;
    for (const count of values) {
      if (count > 0) {
        const p = count / total;
        entropy -= p * Math.log2(p);
      }
    }
    
    // ØªØ·Ø¨ÙŠØ¹ Ø§Ù„Ø¥Ù†ØªØ±ÙˆØ¨ÙŠØ§
    const maxEntropy = Math.log2(distribution.size);
    return maxEntropy > 0 ? entropy / maxEntropy : 0;
  }
  
  /**
   * Ø­Ø³Ø§Ø¨ ÙƒÙØ§Ø¡Ø© Ø§Ù„Ø³Ø±Ø¯
   */
  calculateNarrativeEfficiency(
    network: ConflictNetwork
  ): NarrativeEfficiencyMetrics {
    const characters = Array.from(network.characters.values());
    const relationships = Array.from(network.relationships.values());
    const conflicts = Array.from(network.conflicts.values());
    
    // Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù†Ø´Ø·Ø© (Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ© ÙÙŠ ØµØ±Ø§Ø¹Ø§Øª Ø£Ùˆ Ø¹Ù„Ø§Ù‚Ø§Øª)
    const activeCharacters = new Set<string>();
    
    for (const conflict of conflicts) {
      conflict.involvedCharacters.forEach(id => 
        activeCharacters.add(id)
      );
    }
    
    for (const rel of relationships) {
      activeCharacters.add(rel.source);
      activeCharacters.add(rel.target);
    }
    
    const activeRatio = characters.length > 0 
      ? activeCharacters.size / characters.length 
      : 0;
    
    // Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª Ø§Ù„Ø°Ø§Øª Ù…Ø¹Ù†Ù‰ (Ù‚ÙˆØ© > 5)
    const meaningfulRels = relationships.filter(r => r.strength > 5);
    const meaningfulRelsRatio = relationships.length > 0
      ? meaningfulRels.length / relationships.length
      : 0;
    
    // Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© (Ù„ÙŠØ³Øª ÙÙŠ Ù…Ø±Ø­Ù„Ø© LATENT)
    const advancedConflicts = conflicts.filter(
      c => c.phase !== ConflictPhase.LATENT
    );
    const advancedConflictsRatio = conflicts.length > 0
      ? advancedConflicts.length / conflicts.length
      : 0;
    
    // Ø§Ù„ÙƒÙØ§Ø¡Ø© Ø§Ù„ÙƒÙ„ÙŠØ©
    const characterEfficiency = activeRatio;
    const relationshipEfficiency = meaningfulRelsRatio;
    const conflictEfficiency = advancedConflictsRatio;
    
    const narrativeEfficiencyScore = 
      (characterEfficiency + relationshipEfficiency + conflictEfficiency) / 3;
    
    return {
      narrativeEfficiencyScore,
      efficiencyRating: this.getRating(narrativeEfficiencyScore),
      characterEfficiency,
      relationshipEfficiency,
      conflictEfficiency,
      details: {
        activeCharactersRatio: activeRatio,
        meaningfulRelationshipsRatio: meaningfulRelsRatio,
        resolvedConflictsRatio: advancedConflictsRatio
      }
    };
  }
  
  /**
   * ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªÙƒØ±Ø§Ø±
   */
  analyzeRedundancy(network: ConflictNetwork): RedundancyMetrics {
    const relationships = Array.from(network.relationships.values());
    const conflicts = Array.from(network.conflicts.values());
    
    const redundantPairs: Array<{
      type: 'relationship' | 'conflict';
      ids: [string, string];
      similarityScore: number;
    }> = [];
    
    // ÙØ­Øµ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª Ø§Ù„Ù…ÙƒØ±Ø±Ø©
    for (let i = 0; i < relationships.length; i++) {
      for (let j = i + 1; j < relationships.length; j++) {
        const similarity = this.calculateRelationshipSimilarity(
          relationships[i],
          relationships[j]
        );
        
        if (similarity > 0.8) {
          redundantPairs.push({
            type: 'relationship',
            ids: [relationships[i].id, relationships[j].id],
            similarityScore: similarity
          });
        }
      }
    }
    
    // ÙØ­Øµ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„Ù…ØªØ¯Ø§Ø®Ù„Ø©
    for (let i = 0; i < conflicts.length; i++) {
      for (let j = i + 1; j < conflicts.length; j++) {
        const similarity = this.calculateConflictSimilarity(
          conflicts[i],
          conflicts[j]
        );
        
        if (similarity > 0.7) {
          redundantPairs.push({
            type: 'conflict',
            ids: [conflicts[i].id, conflicts[j].id],
            similarityScore: similarity
          });
        }
      }
    }
    
    const duplicateRelationships = redundantPairs.filter(
      p => p.type === 'relationship'
    ).length;
    
    const overlappingConflicts = redundantPairs.filter(
      p => p.type === 'conflict'
    ).length;
    
    const totalEntities = relationships.length + conflicts.length;
    const redundancyScore = totalEntities > 0
      ? (duplicateRelationships + overlappingConflicts) / totalEntities
      : 0;
    
    return {
      redundancyScore,
      redundancyLevel: this.getRedundancyLevel(redundancyScore),
      duplicateRelationships,
      overlappingConflicts,
      details: { redundantPairs }
    };
  }
  
  private calculateRelationshipSimilarity(
    r1: Relationship,
    r2: Relationship
  ): number {
    // Ù†ÙØ³ Ø§Ù„Ø´Ø®ØµÙŠØ§ØªØŸ
    const samePair = 
      (r1.source === r2.source && r1.target === r2.target) ||
      (r1.source === r2.target && r1.target === r2.source);
    
    if (!samePair) return 0;
    
    // Ù†ÙØ³ Ø§Ù„Ù†ÙˆØ¹ ÙˆØ§Ù„Ø·Ø¨ÙŠØ¹Ø©ØŸ
    const sameType = r1.type === r2.type ? 0.5 : 0;
    const sameNature = r1.nature === r2.nature ? 0.5 : 0;
    
    return 0.5 + sameType + sameNature; // Ø£Ø³Ø§Ø³ 0.5 Ù„Ù†ÙØ³ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª
  }
  
  private calculateConflictSimilarity(
    c1: Conflict,
    c2: Conflict
  ): number {
    const chars1 = new Set(c1.involvedCharacters);
    const chars2 = new Set(c2.involvedCharacters);
    
    const intersection = new Set(
      [...chars1].filter(x => chars2.has(x))
    );
    
    const charOverlap = chars1.size > 0 && chars2.size > 0
      ? intersection.size / Math.min(chars1.size, chars2.size)
      : 0;
    
    const sameSubject = c1.subject === c2.subject ? 0.3 : 0;
    const sameScope = c1.scope === c2.scope ? 0.2 : 0;
    
    return charOverlap * 0.5 + sameSubject + sameScope;
  }
  
  /**
   * Ø­Ø³Ø§Ø¨ Ø§Ù„ÙƒØ«Ø§ÙØ© Ø§Ù„Ø³Ø±Ø¯ÙŠØ©
   */
  calculateNarrativeDensity(
    network: ConflictNetwork
  ): DensityMetrics {
    const numChars = network.characters.size;
    const numRels = network.relationships.size;
    const numConflicts = network.conflicts.size;
    
    if (numChars === 0) {
      return {
        densityScores: {
          storyDensity: 0,
          characterDensity: 0,
          conflictDensity: 0
        },
        densityRating: 'Empty',
        details: {
          averageConnectionsPerCharacter: 0,
          averageConflictsPerCharacter: 0,
          networkCentralization: 0
        }
      };
    }
    
    // Ø§Ù„ÙƒØ«Ø§ÙØ© Ø§Ù„ÙƒÙ„ÙŠØ©
    const maxPossibleConnections = numChars * (numChars - 1) / 2;
    const characterDensity = maxPossibleConnections > 0
      ? numRels / maxPossibleConnections
      : 0;
    
    const conflictDensity = numConflicts / numChars;
    
    const storyDensity = (characterDensity + Math.min(conflictDensity, 1)) / 2;
    
    // Ù…ØªÙˆØ³Ø· Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª Ù„ÙƒÙ„ Ø´Ø®ØµÙŠØ©
    const avgConnections = (numRels * 2) / numChars;
    
    // Ù…ØªÙˆØ³Ø· Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ù„ÙƒÙ„ Ø´Ø®ØµÙŠØ©
    let totalInvolvement = 0;
    for (const conflict of network.conflicts.values()) {
      totalInvolvement += conflict.involvedCharacters.length;
    }
    const avgConflicts = totalInvolvement / numChars;
    
    // Ø§Ù„Ù…Ø±ÙƒØ²ÙŠØ© (Network Centralization)
    const centralization = this.calculateNetworkCentralization(network);
    
    return {
      densityScores: {
        storyDensity,
        characterDensity,
        conflictDensity
      },
      densityRating: this.getRating(storyDensity),
      details: {
        averageConnectionsPerCharacter: avgConnections,
        averageConflictsPerCharacter: avgConflicts,
        networkCentralization: centralization
      }
    };
  }
  
  private calculateNetworkCentralization(
    network: ConflictNetwork
  ): number {
    const degrees = new Map<string, number>();
    
    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¯Ø±Ø¬Ø© Ù„ÙƒÙ„ Ø´Ø®ØµÙŠØ©
    for (const char of network.characters.keys()) {
      degrees.set(char, 0);
    }
    
    for (const rel of network.relationships.values()) {
      degrees.set(rel.source, (degrees.get(rel.source) || 0) + 1);
      degrees.set(rel.target, (degrees.get(rel.target) || 0) + 1);
    }
    
    const degreeValues = Array.from(degrees.values());
    if (degreeValues.length === 0) return 0;
    
    const maxDegree = Math.max(...degreeValues);
    const n = degreeValues.length;
    
    let sum = 0;
    for (const degree of degreeValues) {
      sum += maxDegree - degree;
    }
    
    const maxCentralization = (n - 1) * (n - 2);
    return maxCentralization > 0 ? sum / maxCentralization : 0;
  }
  
  private getRating(score: number): string {
    if (score >= 0.8) return 'Excellent';
    if (score >= 0.6) return 'Good';
    if (score >= 0.4) return 'Fair';
    if (score >= 0.2) return 'Poor';
    return 'Critical';
  }
  
  private getRedundancyLevel(score: number): 'Low' | 'Moderate' | 'High' | 'Critical' {
    if (score < 0.1) return 'Low';
    if (score < 0.25) return 'Moderate';
    if (score < 0.5) return 'High';
    return 'Critical';
  }
}

/**
 * Ø§Ù„Ù…Ø­Ø·Ø© Ø§Ù„Ø±Ø§Ø¨Ø¹Ø©: Ù‚ÙŠØ§Ø³ Ø§Ù„ÙƒÙØ§Ø¡Ø©
 */
class Station4EfficiencyMetrics extends BaseStation<Station4Input, Station4Output> {
  private analyzer: EfficiencyMetricsAnalyzer;
  
  constructor(
    config: StationConfig,
    geminiService: GeminiService,
    resultSelector: AIResultSelector
  ) {
    super(config, geminiService, resultSelector);
    this.analyzer = new EfficiencyMetricsAnalyzer();
  }
  
  protected async process(input: Station4Input): Promise<Station4Output> {
    const network = input.conflictNetwork;
    const startTime = Date.now();
    
    // Ø­Ø³Ø§Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù‚Ø§ÙŠÙŠØ³
    const conflictCohesion = this.analyzer.calculateConflictCohesion(network);
    const dramaticBalance = this.analyzer.calculateDramaticBalance(network);
    const narrativeEfficiency = this.analyzer.calculateNarrativeEfficiency(network);
    const redundancy = this.analyzer.analyzeRedundancy(network);
    const narrativeDensity = this.analyzer.calculateNarrativeDensity(network);
    
    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¯Ø±Ø¬Ø© Ø§Ù„ÙƒÙ„ÙŠØ©
    const overallEfficiencyScore = this.calculateOverallScore({
      conflictCohesion,
      dramaticBalance: dramaticBalance.balanceScore,
      narrativeEfficiency: narrativeEfficiency.narrativeEfficiencyScore,
      redundancy: 1 - redundancy.redundancyScore, // Ø¹ÙƒØ³ Ø§Ù„ØªÙƒØ±Ø§Ø±
      narrativeDensity: narrativeDensity.densityScores.storyDensity
    });
    
    // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ø´Ø§ÙƒÙ„
    const issues = this.identifyIssues({
      conflictCohesion,
      dramaticBalance,
      narrativeEfficiency,
      redundancy,
      narrativeDensity
    });
    
    // ØªÙ‚Ø¯ÙŠÙ… Ø§Ù„ØªÙˆØµÙŠØ§Øª
    const recommendations = this.generateRecommendations(issues);
    
    const analysisTime = Date.now() - startTime;
    
    return {
      overallEfficiencyScore,
      overallRating: this.getOverallRating(overallEfficiencyScore),
      conflictCohesion,
      dramaticBalance,
      narrativeEfficiency,
      redundancy,
      narrativeDensity,
      issues,
      recommendations,
      metadata: {
        analysisTimestamp: new Date(),
        status: 'Success',
        analysisTime
      }
    };
  }
  
  private calculateOverallScore(metrics: {
    conflictCohesion: number;
    dramaticBalance: number;
    narrativeEfficiency: number;
    redundancy: number;
    narrativeDensity: number;
  }): number {
    // Ø§Ù„Ø£ÙˆØ²Ø§Ù† Ø§Ù„Ù†Ø³Ø¨ÙŠØ©
    const weights = {
      conflictCohesion: 0.25,
      dramaticBalance: 0.25,
      narrativeEfficiency: 0.25,
      redundancy: 0.15,
      narrativeDensity: 0.10
    };
    
    return (
      metrics.conflictCohesion * weights.conflictCohesion +
      metrics.dramaticBalance * weights.dramaticBalance +
      metrics.narrativeEfficiency * weights.narrativeEfficiency +
      metrics.redundancy * weights.redundancy +
      metrics.narrativeDensity * weights.narrativeDensity
    );
  }
  
  private getOverallRating(
    score: number
  ): 'Excellent' | 'Good' | 'Fair' | 'Poor' | 'Critical' {
    if (score >= 0.8) return 'Excellent';
    if (score >= 0.6) return 'Good';
    if (score >= 0.4) return 'Fair';
    if (score >= 0.2) return 'Poor';
    return 'Critical';
  }
  
  private identifyIssues(metrics: {
    conflictCohesion: number;
    dramaticBalance: DramaticBalanceMetrics;
    narrativeEfficiency: NarrativeEfficiencyMetrics;
    redundancy: RedundancyMetrics;
    narrativeDensity: DensityMetrics;
  }): EfficiencyIssue[] {
    const issues: EfficiencyIssue[] = [];
    
    // ÙØ­Øµ ØªÙ…Ø§Ø³Ùƒ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
    if (metrics.conflictCohesion < 0.3) {
      issues.push({
        type: 'structural',
        severity: 'major',
        description: 'Conflict cohesion is very low - conflicts appear disconnected',
        affectedEntities: ['conflicts'],
        suggestion: 'Consider adding shared characters or themes between conflicts'
      });
    }
    
    // ÙØ­Øµ Ø§Ù„ØªÙˆØ§Ø²Ù† Ø§Ù„Ø¯Ø±Ø§Ù…ÙŠ
    if (metrics.dramaticBalance.characterInvolvementGini > 0.6) {
      issues.push({
        type: 'balance',
        severity: 'major',
        description: 'High imbalance in character involvement - some characters dominate',
        affectedEntities: ['characters'],
        suggestion: 'Distribute conflicts and relationships more evenly among characters'
      });
    }
    
    // ÙØ­Øµ Ø§Ù„ÙƒÙØ§Ø¡Ø© Ø§Ù„Ø³Ø±Ø¯ÙŠØ©
    if (metrics.narrativeEfficiency.characterEfficiency < 0.5) {
      issues.push({
        type: 'structural',
        severity: 'major',
        description: `Low character utilization - ${Math.round((1 - metrics.narrativeEfficiency.characterEfficiency) * 100)}% of characters are inactive`,
        affectedEntities: ['characters'],
        suggestion: 'Remove inactive characters or integrate them into conflicts'
      });
    }
    
    // ÙØ­Øµ Ø§Ù„ØªÙƒØ±Ø§Ø±
    if (metrics.redundancy.redundancyLevel === 'High' || 
        metrics.redundancy.redundancyLevel === 'Critical') {
      issues.push({
        type: 'redundancy',
        severity: metrics.redundancy.redundancyLevel === 'Critical' ? 'critical' : 'major',
        description: `${metrics.redundancy.redundancyLevel} redundancy detected`,
        affectedEntities: ['relationships', 'conflicts'],
        suggestion: 'Review and consolidate similar relationships or conflicts'
      });
    }
    
    // ÙØ­Øµ Ø§Ù„ÙƒØ«Ø§ÙØ©
    if (metrics.narrativeDensity.densityScores.storyDensity < 0.2) {
      issues.push({
        type: 'density',
        severity: 'minor',
        description: 'Low story density - narrative may feel sparse',
        affectedEntities: ['overall'],
        suggestion: 'Consider adding more relationships or conflicts'
      });
    } else if (metrics.narrativeDensity.densityScores.storyDensity > 0.8) {
      issues.push({
        type: 'density',
        severity: 'minor',
        description: 'Very high story density - narrative may feel overwhelming',
        affectedEntities: ['overall'],
        suggestion: 'Consider simplifying some relationships or conflicts'
      });
    }
    
    return issues;
  }
  
  private generateRecommendations(issues: EfficiencyIssue[]): string[] {
    const recommendations = new Set<string>();
    
    for (const issue of issues) {
      if (issue.severity === 'critical' || issue.severity === 'major') {
        recommendations.add(issue.suggestion);
      }
    }
    
    // ØªÙˆØµÙŠØ§Øª Ø¹Ø§Ù…Ø©
    if (issues.length === 0) {
      recommendations.add('Network structure is well-balanced - maintain current approach');
    } else if (issues.filter(i => i.severity === 'critical').length > 0) {
      recommendations.add('Critical issues detected - major revision recommended');
    }
    
    return Array.from(recommendations);
  }
  
  protected extractRequiredData(input: Station4Input): any {
    return {
      network: input.conflictNetwork,
      station3Output: input.station3Output
    };
  }
  
  protected getErrorFallback(): Station4Output {
    return {
      overallEfficiencyScore: 0,
      overallRating: 'Critical',
      conflictCohesion: 0,
      dramaticBalance: {
        balanceScore: 0,
        balanceRating: 'Critical',
        characterInvolvementGini: 1,
        conflictDistributionScore: 0,
        details: {
          characterInvolvementStats: new Map(),
          conflictTypeDistribution: new Map()
        }
      },
      narrativeEfficiency: {
        narrativeEfficiencyScore: 0,
        efficiencyRating: 'Critical',
        characterEfficiency: 0,
        relationshipEfficiency: 0,
        conflictEfficiency: 0,
        details: {
          activeCharactersRatio: 0,
          meaningfulRelationshipsRatio: 0,
          resolvedConflictsRatio: 0
        }
      },
      redundancy: {
        redundancyScore: 0,
        redundancyLevel: 'Low',
        duplicateRelationships: 0,
        overlappingConflicts: 0,
        details: { redundantPairs: [] }
      },
      narrativeDensity: {
        densityScores: {
          storyDensity: 0,
          characterDensity: 0,
          conflictDensity: 0
        },
        densityRating: 'Empty',
        details: {
          averageConnectionsPerCharacter: 0,
          averageConflictsPerCharacter: 0,
          networkCentralization: 0
        }
      },
      issues: [],
      recommendations: ['Analysis failed - unable to generate recommendations'],
      metadata: {
        analysisTimestamp: new Date(),
        status: 'Failed',
        analysisTime: 0
      }
    };
  }
}
```
Ø§Ù„Ù…Ø­Ø·Ø© Ø§Ù„Ø®Ø§Ù…Ø³Ø©: Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ ÙˆØ§Ù„Ø±Ù…Ø²ÙŠ ÙˆØ§Ù„Ø£Ø³Ù„ÙˆØ¨ÙŠ
typescript// stations/station5/station5-dynamic-symbolic-stylistic.ts

interface Station5Input {
  conflictNetwork: ConflictNetwork;
  station4Output: Station4Output;
  fullText: string;
}

interface Station5Output {
  dynamicAnalysisResults: DynamicAnalysisResults;
  episodicIntegrationResults: EpisodicIntegrationResults;
  symbolicAnalysisResults: SymbolicAnalysisResults;
  stylisticAnalysisResults: StylisticAnalysisResults;
  metadata: {
    analysisTimestamp: Date;
    status: 'Success' | 'Partial' | 'Failed';
    analysisTime: number;
  };
}

interface DynamicAnalysisResults {
  eventTimeline: TimelineEvent[];
  networkEvolutionAnalysis: EvolutionAnalysis;
  characterDevelopmentTracking: Map<string, CharacterEvolution>;
  conflictProgressionTracking: Map<string, ConflictProgression>;
}

interface TimelineEvent {
  timestamp: Date;
  eventType: 'character_introduced' | 'relationship_formed' | 
              'conflict_emerged' | 'conflict_escalated' | 
              'conflict_resolved' | 'character_transformed' | 
              'network_snapshot' | 'other';
  description: string;
  involvedEntities: {
    characters?: string[];
    relationships?: string[];
    conflicts?: string[];
  };
  significance: number; // 1-10
  narrativePhase: 'setup' | 'rising_action' | 'climax' | 
                   'falling_action' | 'resolution';
}

interface EvolutionAnalysis {
  overallGrowthRate: number;
  complexityProgression: number[];
  densityProgression: number[];
  criticalTransitionPoints: Array<{
    timestamp: Date;
    description: string;
    impactScore: number;
  }>;
  stabilityMetrics: {
    structuralStability: number;
    characterStability: number;
    conflictStability: number;
  };
}

interface CharacterEvolution {
  characterId: string;
  characterName: string;
  developmentStages: Array<{
    timestamp: Date;
    stage: string;
    traits: string[];
    relationships: string[];
    conflicts: string[];
  }>;
  arcType: 'positive' | 'negative' | 'flat' | 'complex';
  transformationScore: number;
  keyMoments: Array<{
    timestamp: Date;
    event: string;
    impact: string;
  }>;
}

interface ConflictProgression {
  conflictId: string;
  conflictName: string;
  phaseTransitions: Array<{
    timestamp: Date;
    fromPhase: ConflictPhase;
    toPhase: ConflictPhase;
    catalyst: string;
  }>;
  intensityProgression: number[];
  resolutionProbability: number;
  stagnationRisk: number;
}

interface EpisodicIntegrationResults {
  seriesStructure: SeriesStructure;
  seasonBreakdown: Map<number, SeasonDetails>;
  episodeDistribution: Map<string, EpisodeAssignment>;
  balanceReport: EpisodicBalanceReport;
}

interface SeriesStructure {
  totalSeasons: number;
  episodesPerSeason: number;
  totalEpisodes: number;
  recommendedRuntime: number; // minutes per episode
}

interface SeasonDetails {
  seasonNumber: number;
  seasonTitle: string;
  episodes: Episode[];
  majorConflicts: string[];
  seasonArc: string;
  cliffhanger?: string;
}

interface Episode {
  episodeNumber: number;
  seasonNumber: number;
  title: string;
  assignedConflicts: string[];
  featuredCharacters: string[];
  estimatedIntensity: number;
  narrativeFunction: 'setup' | 'development' | 'climax' | 'resolution';
}

interface EpisodeAssignment {
  conflictId: string;
  episodes: number[];
  distributionQuality: number;
}

interface EpisodicBalanceReport {
  overallBalance: number;
  conflictDistributionScore: number;
  characterAppearanceBalance: number;
  intensityFlowScore: number;
  recommendations: string[];
}

interface SymbolicAnalysisResults {
  keySymbols: Array<{
    symbol: string;
    interpretation: string;
    frequency: number;
    contextualMeanings: string[];
  }>;
  recurringMotifs: Array<{
    motif: string;
    occurrences: number;
    narrativeFunction: string;
  }>;
  centralThemesHintedBySymbols: string[];
  symbolicNetworks: Array<{
    primarySymbol: string;
    relatedSymbols: string[];
    thematicConnection: string;
  }>;
  depthScore: number;
  consistencyScore: number;
}

interface StylisticAnalysisResults {
  overallToneAssessment: {
    primaryTone: string;
    secondaryTones: string[];
    toneConsistency: number;
    explanation: string;
  };
  languageComplexity: {
    level: 'simple' | 'moderate' | 'complex' | 'highly_complex';
    readabilityScore: number;
    vocabularyRichness: number;
  };
  pacingImpression: {
    overallPacing: 'very_slow' | 'slow' | 'balanced' | 'fast' | 'very_fast';
    pacingVariation: number;
    sceneLengthDistribution: number[];
  };
  dialogueStyle: {
    characterization: string;
    naturalness: number;
    effectiveness: number;
    distinctiveness: number;
  };
  descriptiveRichness: {
    visualDetailLevel: number;
    sensoryEngagement: number;
    atmosphericQuality: number;
  };
  stylisticConsistencyImpression: {
    consistencyScore: number;
    deviations: Array<{
      location: string;
      type: string;
      description: string;
    }>;
  };
  textBlobSentiment?: {
    polarity: number;
    subjectivity: number;
  };
}

/**
 * Ù…Ø­Ø±Ùƒ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ
 */
class DynamicAnalysisEngine {
  /**
   * Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø²Ù…Ù†ÙŠ Ù„Ù„Ø£Ø­Ø¯Ø§Ø«
   */
  constructEventTimeline(network: ConflictNetwork): TimelineEvent[] {
    const events: TimelineEvent[] = [];
    
    // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ù…Ù† Ù„Ù‚Ø·Ø§Øª Ø§Ù„Ø´Ø¨ÙƒØ©
    for (const snapshot of network.snapshots) {
      events.push({
        timestamp: snapshot.timestamp,
        eventType: 'network_snapshot',
        description: snapshot.description,
        involvedEntities: {},
        significance: 5,
        narrativePhase: this.inferNarrativePhase(
          snapshot.timestamp,
          network.snapshots
        )
      });
    }
    
    // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ù…Ù† Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
    for (const conflict of network.conflicts.values()) {
      // Ø­Ø¯Ø« Ø¸Ù‡ÙˆØ± Ø§Ù„ØµØ±Ø§Ø¹
      if (conflict.timestamps.length > 0) {
        events.push({
          timestamp: conflict.timestamps[0],
          eventType: 'conflict_emerged',
          description: `Conflict emerged: ${conflict.name}`,
          involvedEntities: {
            characters: conflict.involvedCharacters,
            conflicts: [conflict.id]
          },
          significance: conflict.strength,
          narrativePhase: this.inferNarrativePhase(
            conflict.timestamps[0],
            network.snapshots
          )
        });
      }
      
      // Ø£Ø­Ø¯Ø§Ø« ØªØ·ÙˆØ± Ø§Ù„ØµØ±Ø§Ø¹
      for (let i = 1; i < conflict.timestamps.length; i++) {
        events.push({
          timestamp: conflict.timestamps[i],
          eventType: 'conflict_escalated',
          description: `Conflict escalated: ${conflict.name}`,
          involvedEntities: {
            characters: conflict.involvedCharacters,
            conflicts: [conflict.id]
          },
          significance: conflict.strength,
          narrativePhase: this.inferNarrativePhase(
            conflict.timestamps[i],
            network.snapshots
          )
        });
      }
    }
    
    // ØªØ±ØªÙŠØ¨ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ø²Ù…Ù†ÙŠØ§Ù‹
    events.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());
    
    return events;
  }
  
  private inferNarrativePhase(
    timestamp: Date,
    snapshots: NetworkSnapshot[]
  ): 'setup' | 'rising_action' | 'climax' | 'falling_action' | 'resolution' {
    if (snapshots.length === 0) return 'setup';
    
    const totalDuration = snapshots[snapshots.length - 1].timestamp.getTime() - 
                         snapshots[0].timestamp.getTime();
    
    if (totalDuration === 0) return 'setup';
    
    const position = (timestamp.getTime() - snapshots[0].timestamp.getTime()) / totalDuration;
    
    if (position < 0.2) return 'setup';
    if (position < 0.5) return 'rising_action';
    if (position < 0.7) return 'climax';
    if (position < 0.9) return 'falling_action';
    return 'resolution';
  }
  
  /**
   * ØªØ­Ù„ÙŠÙ„ ØªØ·ÙˆØ± Ø§Ù„Ø´Ø¨ÙƒØ©
   */
  analyzeNetworkEvolution(
    network: ConflictNetwork,
    timeline: TimelineEvent[]
  ): EvolutionAnalysis {
    const complexityProgression: number[] = [];
    const densityProgression: number[] = [];
    const transitionPoints: Array<{
      timestamp: Date;
      description: string;
      impactScore: number;
    }> = [];
    
    // Ø­Ø³Ø§Ø¨ Ø§Ù„ØªØ¹Ù‚ÙŠØ¯ ÙˆØ§Ù„ÙƒØ«Ø§ÙØ© Ø¹Ø¨Ø± Ø§Ù„Ø²Ù…Ù†
    for (const snapshot of network.snapshots) {
      if (!snapshot.networkState.characters || 
          !snapshot.networkState.relationships || 
          !snapshot.networkState.conflicts) {
        continue;
      }
      
      const numChars = snapshot.networkState.characters.size;
      const numRels = snapshot.networkState.relationships.size;
      const numConflicts = snapshot.networkState.conflicts.size;
      
      // Ø§Ù„ØªØ¹Ù‚ÙŠØ¯ = Ø¹Ø¯Ø¯ Ø§Ù„ÙƒÙŠØ§Ù†Ø§Øª Ø§Ù„ÙƒÙ„ÙŠ
      const complexity = numChars + numRels + numConflicts;
      complexityProgression.push(complexity);
      
      // Ø§Ù„ÙƒØ«Ø§ÙØ© = Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª / Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ù…ÙƒÙ†Ø©
      const maxPossibleRels = numChars * (numChars - 1) / 2;
      const density = maxPossibleRels > 0 ? numRels / maxPossibleRels : 0;
      densityProgression.push(density);
    }
    
    // ØªØ­Ø¯ÙŠØ¯ Ù†Ù‚Ø§Ø· Ø§Ù„ØªØ­ÙˆÙ„ Ø§Ù„Ø­Ø±Ø¬Ø©
    for (let i = 1; i < complexityProgression.length; i++) {
      const change = Math.abs(
        complexityProgression[i] - complexityProgression[i - 1]
      );
      
      if (change > 5) { // Ø¹ØªØ¨Ø© Ø§Ù„ØªØºÙŠÙŠØ± Ø§Ù„Ù…Ù‡Ù…
        transitionPoints.push({
          timestamp: network.snapshots[i].timestamp,
          description: network.snapshots[i].description,
          impactScore: change
        });
      }
    }
    
    // Ø­Ø³Ø§Ø¨ Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù†Ù…Ùˆ Ø§Ù„ÙƒÙ„ÙŠ
    const overallGrowthRate = complexityProgression.length > 1
      ? (complexityProgression[complexityProgression.length - 1] - 
         complexityProgression[0]) / complexityProgression.length
      : 0;
    
    // Ø­Ø³Ø§Ø¨ Ù…Ù‚Ø§ÙŠÙŠØ³ Ø§Ù„Ø§Ø³ØªÙ‚Ø±Ø§Ø±
    const stabilityMetrics = this.calculateStabilityMetrics(
      complexityProgression,
      densityProgression
    );
    
    return {
      overallGrowthRate,
      complexityProgression,
      densityProgression,
      criticalTransitionPoints: transitionPoints,
      stabilityMetrics
    };
  }
  
  private calculateStabilityMetrics(
    complexityProgression: number[],
    densityProgression: number[]
  ): {
    structuralStability: number;
    characterStability: number;
    conflictStability: number;
  } {
    // Ø­Ø³Ø§Ø¨ Ø§Ù„ØªØ¨Ø§ÙŠÙ† ÙÙŠ Ø§Ù„ØªØ¹Ù‚ÙŠØ¯
    const complexityVariance = this.calculateVariance(complexityProgression);
    const densityVariance = this.calculateVariance(densityProgression);
    
    // Ø§Ù„Ø§Ø³ØªÙ‚Ø±Ø§Ø± = 1 / (1 + Ø§Ù„ØªØ¨Ø§ÙŠÙ†)
    const structuralStability = 1 / (1 + complexityVariance);
    
    return {
      structuralStability,
      characterStability: 1 / (1 + densityVariance),
      conflictStability: structuralStability // ØªÙ‚Ø±ÙŠØ¨
    };
  }
  
  private calculateVariance(values: number[]): number {
    if (values.length === 0) return 0;
    
    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
    const squaredDiffs = values.map(val => Math.pow(val - mean, 2));
    return squaredDiffs.reduce((sum, val) => sum + val, 0) / values.length;
  }
  
  /**
   * ØªØªØ¨Ø¹ ØªØ·ÙˆØ± Ø§Ù„Ø´Ø®ØµÙŠØ§Øª
   */
  trackCharacterDevelopment(
    network: ConflictNetwork,
    timeline: TimelineEvent[]
  ): Map<string, CharacterEvolution> {
    const evolutionMap = new Map<string, CharacterEvolution>();
    
    for (const [charId, character] of network.characters) {
      const developmentStages: CharacterEvolution['developmentStages'] = [];
      const keyMoments: CharacterEvolution['keyMoments'] = [];
      
      // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù…Ø±Ø§Ø­Ù„ Ù…Ù† Ø§Ù„Ù„Ù‚Ø·Ø§Øª
      for (const snapshot of network.snapshots) {
        if (!snapshot.networkState.characters?.has(charId)) continue;
        
        const charState = snapshot.networkState.characters.get(charId);
        if (!charState) continue;
        
        // Ø¬Ù…Ø¹ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª ÙˆØ§Ù„ØµØ±Ø§Ø¹Ø§Øª ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø­Ù„Ø©
        const relationships: string[] = [];
        const conflicts: string[] = [];
        
        if (snapshot.networkState.relationships) {
          for (const [relId, rel] of snapshot.networkState.relationships) {
            if (rel.source === charId || rel.target === charId) {
              relationships.push(relId);
            }
          }
        }
        
        if (snapshot.networkState.conflicts) {
          for (const [confId, conf] of snapshot.networkState.conflicts) {
            if (conf.involvedCharacters.includes(charId)) {
              conflicts.push(confId);
            }
          }
        }
        
        developmentStages.push({
          timestamp: snapshot.timestamp,
          stage: snapshot.description,
          traits: [], // ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ®Ø±Ø§Ø¬Ù‡Ø§ Ù…Ù† Ø§Ù„ØªØ­Ù„ÙŠÙ„
          relationships,
          conflicts
        });
      }
      
      // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù„Ø­Ø¸Ø§Øª Ø§Ù„Ù…ÙØµÙ„ÙŠØ© Ù…Ù† Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø²Ù…Ù†ÙŠ
      for (const event of timeline) {
        if (event.involvedEntities.characters?.includes(charId)) {
          keyMoments.push({
            timestamp: event.timestamp,
            event: event.description,
            impact: `Significance: ${event.significance}/10`
          });
        }
      }
      
      // ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„Ù‚ÙˆØ³
      const arcType = this.determineArcType(developmentStages);
      
      // Ø­Ø³Ø§Ø¨ Ø¯Ø±Ø¬Ø© Ø§Ù„ØªØ­ÙˆÙ„
      const transformationScore = this.calculateTransformationScore(
        developmentStages
      );
      
      evolutionMap.set(charId, {
        characterId: charId,
        characterName: character.name,
        developmentStages,
        arcType,
        transformationScore,
        keyMoments
      });
    }
    
    return evolutionMap;
  }
  
  private determineArcType(
    stages: CharacterEvolution['developmentStages']
  ): 'positive' | 'negative' | 'flat' | 'complex' {
    if (stages.length < 2) return 'flat';
    
    // ØªØ­Ù„ÙŠÙ„ Ø¨Ø³ÙŠØ· Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø¹Ø¯Ø¯ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª ÙˆØ§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
    const firstStage = stages[0];
    const lastStage = stages[stages.length - 1];
    
    const conflictChange = 
      lastStage.conflicts.length - firstStage.conflicts.length;
    const relationshipChange = 
      lastStage.relationships.length - firstStage.relationships.length;
    
    const totalChange = conflictChange + relationshipChange;
    
    if (totalChange > 2) return 'positive';
    if (totalChange < -2) return 'negative';
    if (Math.abs(totalChange) > 4) return 'complex';
    return 'flat';
  }
  
  private calculateTransformationScore(
    stages: CharacterEvolution['developmentStages']
  ): number {
    if (stages.length < 2) return 0;
    
    let totalChange = 0;
    
    for (let i = 1; i < stages.length; i++) {
      const prev = stages[i - 1];
      const curr = stages[i];
      
      const conflictChange = Math.abs(
        curr.conflicts.length - prev.conflicts.length
      );
      const relationshipChange = Math.abs(
        curr.relationships.length - prev.relationships.length
      );
      
      totalChange += conflictChange + relationshipChange;
    }
    
    // ØªØ·Ø¨ÙŠØ¹ Ø§Ù„Ø¯Ø±Ø¬Ø© (0-10)
    return Math.min(10, totalChange / stages.length);
  }
  
  /**
   * ØªØªØ¨Ø¹ ØªÙ‚Ø¯Ù… Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
   */
  trackConflictProgression(
    network: ConflictNetwork,
    timeline: TimelineEvent[]
  ): Map<string, ConflictProgression> {
    const progressionMap = new Map<string, ConflictProgression>();
    
    for (const [confId, conflict] of network.conflicts) {
      const phaseTransitions: ConflictProgression['phaseTransitions'] = [];
      const intensityProgression: number[] = [];
      
      // ØªØªØ¨Ø¹ ØªØ­ÙˆÙ„Ø§Øª Ø§Ù„Ù…Ø±Ø§Ø­Ù„ Ù…Ù† Ø§Ù„Ù„Ù‚Ø·Ø§Øª
      let previousPhase: ConflictPhase | null = null;
      
      for (const snapshot of network.snapshots) {
        if (!snapshot.networkState.conflicts?.has(confId)) continue;
        
        const confState = snapshot.networkState.conflicts.get(confId);
        if (!confState) continue;
        
        intensityProgression.push(confState.strength);
        
        if (previousPhase !== null && confState.phase !== previousPhase) {
          // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù…Ø­ÙØ² Ù…Ù† Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø²Ù…Ù†ÙŠ
          const catalyst = timeline.find(
            event => 
              event.timestamp.getTime() === snapshot.timestamp.getTime() &&
              event.involvedEntities.conflicts?.includes(confId)
          )?.description || 'Unknown catalyst';
          
          phaseTransitions.push({
            timestamp: snapshot.timestamp,
            fromPhase: previousPhase,
            toPhase: confState.phase,
            catalyst
          });
        }
        
        previousPhase = confState.phase;
      }
      
      // Ø­Ø³Ø§Ø¨ Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ© Ø§Ù„Ø­Ù„
      const resolutionProbability = this.calculateResolutionProbability(
        conflict,
        phaseTransitions
      );
      
      // Ø­Ø³Ø§Ø¨ Ø®Ø·Ø± Ø§Ù„Ø±ÙƒÙˆØ¯
      const stagnationRisk = this.calculateStagnationRisk(
        intensityProgression,
        phaseTransitions
      );
      
      progressionMap.set(confId, {
        conflictId: confId,
        conflictName: conflict.name,
        phaseTransitions,
        intensityProgression,
        resolutionProbability,
        stagnationRisk
      });
    }
    
    return progressionMap;
  }
  
  private calculateResolutionProbability(
    conflict: Conflict,
    transitions: ConflictProgression['phaseTransitions']
  ): number {
    // Ø¹ÙˆØ§Ù…Ù„ ØªØ²ÙŠØ¯ Ù…Ù† Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ© Ø§Ù„Ø­Ù„
    let probability = 0.5; // Ù‚Ø§Ø¹Ø¯Ø©
    
    // Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
    if (conflict.phase === ConflictPhase.RESOLUTION) {
      probability = 0.95;
    } else if (conflict.phase === ConflictPhase.DEESCALATING) {
      probability = 0.75;
    } else if (conflict.phase === ConflictPhase.AFTERMATH) {
      probability = 1.0;
    } else if (conflict.phase === ConflictPhase.CLIMAX) {
      probability = 0.6;
    } else if (conflict.phase === ConflictPhase.LATENT) {
      probability = 0.2;
    }
    
    // Ø¹Ø¯Ø¯ Ø§Ù„ØªØ­ÙˆÙ„Ø§Øª (Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„ØªØ·ÙˆØ± ÙŠØ²ÙŠØ¯ Ø§Ù„Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ©)
    const transitionBonus = Math.min(0.3, transitions.length * 0.05);
    probability += transitionBonus;
    
    return Math.max(0, Math.min(1, probability));
  }
  
  private calculateStagnationRisk(
    intensityProgression: number[],
    transitions: ConflictProgression['phaseTransitions']
  ): number {
    if (intensityProgression.length < 3) return 0.5;
    
    // Ø­Ø³Ø§Ø¨ Ø§Ù„ØªØ¨Ø§ÙŠÙ† ÙÙŠ Ø§Ù„Ø´Ø¯Ø©
    const variance = this.calculateVariance(intensityProgression);
    
    // Ù‚Ù„Ø© Ø§Ù„ØªØ­ÙˆÙ„Ø§Øª = Ø®Ø·Ø± Ø±ÙƒÙˆØ¯ Ø£Ø¹Ù„Ù‰
    const transitionFactor = transitions.length === 0 ? 0.8 : 
                            transitions.length < 2 ? 0.5 : 0.2;
    
    // ØªØ¨Ø§ÙŠÙ† Ù…Ù†Ø®ÙØ¶ = Ø±ÙƒÙˆØ¯
    const varianceFactor = variance < 1 ? 0.7 : 
                          variance < 3 ? 0.4 : 0.1;
    
    const risk = (transitionFactor + varianceFactor) / 2;
    
    return Math.max(0, Math.min(1, risk));
  }
}

/**
 * Ù…Ø­Ø±Ùƒ Ø§Ù„ØªÙƒØ§Ù…Ù„ Ø§Ù„Ø­Ù„Ù‚ÙŠ
 */
class EpisodicIntegrationEngine {
  /**
   * Ø¥Ù†Ø´Ø§Ø¡ Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø³Ù„Ø³Ù„Ø©
   */
  createSeriesStructure(
    network: ConflictNetwork,
    targetEpisodesPerSeason: number = 10
  ): SeriesStructure {
    const numConflicts = network.conflicts.size;
    
    // ØªÙ‚Ø¯ÙŠØ± Ø¹Ø¯Ø¯ Ø§Ù„Ø­Ù„Ù‚Ø§Øª Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
    // Ø§ÙØªØ±Ø§Ø¶: 2-3 ØµØ±Ø§Ø¹Ø§Øª Ù„ÙƒÙ„ Ø­Ù„Ù‚Ø©
    const estimatedEpisodes = Math.ceil(numConflicts / 2.5);
    
    const totalEpisodes = Math.max(
      targetEpisodesPerSeason,
      estimatedEpisodes
    );
    
    const totalSeasons = Math.ceil(totalEpisodes / targetEpisodesPerSeason);
    
    return {
      totalSeasons,
      episodesPerSeason: targetEpisodesPerSeason,
      totalEpisodes,
      recommendedRuntime: 45 // Ø¯Ù‚ÙŠÙ‚Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
    };
  }
  
  /**
   * ØªÙˆØ²ÙŠØ¹ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø¹Ø¨Ø± Ø§Ù„Ø­Ù„Ù‚Ø§Øª
   */
  distributeConflicts(
    network: ConflictNetwork,
    structure: SeriesStructure
  ): Map<string, EpisodeAssignment> {
    const assignments = new Map<string, EpisodeAssignment>();
    const conflicts = Array.from(network.conflicts.values());
    
    // ØªØ±ØªÙŠØ¨ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø­Ø³Ø¨ Ø§Ù„Ø£Ù‡Ù…ÙŠØ© (Ø§Ù„Ø´Ø¯Ø©)
    conflicts.sort((a, b) => b.strength - a.strength);
    
    let currentEpisode = 1;
    
    for (const conflict of conflicts) {
      const episodes: number[] = [];
      
      // ØªÙˆØ²ÙŠØ¹ Ø§Ù„ØµØ±Ø§Ø¹ Ø¹Ù„Ù‰ 2-4 Ø­Ù„Ù‚Ø§Øª Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø´Ø¯ØªÙ‡
      const episodeSpan = Math.ceil(conflict.strength / 3);
      
      for (let i = 0; i < episodeSpan; i++) {
        if (currentEpisode <= structure.totalEpisodes) {
          episodes.push(currentEpisode);
          currentEpisode++;
        }
      }
      
      // Ø¥Ø°Ø§ ÙˆØµÙ„Ù†Ø§ Ù„Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ø³Ù„Ø³Ù„Ø©ØŒ Ù†Ø¨Ø¯Ø£ Ù…Ù† Ø¬Ø¯ÙŠØ¯
      if (currentEpisode > structure.totalEpisodes) {
        currentEpisode = 1;
      }
      
      assignments.set(conflict.id, {
        conflictId: conflict.id,
        episodes,
        distributionQuality: this.evaluateDistributionQuality(episodes)
      });
    }
    
    return assignments;
  }
  
  private evaluateDistributionQuality(episodes: number[]): number {
    if (episodes.length === 0) return 0;
    if (episodes.length === 1) return 1;
    
    // Ø§Ù„ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø¬ÙŠØ¯ = ÙØªØ±Ø§Øª Ù…ØªØ³Ø§ÙˆÙŠØ© Ø¨ÙŠÙ† Ø§Ù„Ø­Ù„Ù‚Ø§Øª
    const gaps: number[] = [];
    for (let i = 1; i < episodes.length; i++) {
      gaps.push(episodes[i] - episodes[i - 1]);
    }
    
    const avgGap = gaps.reduce((sum, gap) => sum + gap, 0) / gaps.length;
    const variance = this.calculateVariance(gaps);
    
    // Ù‚Ù„Ø© Ø§Ù„ØªØ¨Ø§ÙŠÙ† = Ø¬ÙˆØ¯Ø© Ø£Ø¹Ù„Ù‰
    const quality = 1 / (1 + variance);
    
    return Math.max(0, Math.min(1, quality));
  }
  
  private calculateVariance(values: number[]): number {
    if (values.length === 0) return 0;
    
    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
    const squaredDiffs = values.map(val => Math.pow(val - mean, 2));
    return squaredDiffs.reduce((sum, val) => sum + val, 0) / values.length;
  }
  
  /**
   * Ø¥Ù†Ø´Ø§Ø¡ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ù…ÙˆØ§Ø³Ù…
   */
  createSeasonBreakdown(
    network: ConflictNetwork,
    structure: SeriesStructure,
    assignments: Map<string, EpisodeAssignment>
  ): Map<number, SeasonDetails> {
    const seasonMap = new Map<number, SeasonDetails>();
    
    for (let s = 1; s <= structure.totalSeasons; s++) {
      const startEpisode = (s - 1) * structure.episodesPerSeason + 1;
      const endEpisode = Math.min(
        s * structure.episodesPerSeason,
        structure.totalEpisodes
      );
      
      // Ø§Ù„Ø­Ù„Ù‚Ø§Øª ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ù…ÙˆØ³Ù…
      const episodes: Episode[] = [];
      const seasonConflicts = new Set<string>();
      
      for (let e = startEpisode; e <= endEpisode; e++) {
        const episodeConflicts: string[] = [];
        const featuredCharacters = new Set<string>();
        
        // Ø¬Ù…Ø¹ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„Ù…Ø®ØµØµØ© Ù„Ù‡Ø°Ù‡ Ø§Ù„Ø­Ù„Ù‚Ø©
        for (const [conflictId, assignment] of assignments) {
          if (assignment.episodes.includes(e)) {
            episodeConflicts.push(conflictId);
            seasonConflicts.add(conflictId);
            
            const conflict = network.conflicts.get(conflictId);
            if (conflict) {
              conflict.involvedCharacters.forEach(charId => 
                featuredCharacters.add(charId)
              );
            }
          }
        }
        
        // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø´Ø¯Ø© Ø§Ù„Ù…Ù‚Ø¯Ø±Ø©
        let estimatedIntensity = 0;
        for (const confId of episodeConflicts) {
          const conflict = network.conflicts.get(confId);
          if (conflict) {
            estimatedIntensity += conflict.strength;
          }
        }
        estimatedIntensity = Math.min(10, estimatedIntensity / episodeConflicts.length);
        
        // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙˆØ¸ÙŠÙØ© Ø§Ù„Ø³Ø±Ø¯ÙŠØ©
        const relativePosition = (e - startEpisode) / (endEpisode - startEpisode);
        const narrativeFunction = 
          relativePosition < 0.3 ? 'setup' :
          relativePosition < 0.7 ? 'development' :
          relativePosition < 0.9 ? 'climax' : 'resolution';
        
        episodes.push({
          episodeNumber: e,
          seasonNumber: s,
          title: `Episode ${e}`,
          assignedConflicts: episodeConflicts,
          featuredCharacters: Array.from(featuredCharacters),
          estimatedIntensity,
          narrativeFunction
        });
      }
      
      seasonMap.set(s, {
        seasonNumber: s,
        seasonTitle: `Season ${s}`,
        episodes,
        majorConflicts: Array.from(seasonConflicts),
        seasonArc: `Season ${s} arc description`,
        cliffhanger: s < structure.totalSeasons 
          ? `Cliffhanger for Season ${s}` 
          : undefined
      });
    }
    
    return seasonMap;
  }
  
  /**
   * ØªÙ‚ÙŠÙŠÙ… ØªÙˆØ§Ø²Ù† Ø§Ù„ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø­Ù„Ù‚ÙŠ
   */
  evaluateEpisodicBalance(
    network: ConflictNetwork,
    seasonBreakdown: Map<number, SeasonDetails>
  ): EpisodicBalanceReport {
    const allEpisodes: Episode[] = [];
    for (const season of seasonBreakdown.values()) {
      allEpisodes.push(...season.episodes);
    }
    
    // ØªÙˆØ²ÙŠØ¹ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
    const conflictsPerEpisode = allEpisodes.map(ep => 
      ep.assignedConflicts.length
    );
    const conflictDistributionScore = 1 - this.calculateVariance(
      conflictsPerEpisode
    ) / Math.max(...conflictsPerEpisode);
    
    // ØªÙˆØ§Ø²Ù† Ø¸Ù‡ÙˆØ± Ø§Ù„Ø´Ø®ØµÙŠØ§Øª
    const charAppearances = new Map<string, number>();
    for (const episode of allEpisodes) {
      for (const charId of episode.featuredCharacters) {RetryAContinueEdittypescript        charAppearances.set(
          charId,
          (charAppearances.get(charId) || 0) + 1
        );
      }
    }
    
    const appearanceCounts = Array.from(charAppearances.values());
    const characterAppearanceBalance = appearanceCounts.length > 0
      ? 1 - this.calculateVariance(appearanceCounts) / 
        Math.max(...appearanceCounts)
      : 0;
    
    // ØªØ¯ÙÙ‚ Ø§Ù„Ø´Ø¯Ø©
    const intensities = allEpisodes.map(ep => ep.estimatedIntensity);
    const intensityFlowScore = this.evaluateIntensityFlow(intensities);
    
    // Ø§Ù„ØªÙˆØ§Ø²Ù† Ø§Ù„ÙƒÙ„ÙŠ
    const overallBalance = (
      conflictDistributionScore * 0.4 +
      characterAppearanceBalance * 0.3 +
      intensityFlowScore * 0.3
    );
    
    // Ø§Ù„ØªÙˆØµÙŠØ§Øª
    const recommendations = this.generateBalanceRecommendations({
      conflictDistributionScore,
      characterAppearanceBalance,
      intensityFlowScore,
      overallBalance
    });
    
    return {
      overallBalance,
      conflictDistributionScore,
      characterAppearanceBalance,
      intensityFlowScore,
      recommendations
    };
  }
  
  private evaluateIntensityFlow(intensities: number[]): number {
    if (intensities.length < 2) return 1;
    
    // ØªØ¯ÙÙ‚ Ø¬ÙŠØ¯ = ØªØµØ§Ø¹Ø¯ ØªØ¯Ø±ÙŠØ¬ÙŠ Ù…Ø¹ Ù‚Ù…Ù… ÙˆÙ‚ÙŠØ¹Ø§Ù†
    let score = 1.0;
    
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ ØªÙ†ÙˆØ¹
    const variance = this.calculateVariance(intensities);
    if (variance < 1) {
      score -= 0.3; // ØªØ¯ÙÙ‚ Ù…Ø³Ø·Ø­ = Ø³ÙŠØ¡
    }
    
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªØµØ§Ø¹Ø¯ Ø§Ù„Ø¹Ø§Ù…
    const firstHalf = intensities.slice(0, Math.floor(intensities.length / 2));
    const secondHalf = intensities.slice(Math.floor(intensities.length / 2));
    
    const firstHalfAvg = firstHalf.reduce((sum, val) => sum + val, 0) / firstHalf.length;
    const secondHalfAvg = secondHalf.reduce((sum, val) => sum + val, 0) / secondHalf.length;
    
    if (secondHalfAvg > firstHalfAvg) {
      score += 0.2; // ØªØµØ§Ø¹Ø¯ Ø¬ÙŠØ¯
    }
    
    return Math.max(0, Math.min(1, score));
  }
  
  private generateBalanceRecommendations(metrics: {
    conflictDistributionScore: number;
    characterAppearanceBalance: number;
    intensityFlowScore: number;
    overallBalance: number;
  }): string[] {
    const recommendations: string[] = [];
    
    if (metrics.conflictDistributionScore < 0.6) {
      recommendations.push(
        'Consider redistributing conflicts more evenly across episodes'
      );
    }
    
    if (metrics.characterAppearanceBalance < 0.5) {
      recommendations.push(
        'Some characters appear too frequently or too rarely - balance character screen time'
      );
    }
    
    if (metrics.intensityFlowScore < 0.5) {
      recommendations.push(
        'Intensity flow needs improvement - add more variation and build-up'
      );
    }
    
    if (metrics.overallBalance >= 0.8) {
      recommendations.push(
        'Excellent episodic balance - maintain current structure'
      );
    }
    
    return recommendations;
  }
  
  private calculateVariance(values: number[]): number {
    if (values.length === 0) return 0;
    
    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
    const squaredDiffs = values.map(val => Math.pow(val - mean, 2));
    return squaredDiffs.reduce((sum, val) => sum + val, 0) / values.length;
  }
}

/**
 * Ø§Ù„Ù…Ø­Ø·Ø© Ø§Ù„Ø®Ø§Ù…Ø³Ø©: Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ ÙˆØ§Ù„Ø±Ù…Ø²ÙŠ ÙˆØ§Ù„Ø£Ø³Ù„ÙˆØ¨ÙŠ
 */
class Station5DynamicSymbolicStylistic extends BaseStation<Station5Input, Station5Output> {
  private dynamicEngine: DynamicAnalysisEngine;
  private episodicEngine: EpisodicIntegrationEngine;
  
  constructor(
    config: StationConfig,
    geminiService: GeminiService,
    resultSelector: AIResultSelector
  ) {
    super(config, geminiService, resultSelector);
    this.dynamicEngine = new DynamicAnalysisEngine();
    this.episodicEngine = new EpisodicIntegrationEngine();
  }
  
  protected async process(input: Station5Input): Promise<Station5Output> {
    const startTime = Date.now();
    
    // 1. Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ
    const dynamicAnalysisResults = await this.performDynamicAnalysis(
      input.conflictNetwork
    );
    
    // 2. Ø§Ù„ØªÙƒØ§Ù…Ù„ Ø§Ù„Ø­Ù„Ù‚ÙŠ
    const episodicIntegrationResults = await this.performEpisodicIntegration(
      input.conflictNetwork
    );
    
    // 3. Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø±Ù…Ø²ÙŠ (Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ)
    const symbolicAnalysisResults = await this.performSymbolicAnalysis(
      input.fullText
    );
    
    // 4. Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ø³Ù„ÙˆØ¨ÙŠ (Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ)
    const stylisticAnalysisResults = await this.performStylisticAnalysis(
      input.fullText
    );
    
    const analysisTime = Date.now() - startTime;
    
    return {
      dynamicAnalysisResults,
      episodicIntegrationResults,
      symbolicAnalysisResults,
      stylisticAnalysisResults,
      metadata: {
        analysisTimestamp: new Date(),
        status: 'Success',
        analysisTime
      }
    };
  }
  
  private async performDynamicAnalysis(
    network: ConflictNetwork
  ): Promise<DynamicAnalysisResults> {
    // Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø²Ù…Ù†ÙŠ
    const eventTimeline = this.dynamicEngine.constructEventTimeline(network);
    
    // ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØ·ÙˆØ±
    const networkEvolutionAnalysis = this.dynamicEngine.analyzeNetworkEvolution(
      network,
      eventTimeline
    );
    
    // ØªØªØ¨Ø¹ ØªØ·ÙˆØ± Ø§Ù„Ø´Ø®ØµÙŠØ§Øª
    const characterDevelopmentTracking = 
      this.dynamicEngine.trackCharacterDevelopment(
        network,
        eventTimeline
      );
    
    // ØªØªØ¨Ø¹ ØªÙ‚Ø¯Ù… Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
    const conflictProgressionTracking = 
      this.dynamicEngine.trackConflictProgression(
        network,
        eventTimeline
      );
    
    return {
      eventTimeline,
      networkEvolutionAnalysis,
      characterDevelopmentTracking,
      conflictProgressionTracking
    };
  }
  
  private async performEpisodicIntegration(
    network: ConflictNetwork
  ): Promise<EpisodicIntegrationResults> {
    // Ø¥Ù†Ø´Ø§Ø¡ Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø³Ù„Ø³Ù„Ø©
    const seriesStructure = this.episodicEngine.createSeriesStructure(
      network,
      10 // 10 Ø­Ù„Ù‚Ø§Øª Ù„ÙƒÙ„ Ù…ÙˆØ³Ù… Ø§ÙØªØ±Ø§Ø¶ÙŠØ§Ù‹
    );
    
    // ØªÙˆØ²ÙŠØ¹ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
    const episodeDistribution = this.episodicEngine.distributeConflicts(
      network,
      seriesStructure
    );
    
    // Ø¥Ù†Ø´Ø§Ø¡ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ù…ÙˆØ§Ø³Ù…
    const seasonBreakdown = this.episodicEngine.createSeasonBreakdown(
      network,
      seriesStructure,
      episodeDistribution
    );
    
    // ØªÙ‚ÙŠÙŠÙ… Ø§Ù„ØªÙˆØ§Ø²Ù†
    const balanceReport = this.episodicEngine.evaluateEpisodicBalance(
      network,
      seasonBreakdown
    );
    
    return {
      seriesStructure,
      seasonBreakdown,
      episodeDistribution,
      balanceReport
    };
  }
  
  private async performSymbolicAnalysis(
    fullText: string
  ): Promise<SymbolicAnalysisResults> {
    const prompt = `
Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù†Øµ Ø§Ù„Ø³Ø±Ø¯ÙŠ Ø§Ù„Ù…Ø±ÙÙ‚ØŒ Ù‚Ù… Ø¨ØªØ­Ù„ÙŠÙ„ ÙˆØªØ­Ø¯ÙŠØ¯ Ù…Ø§ ÙŠÙ„ÙŠ:

1. **key_symbols**: Ù‚Ø§Ø¦Ù…Ø© Ø¨Ù€ 3-5 Ø±Ù…ÙˆØ² Ø£Ùˆ Ø£Ø´ÙŠØ§Ø¡ Ø£Ùˆ Ø£Ù…Ø§ÙƒÙ† Ù…ØªÙƒØ±Ø±Ø© Ø£Ùˆ Ø°Ø§Øª Ø£Ù‡Ù…ÙŠØ© Ø±Ù…Ø²ÙŠØ© ÙˆØ§Ø¶Ø­Ø© ÙÙŠ Ø§Ù„Ù†Øµ. 
   Ù„ÙƒÙ„ Ø±Ù…Ø²ØŒ Ù‚Ø¯Ù…:
   - "symbol": Ø§Ø³Ù… Ø§Ù„Ø±Ù…Ø²
   - "interpretation": ØªÙØ³ÙŠØ± Ù…ÙˆØ¬Ø² Ù„Ù…Ø¹Ù†Ø§Ù‡ Ø§Ù„Ù…Ø­ØªÙ…Ù„
   - "frequency": ØªÙ‚Ø¯ÙŠØ± Ù„Ø¹Ø¯Ø¯ Ù…Ø±Ø§Øª Ø§Ù„Ø¸Ù‡ÙˆØ± (Ø±Ù‚Ù…)
   - "contextual_meanings": Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø§Ù„Ù…Ø¹Ø§Ù†ÙŠ Ø§Ù„Ù…Ø®ØªÙ„ÙØ© ÙÙŠ Ø³ÙŠØ§Ù‚Ø§Øª Ù…Ø®ØªÙ„ÙØ©

2. **recurring_motifs**: Ù‚Ø§Ø¦Ù…Ø© Ø¨Ù€ 2-3 Ø£ÙÙƒØ§Ø± Ø£Ùˆ Ø£Ù†Ù…Ø§Ø· Ø£Ùˆ Ù…ÙˆØ§Ù‚Ù Ù…ØªÙƒØ±Ø±Ø© (motifs) ØªØ¸Ù‡Ø± ÙÙŠ Ø§Ù„Ù†Øµ.
   Ù„ÙƒÙ„ motif:
   - "motif": ÙˆØµÙ Ø§Ù„Ù€ motif
   - "occurrences": Ø¹Ø¯Ø¯ Ù…Ø±Ø§Øª Ø§Ù„Ø¸Ù‡ÙˆØ±
   - "narrative_function": ÙˆØ¸ÙŠÙØªÙ‡ Ø§Ù„Ø³Ø±Ø¯ÙŠØ©

3. **central_themes_hinted_by_symbols**: Ø§Ø³ØªÙ†ØªØ§Ø¬ Ù…ÙˆØ¬Ø² Ø­ÙˆÙ„ Ø§Ù„Ø«ÙŠÙ…Ø§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ø§Ù„ØªÙŠ Ù‚Ø¯ ØªØ´ÙŠØ± Ø¥Ù„ÙŠÙ‡Ø§ Ù‡Ø°Ù‡ Ø§Ù„Ø±Ù…ÙˆØ² ÙˆØ§Ù„Ø£Ù†Ù…Ø§Ø· (Ù‚Ø§Ø¦Ù…Ø© Ù†ØµÙˆØµ).

4. **symbolic_networks**: Ø´Ø¨ÙƒØ§Øª Ø±Ù…Ø²ÙŠØ© (Ù‚Ø§Ø¦Ù…Ø© Ù…Ù† Ø§Ù„Ù‚ÙˆØ§Ù…ÙŠØ³)ØŒ ÙƒÙ„ Ù‚Ø§Ù…ÙˆØ³ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰:
   - "primary_symbol": Ø§Ù„Ø±Ù…Ø² Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
   - "related_symbols": Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø© (Ù‚Ø§Ø¦Ù…Ø©)
   - "thematic_connection": Ø§Ù„ØµÙ„Ø© Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹ÙŠØ©

5. **depth_score**: Ø¯Ø±Ø¬Ø© Ø¹Ù…Ù‚ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø±Ù…Ø²ÙŠ (0-10)

6. **consistency_score**: Ø¯Ø±Ø¬Ø© Ø§ØªØ³Ø§Ù‚ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø±Ù…Ø²ÙŠ (0-10)

Ø£Ø¹Ø¯ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© **Ø­ØµØ±ÙŠØ§Ù‹** Ø¨ØªÙ†Ø³ÙŠÙ‚ JSON ØµØ§Ù„Ø­ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ù…Ø°ÙƒÙˆØ±Ø© Ø£Ø¹Ù„Ø§Ù‡.
    `;
    
    const results = await this.geminiService.generateMultiModel<SymbolicAnalysisResults>({
      prompt,
      context: fullText.substring(0, 30000),
      model: GeminiModel.PRO,
      temperature: 0.7
    });
    
    const selected = this.resultSelector.selectBest(results, {
      preferredModels: [GeminiModel.PRO, GeminiModel.FLASH],
      validationFunction: (result) => 
        result.keySymbols &&
        Array.isArray(result.keySymbols) &&
        result.recurringMotifs &&
        Array.isArray(result.recurringMotifs)
    });
    
    return selected?.content || this.getDefaultSymbolicResults();
  }
  
  private async performStylisticAnalysis(
    fullText: string
  ): Promise<StylisticAnalysisResults> {
    const prompt = `
Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù†Øµ Ø§Ù„Ø³Ø±Ø¯ÙŠ Ø§Ù„Ù…Ø±ÙÙ‚ØŒ Ù‚Ù… Ø¨ØªØ­Ù„ÙŠÙ„ ÙˆØªÙ‚Ø¯ÙŠÙ… ØªÙ‚ÙŠÙŠÙ… Ù„Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ø£Ø³Ù„ÙˆØ¨ÙŠØ© Ø§Ù„ØªØ§Ù„ÙŠØ©:

1. **overall_tone_assessment**: ØªÙ‚ÙŠÙŠÙ… Ù„Ù„Ù†Ø¨Ø±Ø© Ø§Ù„Ø¹Ø§Ù…Ø© Ù„Ù„Ù†Øµ
   - "primary_tone": Ø§Ù„Ù†Ø¨Ø±Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
   - "secondary_tones": Ù†Ø¨Ø±Ø§Øª Ø«Ø§Ù†ÙˆÙŠØ© (Ù‚Ø§Ø¦Ù…Ø©)
   - "tone_consistency": Ø¯Ø±Ø¬Ø© Ø§ØªØ³Ø§Ù‚ Ø§Ù„Ù†Ø¨Ø±Ø© (0-10)
   - "explanation": Ø´Ø±Ø­ Ù…ÙˆØ¬Ø²

2. **language_complexity**: ØªÙ‚ÙŠÙŠÙ… Ù„Ù…Ø¯Ù‰ ØªØ¹Ù‚ÙŠØ¯ Ø§Ù„Ù„ØºØ©
   - "level": Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªØ¹Ù‚ÙŠØ¯ ("simple", "moderate", "complex", "highly_complex")
   - "readability_score": Ø¯Ø±Ø¬Ø© Ø§Ù„Ù‚Ø±Ø§Ø¡Ø© (0-10)
   - "vocabulary_richness": Ø«Ø±Ø§Ø¡ Ø§Ù„Ù…ÙØ±Ø¯Ø§Øª (0-10)

3. **pacing_impression**: Ø§Ù†Ø·Ø¨Ø§Ø¹ Ø¹Ø§Ù… Ø­ÙˆÙ„ Ø¥ÙŠÙ‚Ø§Ø¹ Ø§Ù„Ø³Ø±Ø¯
   - "overall_pacing": Ø§Ù„Ø¥ÙŠÙ‚Ø§Ø¹ Ø§Ù„Ø¹Ø§Ù… ("very_slow", "slow", "balanced", "fast", "very_fast")
   - "pacing_variation": Ø¯Ø±Ø¬Ø© Ø§Ù„ØªÙ†ÙˆØ¹ ÙÙŠ Ø§Ù„Ø¥ÙŠÙ‚Ø§Ø¹ (0-10)
   - "scene_length_distribution": ØªÙˆØ²ÙŠØ¹ Ø£Ø·ÙˆØ§Ù„ Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯ (Ù‚Ø§Ø¦Ù…Ø© Ø£Ø±Ù‚Ø§Ù… ØªÙ‚Ø±ÙŠØ¨ÙŠØ©)

4. **dialogue_style**: Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø­ÙˆÙ„ Ø£Ø³Ù„ÙˆØ¨ Ø§Ù„Ø­ÙˆØ§Ø±
   - "characterization": Ø¯Ø±Ø¬Ø© ØªÙ…ÙŠÙŠØ² Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ù…Ù† Ø®Ù„Ø§Ù„ Ø§Ù„Ø­ÙˆØ§Ø± (Ù†Øµ)
   - "naturalness": Ø·Ø¨ÙŠØ¹ÙŠØ© Ø§Ù„Ø­ÙˆØ§Ø± (0-10)
   - "effectiveness": ÙØ¹Ø§Ù„ÙŠØ© Ø§Ù„Ø­ÙˆØ§Ø± ÙÙŠ ØªØ·ÙˆÙŠØ± Ø§Ù„Ù‚ØµØ© (0-10)
   - "distinctiveness": ØªÙ…ÙŠØ² Ø£ØµÙˆØ§Øª Ø§Ù„Ø´Ø®ØµÙŠØ§Øª (0-10)

5. **descriptive_richness**: Ù…Ø¯Ù‰ Ø«Ø±Ø§Ø¡ Ø§Ù„ÙˆØµÙ
   - "visual_detail_level": Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¨ØµØ±ÙŠØ© (0-10)
   - "sensory_engagement": Ø¯Ø±Ø¬Ø© Ø§Ù„Ø§Ù†Ø®Ø±Ø§Ø· Ø§Ù„Ø­Ø³ÙŠ (0-10)
   - "atmospheric_quality": Ø¬ÙˆØ¯Ø© Ø§Ù„Ø£Ø¬ÙˆØ§Ø¡ (0-10)

6. **stylistic_consistency_impression**: Ø§Ù†Ø·Ø¨Ø§Ø¹ Ø¹Ø§Ù… Ø­ÙˆÙ„ Ù…Ø¯Ù‰ Ø§ØªØ³Ø§Ù‚ Ø§Ù„Ø£Ø³Ù„ÙˆØ¨
   - "consistency_score": Ø¯Ø±Ø¬Ø© Ø§Ù„Ø§ØªØ³Ø§Ù‚ (0-10)
   - "deviations": Ù‚Ø§Ø¦Ù…Ø© Ù…Ù† Ø§Ù„Ø§Ù†Ø­Ø±Ø§ÙØ§Øª Ø§Ù„Ù…Ù„Ø­ÙˆØ¸Ø© (Ø¥Ù† ÙˆØ¬Ø¯Øª)ØŒ ÙƒÙ„ Ø§Ù†Ø­Ø±Ø§Ù Ù‚Ø§Ù…ÙˆØ³ Ø¨Ù€:
     * "location": Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„ØªÙ‚Ø±ÙŠØ¨ÙŠ
     * "type": Ù†ÙˆØ¹ Ø§Ù„Ø§Ù†Ø­Ø±Ø§Ù
     * "description": ÙˆØµÙ Ø§Ù„Ø§Ù†Ø­Ø±Ø§Ù

Ø£Ø¹Ø¯ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© **Ø­ØµØ±ÙŠØ§Ù‹** Ø¨ØªÙ†Ø³ÙŠÙ‚ JSON ØµØ§Ù„Ø­ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ù…Ø°ÙƒÙˆØ±Ø© Ø£Ø¹Ù„Ø§Ù‡.
    `;
    
    const results = await this.geminiService.generateMultiModel<StylisticAnalysisResults>({
      prompt,
      context: fullText.substring(0, 30000),
      model: GeminiModel.PRO,
      temperature: 0.6
    });
    
    const selected = this.resultSelector.selectBest(results, {
      preferredModels: [GeminiModel.PRO, GeminiModel.FLASH],
      validationFunction: (result) => 
        result.overallToneAssessment &&
        result.languageComplexity &&
        result.pacingImpression
    });
    
    const stylisticResults = selected?.content || this.getDefaultStylisticResults();
    
    // Ø¥Ø¶Ø§ÙØ© ØªØ­Ù„ÙŠÙ„ TextBlob Ø¥Ù† Ø£Ù…ÙƒÙ† (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)
    try {
      // Ù‡Ø°Ø§ ÙŠØªØ·Ù„Ø¨ Ù…ÙƒØªØ¨Ø© TextBlob Ø£Ùˆ Ù…ÙƒØªØ¨Ø© Ù…Ø´Ø§Ø¨Ù‡Ø©
      // Ù„Ù„ØªØ¨Ø³ÙŠØ·ØŒ Ù†ØªØ±ÙƒÙ‡Ø§ ÙƒØ®ÙŠØ§Ø± Ø¥Ø¶Ø§ÙÙŠ
      // stylisticResults.textBlobSentiment = await this.analyzeWithTextBlob(fullText);
    } catch (error) {
      console.warn('TextBlob analysis skipped:', error);
    }
    
    return stylisticResults;
  }
  
  private getDefaultSymbolicResults(): SymbolicAnalysisResults {
    return {
      keySymbols: [],
      recurringMotifs: [],
      centralThemesHintedBySymbols: [],
      symbolicNetworks: [],
      depthScore: 0,
      consistencyScore: 0
    };
  }
  
  private getDefaultStylisticResults(): StylisticAnalysisResults {
    return {
      overallToneAssessment: {
        primaryTone: 'Unknown',
        secondaryTones: [],
        toneConsistency: 0,
        explanation: 'Analysis failed'
      },
      languageComplexity: {
        level: 'moderate',
        readabilityScore: 5,
        vocabularyRichness: 5
      },
      pacingImpression: {
        overallPacing: 'balanced',
        pacingVariation: 5,
        sceneLengthDistribution: []
      },
      dialogueStyle: {
        characterization: 'Unknown',
        naturalness: 5,
        effectiveness: 5,
        distinctiveness: 5
      },
      descriptiveRichness: {
        visualDetailLevel: 5,
        sensoryEngagement: 5,
        atmosphericQuality: 5
      },
      stylisticConsistencyImpression: {
        consistencyScore: 5,
        deviations: []
      }
    };
  }
  
  protected extractRequiredData(input: Station5Input): any {
    return {
      network: input.conflictNetwork,
      station4Output: input.station4Output,
      fullText: input.fullText
    };
  }
  
  protected getErrorFallback(): Station5Output {
    return {
      dynamicAnalysisResults: {
        eventTimeline: [],
        networkEvolutionAnalysis: {
          overallGrowthRate: 0,
          complexityProgression: [],
          densityProgression: [],
          criticalTransitionPoints: [],
          stabilityMetrics: {
            structuralStability: 0,
            characterStability: 0,
            conflictStability: 0
          }
        },
        characterDevelopmentTracking: new Map(),
        conflictProgressionTracking: new Map()
      },
      episodicIntegrationResults: {
        seriesStructure: {
          totalSeasons: 0,
          episodesPerSeason: 0,
          totalEpisodes: 0,
          recommendedRuntime: 0
        },
        seasonBreakdown: new Map(),
        episodeDistribution: new Map(),
        balanceReport: {
          overallBalance: 0,
          conflictDistributionScore: 0,
          characterAppearanceBalance: 0,
          intensityFlowScore: 0,
          recommendations: ['Analysis failed']
        }
      },
      symbolicAnalysisResults: this.getDefaultSymbolicResults(),
      stylisticAnalysisResults: this.getDefaultStylisticResults(),
      metadata: {
        analysisTimestamp: new Date(),
        status: 'Failed',
        analysisTime: 0
      }
    };
  }
}

Ø§Ù„Ù…Ø­Ø·Ø© Ø§Ù„Ø³Ø§Ø¯Ø³Ø©: Ø§Ù„ØªØ´Ø®ÙŠØµ ÙˆØ§Ù„Ø¹Ù„Ø§Ø¬
typescript// stations/station6/station6-diagnostics-treatment.ts

interface Station6Input {
  conflictNetwork: ConflictNetwork;
  station5Output: Station5Output;
}

interface Station6Output {
  diagnosticsReport: NetworkDiagnosticsReport;
  treatmentRecommendations: TreatmentRecommendations;
  advancedEfficiencyMetrics: AdvancedEfficiencyMetrics;
  metadata: {
    analysisTimestamp: Date;
    status: 'Success' | 'Partial' | 'Failed';
    analysisTime: number;
  };
}

interface NetworkDiagnosticsReport {
  structuralIssues: StructuralIssue[];
  isolatedCharacters: IsolatedCharacterIssue[];
  abandonedConflicts: AbandonedConflictIssue[];
  overloadedCharacters: OverloadedCharacterIssue[];
  weakConnections: WeakConnectionIssue[];
  redundancyIssues: RedundancyIssue[];
  overallHealthScore: number;
  criticalityLevel: 'healthy' | 'minor_issues' | 'moderate_issues' | 
                     'major_issues' | 'critical';
}

interface StructuralIssue {
  type: 'disconnected_components' | 'bottleneck_character' | 
        'dead_end_conflict' | 'circular_dependency' | 'other';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  affectedEntities: {
    characters?: string[];
    relationships?: string[];
    conflicts?: string[];
  };
  potentialImpact: string;
}

interface IsolatedCharacterIssue {
  characterId: string;
  characterName: string;
  isolationType: 'completely_isolated' | 'weakly_connected' | 
                 'relationship_only' | 'conflict_only';
  connectionCount: number;
  suggestedConnections: string[];
}

interface AbandonedConflictIssue {
  conflictId: string;
  conflictName: string;
  issueType: 'no_progression' | 'stuck_in_phase' | 'insufficient_involvement';
  lastActivity: Date | null;
  durationInCurrentPhase: number; // days
  suggestedActions: string[];
}

interface OverloadedCharacterIssue {
  characterId: string;
  characterName: string;
  involvementScore: number;
  conflictCount: number;
  relationshipCount: number;
  suggestedRedistribution: string[];
}

interface WeakConnectionIssue {
  connectionType: 'relationship' | 'conflict_link';
  connectionId: string;
  entities: string[];
  strengthScore: number;
  reasonForWeakness: string;
  suggestedStrengthening: string;
}

interface RedundancyIssue {
  type: 'duplicate_relationship' | 'overlapping_conflict';
  entities: string[];
  similarityScore: number;
  suggestedMerge: string;
}

interface TreatmentRecommendations {
  prioritizedActions: PrioritizedAction[];
  quickFixes: QuickFix[];
  structuralRevisions: StructuralRevision[];
  characterDevelopmentSuggestions: CharacterDevelopmentSuggestion[];
  conflictEnhancementStrategies: ConflictEnhancementStrategy[];
  consolidatedSummary: string;
}

interface PrioritizedAction {
  priority: 'critical' | 'high' | 'medium' | 'low';
  actionType: 'add' | 'remove' | 'modify' | 'merge';
  targetEntity: {
    type: 'character' | 'relationship' | 'conflict';
    id: string;
    name: string;
  };
  description: string;
  expectedImpact: string;
  effort: 'low' | 'medium' | 'high';
}

interface QuickFix {
  issueId: string;
  fixDescription: string;
  implementation: string;
  estimatedTime: string;
}

interface StructuralRevision {
  revisionType: 'add_bridge_character' | 'merge_conflicts' | 
                'split_overloaded_character' | 'create_subplot' | 'other';
  rationale: string;
  steps: string[];
  affectedElements: string[];
  expectedOutcome: string;
}

interface CharacterDevelopmentSuggestion {
  characterId: string;
  characterName: string;
  currentState: string;
  suggestedArc: string;
  keyMilestones: string[];
  relationshipsToAdd: string[];
  conflictsToInvolve: string[];
}

interface ConflictEnhancementStrategy {
  conflictId: string;
  conflictName: string;
  currentWeakness: string;
  enhancementApproach: string;
  stakesEscalation: string;
  charactersToInvolve: string[];
  phaseProgression: string;
}

interface AdvancedEfficiencyMetrics {
  postDiagnosticScore: number;
  improvementPotential: number;
  treatmentFeasibility: number;
  expectedOutcome: {
    optimisticScore: number;
    realisticScore: number;
    pessimisticScore: number;
  };
  riskAssessment: {
    implementationRisks: string[];
    narrativeCoherenceRisk: number;
    characterConsistencyRisk: number;
  };
}

/**
 * ÙˆØ­Ø¯Ø© ØªØ´Ø®ÙŠØµ Ø§Ù„Ø´Ø¨ÙƒØ©
 */
class NetworkDiagnostics {
  /**
   * ØªØ´ØºÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ´Ø®ÙŠØµØ§Øª
   */
  runAllDiagnostics(network: ConflictNetwork): NetworkDiagnosticsReport {
    const structuralIssues = this.diagnoseStructuralIssues(network);
    const isolatedCharacters = this.findIsolatedCharacters(network);
    const abandonedConflicts = this.findAbandonedConflicts(network);
    const overloadedCharacters = this.findOverloadedCharacters(network);
    const weakConnections = this.findWeakConnections(network);
    const redundancyIssues = this.findRedundancyIssues(network);
    
    // Ø­Ø³Ø§Ø¨ Ø¯Ø±Ø¬Ø© Ø§Ù„ØµØ­Ø© Ø§Ù„ÙƒÙ„ÙŠØ©
    const overallHealthScore = this.calculateHealthScore({
      structuralIssues,
      isolatedCharacters,
      abandonedConflicts,
      overloadedCharacters,
      weakConnections,
      redundancyIssues
    });
    
    const criticalityLevel = this.determineCriticalityLevel(overallHealthScore);
    
    return {
      structuralIssues,
      isolatedCharacters,
      abandonedConflicts,
      overloadedCharacters,
      weakConnections,
      redundancyIssues,
      overallHealthScore,
      criticalityLevel
    };
  }
  
  /**
   * ØªØ´Ø®ÙŠØµ Ø§Ù„Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„Ù‡ÙŠÙƒÙ„ÙŠØ©
   */
  private diagnoseStructuralIssues(
    network: ConflictNetwork
  ): StructuralIssue[] {
    const issues: StructuralIssue[] = [];
    
    // ÙØ­Øµ Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª Ø§Ù„Ù…Ù†ÙØµÙ„Ø©
    const components = this.findDisconnectedComponents(network);
    if (components.length > 1) {
      issues.push({
        type: 'disconnected_components',
        severity: 'high',
        description: `Network has ${components.length} disconnected components`,
        affectedEntities: {
          characters: components.flat()
        },
        potentialImpact: 'Story may feel fragmented with unrelated plot lines'
      });
    }
    
    // ÙØ­Øµ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ø¹Ù†Ù‚ Ø§Ù„Ø²Ø¬Ø§Ø¬ÙŠ (Bottleneck)
    const bottlenecks = this.findBottleneckCharacters(network);
    for (const charId of bottlenecks) {
      const char = network.characters.get(charId);
      issues.push({
        type: 'bottleneck_character',
        severity: 'medium',
        description: `Character '${char?.name}' is a critical bottleneck`,
        affectedEntities: { characters: [charId] },
        potentialImpact: 'Removing this character would fragment the network'
      });
    }
    
    // ÙØ­Øµ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„Ù…Ø³Ø¯ÙˆØ¯Ø©
    const deadEndConflicts = this.findDeadEndConflicts(network);
    for (const confId of deadEndConflicts) {
      const conf = network.conflicts.get(confId);
      issues.push({
        type: 'dead_end_conflict',
        severity: 'medium',
        description: `Conflict '${conf?.name}' has no clear progression path`,
        affectedEntities: { conflicts: [confId] },
        potentialImpact: 'Conflict may feel unresolved or purposeless'
      });
    }
    
    return issues;
  }
  
  private findDisconnectedComponents(
    network: ConflictNetwork
  ): string[][] {
    const visited = new Set<string>();
    const components: string[][] = [];
    
    const dfs = (charId: string, component: string[]) => {
      if (visited.has(charId)) return;
      visited.add(charId);
      component.push(charId);
      
      // Ø²ÙŠØ§Ø±Ø© Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø©
      for (const rel of network.relationships.values()) {
        if (rel.source === charId && !visited.has(rel.target)) {
          dfs(rel.target, component);
        } else if (rel.target === charId && !visited.has(rel.source)) {
          dfs(rel.source, component);
        }
      }
    };
    
    for (const charId of network.characters.keys()) {
      if (!visited.has(charId)) {
        const component: string[] = [];
        dfs(charId, component);
        components.push(component);
      }
    }
    
    return components;
  }
  
  private findBottleneckCharacters(network: ConflictNetwork): string[] {
    const bottlenecks: string[] = [];
    
    for (const charId of network.characters.keys()) {
      // Ø­Ø³Ø§Ø¨ Articulation Point (Ù†Ù‚Ø·Ø© Ø§Ù„Ù…ÙØµÙ„)
      if (this.isArticulationPoint(network, charId)) {
        bottlenecks.push(charId);
      }
    }
    
    return bottlenecks;
  }
  
  private isArticulationPoint(
    network: ConflictNetwork,
    charId: string
  ): boolean {
    // Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø¨Ø³ÙŠØ·Ø© Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù†Ù‚Ø§Ø· Ø§Ù„Ù…ÙØµÙ„
    // ÙÙŠ Ø´Ø¨ÙƒØ© Ø­Ù‚ÙŠÙ‚ÙŠØ©ØŒ ÙŠØ¬Ø¨ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Tarjan
    
    const componentsBefore = this.findDisconnectedComponents(network).length;
    
    // Ù…Ø­Ø§ÙƒØ§Ø© Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø´Ø®ØµÙŠØ©
    const tempNetwork = this.createNetworkWithoutCharacter(network, charId);
    const componentsAfter = this.findDisconnectedComponents(tempNetwork).length;
    
    return componentsAfter > componentsBefore;
  }
  
  private createNetworkWithoutCharacter(
    network: ConflictNetwork,
    charId: string
  ): ConflictNetwork {
    const tempNetwork: ConflictNetwork = {
      ...network,
      characters: new Map(network.characters),
      relationships: new Map(network.relationships),
      conflicts: new Map(network.conflicts),
      snapshots: [],
      metadata: {},
      addCharacter: () => {},
      addRelationship: () => {},
      addConflict: () => {},
      createSnapshot: () => {}
    };
    
    tempNetwork.characters.delete(charId);
    
    // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø©
    for (const [relId, rel] of network.relationships) {
      if (rel.source === charId || rel.target === charId) {
        tempNetwork.relationships.


tempNetwork.relationships.delete(relId);
      }
    }
    
    return tempNetwork;
  }
  
  private findDeadEndConflicts(network: ConflictNetwork): string[] {
    const deadEnds: string[] = [];
    
    for (const [confId, conflict] of network.conflicts) {
      // ØµØ±Ø§Ø¹ Ù…Ø³Ø¯ÙˆØ¯ Ø¥Ø°Ø§ ÙƒØ§Ù† ÙÙŠ Ù…Ø±Ø­Ù„Ø© Ø±Ø§ÙƒØ¯Ø© Ø·ÙˆÙŠÙ„Ø© Ø£Ùˆ Ù„Ø§ ØªÙˆØ¬Ø¯ Ù„Ù‡ Ø¹Ù„Ø§Ù‚Ø§Øª Ø¯Ø§Ø¹Ù…Ø©
      const isStagnant = conflict.phase === ConflictPhase.STALEMATE || 
                        conflict.phase === ConflictPhase.LATENT;
      
      const hasNoRelatedRelationships = !conflict.relatedRelationships || 
                                       conflict.relatedRelationships.length === 0;
      
      const hasMinimalCharacters = conflict.involvedCharacters.length < 2;
      
      if (isStagnant && (hasNoRelatedRelationships || hasMinimalCharacters)) {
        deadEnds.push(confId);
      }
    }
    
    return deadEnds;
  }
  
  /**
   * ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ø¹Ø²ÙˆÙ„Ø©
   */
  private findIsolatedCharacters(network: ConflictNetwork): IsolatedCharacterIssue[] {
    const issues: IsolatedCharacterIssue[] = [];
    
    for (const [charId, char] of network.characters) {
      // Ø­Ø³Ø§Ø¨ Ø¹Ø¯Ø¯ Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª
      let relationshipCount = 0;
      let conflictCount = 0;
      
      // Ø¹Ø¯ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
      for (const rel of network.relationships.values()) {
        if (rel.source === charId || rel.target === charId) {
          relationshipCount++;
        }
      }
      
      // Ø¹Ø¯ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
      for (const conflict of network.conflicts.values()) {
        if (conflict.involvedCharacters.includes(charId)) {
          conflictCount++;
        }
      }
      
      const totalConnections = relationshipCount + conflictCount;
      
      // ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„Ø¹Ø²Ù„Ø©
      let isolationType: IsolatedCharacterIssue['isolationType'] = 'completely_isolated';
      if (totalConnections === 0) {
        isolationType = 'completely_isolated';
      } else if (totalConnections <= 2) {
        isolationType = 'weakly_connected';
      } else if (conflictCount === 0) {
        isolationType = 'relationship_only';
      } else if (relationshipCount === 0) {
        isolationType = 'conflict_only';
      } else {
        continue; // Ù„ÙŠØ³Øª Ù…Ø¹Ø²ÙˆÙ„Ø©
      }
      
      // Ø§Ù‚ØªØ±Ø§Ø­ Ø§ØªØµØ§Ù„Ø§Øª
      const suggestedConnections = this.suggestConnectionsForCharacter(
        network, charId, char
      );
      
      issues.push({
        characterId: charId,
        characterName: char.name,
        isolationType,
        connectionCount: totalConnections,
        suggestedConnections
      });
    }
    
    return issues;
  }
  
  private suggestConnectionsForCharacter(
    network: ConflictNetwork,
    charId: string,
    char: Character
  ): string[] {
    const suggestions: string[] = [];
    
    // Ø§Ù‚ØªØ±Ø§Ø­ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø°Ø§Øª Ø§Ù„Ø³Ù…Ø§Øª Ø§Ù„Ù…Ø´Ø§Ø¨Ù‡Ø©
    const similarChars = this.findSimilarCharacters(network, char);
    if (similarChars.length > 0) {
      suggestions.push(`Ø¥Ø¶Ø§ÙØ© Ø¹Ù„Ø§Ù‚Ø© Ù…Ø¹ Ø´Ø®ØµÙŠØ§Øª Ù…Ø´Ø§Ø¨Ù‡Ø©: ${similarChars.slice(0, 2).join(', ')}`);
    }
    
    // Ø§Ù‚ØªØ±Ø§Ø­ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ© ÙÙŠ ØµØ±Ø§Ø¹Ø§Øª Ù…ÙˆØ¬ÙˆØ¯Ø©
    const relevantConflicts = this.findRelevantConflicts(network, char);
    if (relevantConflicts.length > 0) {
      suggestions.push(`Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ© ÙÙŠ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª: ${relevantConflicts.slice(0, 2).join(', ')}`);
    }
    
    return suggestions;
  }
  
  private findSimilarCharacters(
    network: ConflictNetwork,
    targetChar: Character
  ): string[] {
    const similar: string[] = [];
    
    for (const [charId, char] of network.characters) {
      if (charId === targetChar.id) continue;
      
      // Ù…Ù‚Ø§Ø±Ù†Ø© Ø¨Ø³ÙŠØ·Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø³Ù…Ø§Øª
      const targetTraits = targetChar.profile?.personalityTraits?.toLowerCase() || '';
      const charTraits = char.profile?.personalityTraits?.toLowerCase() || '';
      
      if (this.calculateSimilarity(targetTraits, charTraits) > 0.3) {
        similar.push(char.name);
      }
    }
    
    return similar;
  }
  
  private calculateSimilarity(str1: string, str2: string): number {
    if (!str1 || !str2) return 0;
    
    const words1 = new Set(str1.split(/\s+/));
    const words2 = new Set(str2.split(/\s+/));
    
    const intersection = new Set([...words1].filter(x => words2.has(x)));
    const union = new Set([...words1, ...words2]);
    
    return union.size > 0 ? intersection.size / union.size : 0;
  }
  
  private findRelevantConflicts(
    network: ConflictNetwork,
    char: Character
  ): string[] {
    const relevant: string[] = [];
    
    // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† ØµØ±Ø§Ø¹Ø§Øª ØªØªØ¹Ù„Ù‚ Ø¨Ø£Ù‡Ø¯Ø§Ù Ø§Ù„Ø´Ø®ØµÙŠØ© Ø£Ùˆ ØµÙØ§ØªÙ‡Ø§
    const charGoals = char.profile?.motivationsGoals?.toLowerCase() || '';
    
    for (const [confId, conflict] of network.conflicts) {
      const confDesc = conflict.description.toLowerCase();
      
      if (this.calculateSimilarity(charGoals, confDesc) > 0.2) {
        relevant.push(conflict.name);
      }
    }
    
    return relevant;
  }
  
  /**
   * ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„Ù…Ù‡Ø¬ÙˆØ±Ø©
   */
  private findAbandonedConflicts(
    network: ConflictNetwork
  ): AbandonedConflictIssue[] {
    const issues: AbandonedConflictIssue[] = [];
    const now = new Date();
    
    for (const [confId, conflict] of network.conflicts) {
      // ØªØ­Ø¯ÙŠØ¯ Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ØµØ±Ø§Ø¹ Ù…Ù‡Ø¬ÙˆØ±Ø§Ù‹
      const lastActivity = conflict.timestamps && conflict.timestamps.length > 0
        ? conflict.timestamps[conflict.timestamps.length - 1]
        : null;
      
      const durationInPhase = lastActivity
        ? Math.floor((now.getTime() - lastActivity.getTime()) / (1000 * 60 * 60 * 24))
        : Number.MAX_SAFE_INTEGER;
      
      let issueType: AbandonedConflictIssue['issueType'] | null = null;
      
      // Ù„Ø§ ØªÙ‚Ø¯Ù…
      if (!conflict.timestamps || conflict.timestamps.length <= 1) {
        issueType = 'no_progression';
      }
      // Ø¹Ø§Ù„Ù‚ ÙÙŠ Ù…Ø±Ø­Ù„Ø©
      else if (durationInPhase > 30 && 
               (conflict.phase === ConflictPhase.STALEMATE || 
                conflict.phase === ConflictPhase.LATENT)) {
        issueType = 'stuck_in_phase';
      }
      // Ù…Ø´Ø§Ø±ÙƒØ© ØºÙŠØ± ÙƒØ§ÙÙŠØ©
      else if (conflict.involvedCharacters.length < 2) {
        issueType = 'insufficient_involvement';
      }
      
      if (issueType) {
        const suggestions = this.generateConflictRevivalSuggestions(
          network, conflict, issueType
        );
        
        issues.push({
          conflictId: confId,
          conflictName: conflict.name,
          issueType,
          lastActivity,
          durationInCurrentPhase: durationInPhase,
          suggestedActions: suggestions
        });
      }
    }
    
    return issues;
  }
  
  private generateConflictRevivalSuggestions(
    network: ConflictNetwork,
    conflict: Conflict,
    issueType: AbandonedConflictIssue['issueType']
  ): string[] {
    const suggestions: string[] = [];
    
    switch (issueType) {
      case 'no_progression':
        suggestions.push('Ø¥Ø¶Ø§ÙØ© Ù†Ù‚Ø§Ø· ØªØ­ÙˆÙ„ Ù…Ø­ÙˆØ±ÙŠØ© Ù„ØªØ­Ø±ÙŠÙƒ Ø§Ù„ØµØ±Ø§Ø¹');
        suggestions.push('ØªØµØ¹ÙŠØ¯ Ø§Ù„Ù…Ø®Ø§Ø·Ø± Ø£Ùˆ ØªØºÙŠÙŠØ± Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ© Ø§Ù„Ù‚ÙˆÙ‰');
        break;
        
      case 'stuck_in_phase':
        suggestions.push(`ØªØ­ÙˆÙŠÙ„ Ø§Ù„ØµØ±Ø§Ø¹ Ù…Ù† Ù…Ø±Ø­Ù„Ø© ${conflict.phase.name} Ø¥Ù„Ù‰ Ù…Ø±Ø­Ù„Ø© Ø£ÙƒØ«Ø± Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©`);
        suggestions.push('Ø¥Ø¯Ø®Ø§Ù„ Ø¹Ù†ØµØ± Ø®Ø§Ø±Ø¬ÙŠ Ù„ÙƒØ³Ø± Ø§Ù„Ø¬Ù…ÙˆØ¯');
        break;
        
      case 'insufficient_involvement':
        suggestions.push('Ø¥Ø¶Ø§ÙØ© Ø´Ø®ØµÙŠØ§Øª Ø¥Ø¶Ø§ÙÙŠØ© Ù„Ù„ØµØ±Ø§Ø¹');
        suggestions.push('Ø±Ø¨Ø· Ø§Ù„ØµØ±Ø§Ø¹ Ø¨Ø¹Ù„Ø§Ù‚Ø§Øª Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©');
        break;
    }
    
    return suggestions;
  }
  
  /**
   * ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ø­Ù…Ù„Ø© Ø¨Ø´ÙƒÙ„ Ø²Ø§Ø¦Ø¯
   */
  private findOverloadedCharacters(
    network: ConflictNetwork
  ): OverloadedCharacterIssue[] {
    const issues: OverloadedCharacterIssue[] = [];
    
    // Ø­Ø³Ø§Ø¨ Ù…ØªÙˆØ³Ø· Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ©
    const avgConflictsPerChar = network.conflicts.size / 
                               (network.characters.size || 1);
    const avgRelationsPerChar = network.relationships.size * 2 / 
                               (network.characters.size || 1);
    
    for (const [charId, char] of network.characters) {
      let conflictCount = 0;
      let relationshipCount = 0;
      
      // Ø¹Ø¯ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
      for (const conflict of network.conflicts.values()) {
        if (conflict.involvedCharacters.includes(charId)) {
          conflictCount++;
        }
      }
      
      // Ø¹Ø¯ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
      for (const rel of network.relationships.values()) {
        if (rel.source === charId || rel.target === charId) {
          relationshipCount++;
        }
      }
      
      // Ø­Ø³Ø§Ø¨ Ø¯Ø±Ø¬Ø© Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ©
      const involvementScore = (conflictCount / (avgConflictsPerChar || 1)) +
                              (relationshipCount / (avgRelationsPerChar || 1));
      
      // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ© Ø£Ø¹Ù„Ù‰ Ø¨ÙƒØ«ÙŠØ± Ù…Ù† Ø§Ù„Ù…ØªÙˆØ³Ø·
      if (involvementScore > 2.5) {
        const suggestions = this.generateLoadReductionSuggestions(
          network, char, conflictCount, relationshipCount
        );
        
        issues.push({
          characterId: charId,
          characterName: char.name,
          involvementScore,
          conflictCount,
          relationshipCount,
          suggestedRedistribution: suggestions
        });
      }
    }
    
    return issues;
  }
  
  private generateLoadReductionSuggestions(
    network: ConflictNetwork,
    char: Character,
    conflictCount: number,
    relationshipCount: number
  ): string[] {
    const suggestions: string[] = [];
    
    if (conflictCount > 5) {
      suggestions.push('ØªÙˆØ²ÙŠØ¹ Ø¨Ø¹Ø¶ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø¹Ù„Ù‰ Ø´Ø®ØµÙŠØ§Øª Ø«Ø§Ù†ÙˆÙŠØ©');
      suggestions.push('Ø¯Ù…Ø¬ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„Ù…ØªØ´Ø§Ø¨Ù‡Ø© Ù„ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø¹Ø¨Ø¡');
    }
    
    if (relationshipCount > 8) {
      suggestions.push('Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª Ø§Ù„Ø¶Ø¹ÙŠÙØ© Ø£Ùˆ ØºÙŠØ± Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©');
      suggestions.push('ØªØ¨Ø³ÙŠØ· Ø´Ø¨ÙƒØ© Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª Ø­ÙˆÙ„ Ù‡Ø°Ù‡ Ø§Ù„Ø´Ø®ØµÙŠØ©');
    }
    
    suggestions.push('Ø¥Ù†Ø´Ø§Ø¡ Ø´Ø®ØµÙŠØ© Ø¯Ø§Ø¹Ù…Ø© Ù„ØªØ®ÙÙŠÙ Ø¨Ø¹Ø¶ Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠØ§Øª Ø§Ù„Ø³Ø±Ø¯ÙŠØ©');
    
    return suggestions;
  }
  
  /**
   * ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª Ø§Ù„Ø¶Ø¹ÙŠÙØ©
   */
  private findWeakConnections(
    network: ConflictNetwork
  ): WeakConnectionIssue[] {
    const issues: WeakConnectionIssue[] = [];
    
    // ÙØ­Øµ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª Ø§Ù„Ø¶Ø¹ÙŠÙØ©
    for (const [relId, rel] of network.relationships) {
      if (rel.strength < 3) {
        const source = network.characters.get(rel.source);
        const target = network.characters.get(rel.target);
        
        issues.push({
          connectionType: 'relationship',
          connectionId: relId,
          entities: [source?.name || rel.source, target?.name || rel.target],
          strengthScore: rel.strength,
          reasonForWeakness: 'Ø¹Ù„Ø§Ù‚Ø© Ø¶Ø¹ÙŠÙØ© Ø§Ù„Ø´Ø¯Ø© (< 3)',
          suggestedStrengthening: 'ØªØ¹Ù…ÙŠÙ‚ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø© Ù…Ù† Ø®Ù„Ø§Ù„ Ù…Ø´Ø§Ù‡Ø¯ Ù…Ø´ØªØ±ÙƒØ© Ø£Ùˆ ØµØ±Ø§Ø¹Ø§Øª Ù…ØªÙ‚Ø§Ø·Ø¹Ø©'
        });
      }
    }
    
    // ÙØ­Øµ Ø±ÙˆØ§Ø¨Ø· Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„Ø¶Ø¹ÙŠÙØ©
    for (const [confId, conflict] of network.conflicts) {
      if (conflict.strength < 4) {
        issues.push({
          connectionType: 'conflict_link',
          connectionId: confId,
          entities: conflict.involvedCharacters.map(id => 
            network.characters.get(id)?.name || id
          ),
          strengthScore: conflict.strength,
          reasonForWeakness: 'ØµØ±Ø§Ø¹ Ù…Ù†Ø®ÙØ¶ Ø§Ù„Ø´Ø¯Ø© (< 4)',
          suggestedStrengthening: 'Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ù…Ø®Ø§Ø·Ø± ÙˆØªØµØ¹ÙŠØ¯ Ø§Ù„ØªÙˆØªØ± ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„ØµØ±Ø§Ø¹'
        });
      }
    }
    
    return issues;
  }
  
  /**
   * ØªØ­Ø¯ÙŠØ¯ Ù‚Ø¶Ø§ÙŠØ§ Ø§Ù„ØªÙƒØ±Ø§Ø±
   */
  private findRedundancyIssues(
    network: ConflictNetwork
  ): RedundancyIssue[] {
    const issues: RedundancyIssue[] = [];
    
    // ÙØ­Øµ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª Ø§Ù„Ù…ÙƒØ±Ø±Ø©
    const relationships = Array.from(network.relationships.values());
    for (let i = 0; i < relationships.length; i++) {
      for (let j = i + 1; j < relationships.length; j++) {
        const r1 = relationships[i];
        const r2 = relationships[j];
        
        // Ù†ÙØ³ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª ÙˆÙ†ÙˆØ¹ Ù…Ø´Ø§Ø¨Ù‡
        const samePair = (r1.source === r2.source && r1.target === r2.target) ||
                        (r1.source === r2.target && r1.target === r2.source);
        
        if (samePair && r1.type === r2.type) {
          issues.push({
            type: 'duplicate_relationship',
            entities: [r1.id, r2.id],
            similarityScore: 0.9,
            suggestedMerge: `Ø¯Ù…Ø¬ Ø§Ù„Ø¹Ù„Ø§Ù‚ØªÙŠÙ† ÙÙŠ Ø¹Ù„Ø§Ù‚Ø© ÙˆØ§Ø­Ø¯Ø© Ø£Ù‚ÙˆÙ‰`
          });
        }
      }
    }
    
    // ÙØ­Øµ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„Ù…ØªØ¯Ø§Ø®Ù„Ø©
    const conflicts = Array.from(network.conflicts.values());
    for (let i = 0; i < conflicts.length; i++) {
      for (let j = i + 1; j < conflicts.length; j++) {
        const c1 = conflicts[i];
        const c2 = conflicts[j];
        
        const charOverlap = new Set(c1.involvedCharacters.filter(
          id => c2.involvedCharacters.includes(id)
        ));
        
        const overlapRatio = charOverlap.size / 
          Math.min(c1.involvedCharacters.length, c2.involvedCharacters.length);
        
        if (overlapRatio > 0.7 && c1.subject === c2.subject) {
          issues.push({
            type: 'overlapping_conflict',
            entities: [c1.id, c2.id],
            similarityScore: overlapRatio,
            suggestedMerge: `Ø¯Ù…Ø¬ Ø§Ù„ØµØ±Ø§Ø¹ÙŠÙ† ÙÙŠ ØµØ±Ø§Ø¹ ÙˆØ§Ø­Ø¯ Ø£ÙƒØ«Ø± ØªØ¹Ù‚ÙŠØ¯Ø§Ù‹`
          });
        }
      }
    }
    
    return issues;
  }
  
  /**
   * Ø­Ø³Ø§Ø¨ Ø¯Ø±Ø¬Ø© Ø§Ù„ØµØ­Ø© Ø§Ù„ÙƒÙ„ÙŠØ©
   */
  private calculateHealthScore(diagnostics: {
    structuralIssues: StructuralIssue[];
    isolatedCharacters: IsolatedCharacterIssue[];
    abandonedConflicts: AbandonedConflictIssue[];
    overloadedCharacters: OverloadedCharacterIssue[];
    weakConnections: WeakConnectionIssue[];
    redundancyIssues: RedundancyIssue[];
  }): number {
    let score = 100;
    
    // Ø®ØµÙ… Ø§Ù„Ù†Ù‚Ø§Ø· Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù†ÙˆØ¹ ÙˆØ´Ø¯Ø© Ø§Ù„Ù…Ø´Ø§ÙƒÙ„
    for (const issue of diagnostics.structuralIssues) {
      switch (issue.severity) {
        case 'critical': score -= 15; break;
        case 'high': score -= 10; break;
        case 'medium': score -= 5; break;
        case 'low': score -= 2; break;
      }
    }
    
    score -= diagnostics.isolatedCharacters.length * 5;
    score -= diagnostics.abandonedConflicts.length * 7;
    score -= diagnostics.overloadedCharacters.length * 4;
    score -= diagnostics.weakConnections.length * 2;
    score -= diagnostics.redundancyIssues.length * 3;
    
    return Math.max(0, score);
  }
  
  /**
   * ØªØ­Ø¯ÙŠØ¯ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø®Ø·ÙˆØ±Ø©
   */
  private determineCriticalityLevel(
    healthScore: number
  ): NetworkDiagnosticsReport['criticalityLevel'] {
    if (healthScore >= 85) return 'healthy';
    if (healthScore >= 70) return 'minor_issues';
    if (healthScore >= 50) return 'moderate_issues';
    if (healthScore >= 30) return 'major_issues';
    return 'critical';
  }
}

/**
 * Ù…Ø­Ø±Ùƒ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø§Ù„Ø¹Ù„Ø§Ø¬
 */
class TreatmentStrategies {
  constructor(
    private network: ConflictNetwork,
    private diagnostics: NetworkDiagnosticsReport
  ) {}
  
  /**
   * ØªØ­Ù„ÙŠÙ„ ÙˆØªÙˆØµÙŠØ© Ø¨Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø§Ù„Ø¹Ù„Ø§Ø¬
   */
  analyzeAndRecommendTreatments(): TreatmentRecommendations {
    // Ø¬Ù…Ø¹ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ù…Ù† Ø§Ù„Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ù…Ø®ØªÙ„ÙØ©
    const prioritizedActions = this.generatePrioritizedActions();
    const quickFixes = this.identifyQuickFixes();
    const structuralRevisions = this.planStructuralRevisions();
    const characterSuggestions = this.developCharacterSuggestions();
    const conflictStrategies = this.enhanceConflictStrategies();
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ø®Øµ Ù…ÙˆØ­Ø¯
    const consolidatedSummary = this.createConsolidatedSummary({
      prioritizedActions,
      quickFixes,
      structuralRevisions,
      characterSuggestions,
      conflictStrategies
    });
    
    return {
      prioritizedActions,
      quickFixes,
      structuralRevisions,
      characterDevelopmentSuggestions: characterSuggestions,
      conflictEnhancementStrategies: conflictStrategies,
      consolidatedSummary
    };
  }
  
  private generatePrioritizedActions(): PrioritizedAction[] {
    const actions: PrioritizedAction[] = [];
    
    // Ù…Ù† Ø§Ù„Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„Ù‡ÙŠÙƒÙ„ÙŠØ© Ø§Ù„Ø­Ø±Ø¬Ø©
    for (const issue of this.diagnostics.structuralIssues) {
      if (issue.severity === 'critical' || issue.severity === 'high') {
        actions.push({
          priority: issue.severity === 'critical' ? 'critical' : 'high',
          actionType: 'modify',
          targetEntity: {
            type: 'conflict',
            id: issue.affectedEntities.conflicts?.[0] || 'unknown',
            name: 'Structural Issue'
          },
          description: issue.description,
          expectedImpact: issue.potentialImpact,
          effort: 'high'
        });
      }
    }
    
    // Ù…Ù† Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ø¹Ø²ÙˆÙ„Ø©
    for (const isolated of this.diagnostics.isolatedCharacters) {
      if (isolated.isolationType === 'completely_isolated') {
        actions.push({
          priority: 'high',
          actionType: 'add',
          targetEntity: {
            type: 'character',
            id: isolated.characterId,
            name: isolated.characterName
          },
          description: `Ø¯Ù…Ø¬ Ø§Ù„Ø´Ø®ØµÙŠØ© Ø§Ù„Ù…Ø¹Ø²ÙˆÙ„Ø© '${isolated.characterName}' ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©`,
          expectedImpact: 'ØªØ­Ø³ÙŠÙ† Ø§Ù„ØªÙ…Ø§Ø³Ùƒ Ø§Ù„Ø³Ø±Ø¯ÙŠ ÙˆØ¥Ø«Ø±Ø§Ø¡ Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ§Øª',
          effort: 'medium'
        });
      }
    }
    
    // Ù…Ù† Ø§Ù„ØªÙƒØ±Ø§Ø±Ø§Øª
    for (const redundancy of this.diagnostics.redundancyIssues) {
      actions.push({
        priority: 'medium',
        actionType: 'merge',
        targetEntity: {
          type: redundancy.type === 'duplicate_relationship' ? 'relationship' : 'conflict',
          id: redundancy.entities[0],
          name: 'Redundant Entity'
        },
        description: redundancy.suggestedMerge,
        expectedImpact: 'ØªØ¨Ø³ÙŠØ· Ø§Ù„Ø¨Ù†ÙŠØ© ÙˆØªÙ‚Ù„ÙŠÙ„ Ø§Ù„ØªØ¹Ù‚ÙŠØ¯ ØºÙŠØ± Ø§Ù„Ø¶Ø±ÙˆØ±ÙŠ',
        effort: 'low'
      });
    }
    
    // ØªØ±ØªÙŠØ¨ Ø­Ø³Ø¨ Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ©
    const priorityOrder = { critical: 0, high: 1, medium: 2, low: 3 };
    actions.sort((a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]);
    
    return actions;
  }
  
  private identifyQuickFixes(): QuickFix[] {
    const fixes: QuickFix[] = [];
    
    // Ø¥ØµÙ„Ø§Ø­Ø§Øª Ø³Ø±ÙŠØ¹Ø© Ù„Ù„Ø§ØªØµØ§Ù„Ø§Øª Ø§Ù„Ø¶Ø¹ÙŠÙØ©
    for (const weak of this.diagnostics.weakConnections) {
      fixes.push({
        issueId: weak.connectionId,
        fixDescription: weak.suggestedStrengthening,
        implementation: weak.connectionType === 'relationship'
          ? 'Ø²ÙŠØ§Ø¯Ø© Ù‚ÙŠÙ…Ø© strength ÙÙŠ ÙƒØ§Ø¦Ù† Ø§Ù„Ø¹Ù„Ø§Ù‚Ø©'
          : 'ØªØµØ¹ÙŠØ¯ Ù…Ø±Ø­Ù„Ø© Ø§Ù„ØµØ±Ø§Ø¹ ÙˆØ²ÙŠØ§Ø¯Ø© Ø§Ù„Ù…Ø®Ø§Ø·Ø±',
        estimatedTime: '15-30 Ø¯Ù‚ÙŠÙ‚Ø©'
      });
    }
    
    return fixes;
  }
  
  private planStructuralRevisions(): StructuralRevision[] {
    const revisions: StructuralRevision[] = [];
    
    // Ù…Ø±Ø§Ø¬Ø¹Ø§Øª Ù„Ù„Ù…ÙƒÙˆÙ†Ø§Øª Ø§Ù„Ù…Ù†ÙØµÙ„Ø©
    const disconnectedIssues = this.diagnostics.structuralIssues.filter(
      i => i.type === 'disconnected_components'
    );
    
    for (const issue of disconnectedIssues) {
      revisions.push({
        revisionType: 'add_bridge_character',
        rationale: 'Ø±Ø¨Ø· Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª Ø§Ù„Ù…Ù†ÙØµÙ„Ø© Ù„ØªØ­Ø³ÙŠÙ† ØªÙ…Ø§Ø³Ùƒ Ø§Ù„Ø´Ø¨ÙƒØ©',
        steps: [
          'ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª Ø§Ù„Ù…Ù†ÙØµÙ„Ø©',
          'Ø¥Ù†Ø´Ø§Ø¡ Ø´Ø®ØµÙŠØ© Ø¬Ø³Ø± Ø¬Ø¯ÙŠØ¯Ø© Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø´Ø®ØµÙŠØ© Ù…ÙˆØ¬ÙˆØ¯Ø©',
          'Ø¥Ø¶Ø§ÙØ© Ø¹Ù„Ø§Ù‚Ø§Øª Ø¨ÙŠÙ† Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª',
          'Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªØ­Ø³Ù† Ø§Ù„ØªÙ…Ø§Ø³Ùƒ'
        ],
        affectedElements: issue.affectedEntities.characters || [],
        expectedOutcome: 'Ø´Ø¨ÙƒØ© Ù…ÙˆØ­Ø¯Ø© Ø¨Ø¯ÙˆÙ† Ù…ÙƒÙˆÙ†Ø§Øª Ù…Ù†ÙØµÙ„Ø©'
      });
    }
    
    // Ù…Ø±Ø§Ø¬Ø¹Ø§Øª Ù„Ù„ØªÙƒØ±Ø§Ø±Ø§Øª
    if (this.diagnostics.redundancyIssues.length > 3) {
      revisions.push({
        revisionType: 'merge_conflicts',
        rationale: 'ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„ØªÙƒØ±Ø§Ø± ÙˆØªØ¨Ø³ÙŠØ· Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„Ø³Ø±Ø¯ÙŠØ©',
        steps: [
          'Ù…Ø±Ø§Ø¬Ø¹Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„Ù…ØªØ¯Ø§Ø®Ù„Ø©',
          'ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ù„ÙƒÙ„ ØµØ±Ø§Ø¹',
          'Ø¯Ù…Ø¬ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„Ù…ØªØ´Ø§Ø¨Ù‡Ø©',
          'Ø¥Ø¹Ø§Ø¯Ø© ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ©'
        ],
        affectedElements: this.diagnostics.redundancyIssues.flatMap(r => r.entities),
        expectedOutcome: 'Ø¨Ù†ÙŠØ© ØµØ±Ø§Ø¹ Ø£ÙƒØ«Ø± ÙˆØ¶ÙˆØ­Ø§Ù‹ ÙˆØªØ±ÙƒÙŠØ²Ø§Ù‹'
      });
    }
    
    // Ù…Ø±Ø§Ø¬Ø¹Ø§Øª Ù„Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ø­Ù…Ù„Ø© Ø¨Ø´ÙƒÙ„ Ø²Ø§Ø¦Ø¯
    if (this.diagnostics.overloadedCharacters.length > 0) {
      revisions.push({
        revisionType: 'split_overloaded_character',
        rationale: 'ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠØ§Øª Ø§Ù„Ø³Ø±Ø¯ÙŠØ© Ø¨Ø´ÙƒÙ„ Ø£ÙƒØ«Ø± ØªÙˆØ§Ø²Ù†Ø§Ù‹',
        steps: [
          'ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ø¯ÙˆØ§Ø± Ø§Ù„Ù…ØªØ¹Ø¯Ø¯Ø© Ù„Ù„Ø´Ø®ØµÙŠØ© Ø§Ù„Ù…Ø­Ù…Ù„Ø©',
          'Ø¥Ù†Ø´Ø§Ø¡ Ø´Ø®ØµÙŠØ§Øª Ø¯Ø§Ø¹Ù…Ø© Ø¬Ø¯ÙŠØ¯Ø©',
          'ØªÙˆØ²ÙŠØ¹ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª ÙˆØ§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª',
          'Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„ØªÙ…Ø§Ø³Ùƒ Ø§Ù„Ø³Ø±Ø¯ÙŠ'
        ],
        affectedElements: this.diagnostics.overloadedCharacters.map(o => o.characterId),
        expectedOutcome: 'ØªÙˆØ²ÙŠØ¹ Ø£ÙƒØ«Ø± ØªÙˆØ§Ø²Ù†Ø§Ù‹ Ù„Ù„Ù…Ø´Ø§Ø±ÙƒØ© Ø¹Ø¨Ø± Ø§Ù„Ø´Ø®ØµÙŠØ§Øª'
      });
    }
    
    return revisions;
  }
  
  private developCharacterSuggestions(): CharacterDevelopmentSuggestion[] {
    const suggestions: CharacterDevelopmentSuggestion[] = [];
    
    // Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª Ù„Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ø¹Ø²ÙˆÙ„Ø©
    for (const isolated of this.diagnostics.isolatedCharacters) {
      const char = this.network.characters.get(isolated.characterId);
      if (!char) continue;
      
      suggestions.push({
        characterId: isolated.characterId,
        characterName: isolated.characterName,
        currentState: `Ø´Ø®ØµÙŠØ© Ù…Ø¹Ø²ÙˆÙ„Ø© (${isolated.isolationType})`,
        suggestedArc: 'Ù‚ÙˆØ³ ØªØ·ÙˆØ±ÙŠ ÙŠØ±Ø¨Ø· Ø§Ù„Ø´Ø®ØµÙŠØ© ØªØ¯Ø±ÙŠØ¬ÙŠØ§Ù‹ Ø¨Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©',
        keyMilestones: [
          'Ù„Ù‚Ø§Ø¡ Ø£ÙˆÙ„ Ù…Ø¹ Ø´Ø®ØµÙŠØ© Ø±Ø¦ÙŠØ³ÙŠØ©',
          'Ø§Ù„Ø§Ù†Ø®Ø±Ø§Ø· ÙÙŠ ØµØ±Ø§Ø¹ Ø«Ø§Ù†ÙˆÙŠ',
          'ØªØ·ÙˆÙŠØ± Ø¹Ù„Ø§Ù‚Ø© Ù‚ÙˆÙŠØ©',
          'Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ© ÙÙŠ ØµØ±Ø§Ø¹ Ù…Ø±ÙƒØ²ÙŠ'
        ],
        relationshipsToAdd: isolated.suggestedConnections,
        conflictsToInvolve: this.findSuitableConflictsForCharacter(char)
      });
    }
    
    return suggestions;
  }
  
  private findSuitableConflictsForCharacter(char: Character): string[] {
    const suitable: string[] = [];
    
    for (const [confId, conflict] of this.network.conflicts) {
      // ØµØ±Ø§Ø¹Ø§Øª ØªØ­ØªØ§Ø¬ Ù…Ø²ÙŠØ¯Ø§Ù‹ Ù…Ù† Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ†
      if (conflict.involvedCharacters.length < 3) {
        suitable.push(conflict.name);
      }
    }
    
    return suitable.slice(0, 3);
  }
  
  private enhanceConflictStrategies(): ConflictEnhancementStrategy[] {
    const strategies: ConflictEnhancementStrategy[] = [];
    
    // Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ù„Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„Ù…Ù‡Ø¬ÙˆØ±Ø©
    for (const abandoned of this.diagnostics.abandonedConflicts) {
      const conflict = this.network.conflicts.get(abandoned.conflictId);
      if (!conflict) continue;
      
      strategies.push({
        conflictId: abandoned.conflictId,
        conflictName: abandoned.conflictName,
        currentWeakness: `ØµØ±Ø§Ø¹ Ù…Ù‡Ø¬ÙˆØ± (${abandoned.issueType})`,
        enhancementApproach: this.generateEnhancementApproach(abandoned.issueType),
        stakesEscalation: 'Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ù…Ø®Ø§Ø·Ø± Ø§Ù„Ø´Ø®ØµÙŠØ© ÙˆØ§Ù„Ø¹ÙˆØ§Ù‚Ø¨ Ø§Ù„Ù…Ø­ØªÙ…Ù„Ø©',
        charactersToInvolve: this.findCharactersToInvolveInConflict(conflict),
        phaseProgression: this.suggestPhaseProgression(conflict)
      });
    }
    
    // Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ù„Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„Ø¶Ø¹ÙŠÙØ©
    for (const weak of this.diagnostics.weakConnections) {
      if (weak.connectionType === 'conflict_link') {
        const conflict = this.network.conflicts.get(weak.connectionId);
        if (!conflict) continue;
        
        strategies.push({
          conflictId: weak.connectionId,
          conflictName: conflict.name,
          currentWeakness: weak.reasonForWeakness,
          enhancementApproach: weak.suggestedStrengthening,
          stakesEscalation: 'ØªØµØ¹ÙŠØ¯ Ø§Ù„ØªÙˆØªØ± ÙˆØ²ÙŠØ§Ø¯Ø© Ø§Ù„ØªØ¹Ù‚ÙŠØ¯',
          charactersToInvolve: [],
          phaseProgression: 'Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¥Ù„Ù‰ Ù…Ø±Ø­Ù„Ø© Ø£ÙƒØ«Ø± Ø­Ø¯Ø©'
        });
      }
    }
    
    return strategies;
  }
  
  private generateEnhancementApproach(
    issueType: AbandonedConflictIssue['issueType']
  ): string {
    switch (issueType) {
      case 'no_progression':
        return 'Ø¥Ø¶Ø§ÙØ© Ø£Ø­Ø¯Ø§Ø« Ù…Ø­ÙˆØ±ÙŠØ© Ù…ØªØªØ§Ù„ÙŠØ© Ù„Ø¯ÙØ¹ Ø§Ù„ØµØ±Ø§Ø¹ Ù‚Ø¯Ù…Ø§Ù‹';
      case 'stuck_in_phase':
        return 'Ø¥Ø¯Ø®Ø§Ù„ Ø¹Ù†ØµØ± Ø®Ø§Ø±Ø¬ÙŠ Ø£Ùˆ ÙƒØ´Ù Ù…Ø¹Ù„ÙˆÙ…Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„ÙƒØ³Ø± Ø§Ù„Ø¬Ù…ÙˆØ¯';
      case '
      insufficient_involvement':
        return 'ØªÙˆØ³ÙŠØ¹ Ø¯Ø§Ø¦Ø±Ø© Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ© ÙˆØ±Ø¨Ø· Ø§Ù„ØµØ±Ø§Ø¹ Ø¨Ø®Ø·ÙˆØ· Ù‚ØµØµÙŠØ© Ø£Ø®Ø±Ù‰';
      default:
        return 'Ù…Ø±Ø§Ø¬Ø¹Ø© Ø´Ø§Ù…Ù„Ø© Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ© Ø§Ù„ØµØ±Ø§Ø¹ ÙˆØ¥Ø¹Ø§Ø¯Ø© Ù‡ÙŠÙƒÙ„ØªÙ‡';
    }
  }
  
  private findCharactersToInvolveInConflict(conflict: Conflict): string[] {
    const candidates: string[] = [];
    
    // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø´Ø®ØµÙŠØ§Øª Ù„Ù‡Ø§ Ø¹Ù„Ø§Ù‚Ø§Øª Ø¨Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ† Ø§Ù„Ø­Ø§Ù„ÙŠÙŠÙ†
    for (const [charId, char] of this.network.characters) {
      if (conflict.involvedCharacters.includes(charId)) continue;
      
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø¹Ù„Ø§Ù‚Ø§Øª Ù…Ø¹ Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ†
      let hasConnection = false;
      for (const rel of this.network.relationships.values()) {
        if ((rel.source === charId && conflict.involvedCharacters.includes(rel.target)) ||
            (rel.target === charId && conflict.involvedCharacters.includes(rel.source))) {
          hasConnection = true;
          break;
        }
      }
      
      if (hasConnection) {
        candidates.push(char.name);
      }
    }
    
    return candidates.slice(0, 3);
  }
  
  private suggestPhaseProgression(conflict: Conflict): string {
    const phaseOrder = [
      ConflictPhase.LATENT,
      ConflictPhase.EMERGING,
      ConflictPhase.ESCALATING,
      ConflictPhase.CLIMAX,
      ConflictPhase.DEESCALATING,
      ConflictPhase.RESOLUTION,
      ConflictPhase.AFTERMATH
    ];
    
    const currentIndex = phaseOrder.indexOf(conflict.phase);
    if (currentIndex === -1 || currentIndex >= phaseOrder.length - 1) {
      return 'Ø§Ù„ØµØ±Ø§Ø¹ ÙÙŠ Ù…Ø±Ø­Ù„Ø© Ù†Ù‡Ø§Ø¦ÙŠØ© Ø£Ùˆ ØºÙŠØ± Ù…Ø­Ø¯Ø¯Ø©';
    }
    
    const nextPhase = phaseOrder[currentIndex + 1];
    return `Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ù…Ù† ${conflict.phase.name} Ø¥Ù„Ù‰ ${nextPhase.name}`;
  }
  
  private createConsolidatedSummary(components: {
    prioritizedActions: PrioritizedAction[];
    quickFixes: QuickFix[];
    structuralRevisions: StructuralRevision[];
    characterSuggestions: CharacterDevelopmentSuggestion[];
    conflictStrategies: ConflictEnhancementStrategy[];
  }): string {
    const parts: string[] = [];
    
    parts.push(`## Ù…Ù„Ø®Øµ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø§Ù„Ø¹Ù„Ø§Ø¬ Ø§Ù„Ù…ÙˆØ­Ø¯`);
    parts.push(`\n### Ù†Ø¸Ø±Ø© Ø¹Ø§Ù…Ø© Ø¹Ù„Ù‰ ØµØ­Ø© Ø§Ù„Ø´Ø¨ÙƒØ©:`);
    parts.push(`- Ø§Ù„Ø¯Ø±Ø¬Ø© Ø§Ù„ÙƒÙ„ÙŠØ©: ${this.diagnostics.overallHealthScore}/100`);
    parts.push(`- Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø®Ø·ÙˆØ±Ø©: ${this.diagnostics.criticalityLevel}`);
    
    if (components.prioritizedActions.length > 0) {
      parts.push(`\n### Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø°Ø§Øª Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ© Ø§Ù„Ø¹Ù„ÙŠØ§ (${components.prioritizedActions.length}):`);
      const criticalCount = components.prioritizedActions.filter(a => a.priority === 'critical').length;
      const highCount = components.prioritizedActions.filter(a => a.priority === 'high').length;
      parts.push(`- Ø­Ø±Ø¬Ø©: ${criticalCount}`);
      parts.push(`- Ø¹Ø§Ù„ÙŠØ©: ${highCount}`);
      parts.push(`- Ù…ØªÙˆØ³Ø·Ø©/Ù…Ù†Ø®ÙØ¶Ø©: ${components.prioritizedActions.length - criticalCount - highCount}`);
    }
    
    if (components.quickFixes.length > 0) {
      parts.push(`\n### Ø§Ù„Ø¥ØµÙ„Ø§Ø­Ø§Øª Ø§Ù„Ø³Ø±ÙŠØ¹Ø© Ø§Ù„Ù…ØªØ§Ø­Ø©: ${components.quickFixes.length}`);
      parts.push(`ÙŠÙ…ÙƒÙ† ØªÙ†ÙÙŠØ° Ù‡Ø°Ù‡ Ø§Ù„Ø¥ØµÙ„Ø§Ø­Ø§Øª Ø¨Ø³Ø±Ø¹Ø© Ù„ØªØ­Ø³ÙŠÙ† ÙÙˆØ±ÙŠ ÙÙŠ Ø¬ÙˆØ¯Ø© Ø§Ù„Ø´Ø¨ÙƒØ©.`);
    }
    
    if (components.structuralRevisions.length > 0) {
      parts.push(`\n### Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø§Øª Ø§Ù„Ù‡ÙŠÙƒÙ„ÙŠØ© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©: ${components.structuralRevisions.length}`);
      const revisionTypes = components.structuralRevisions.map(r => r.revisionType).join(', ');
      parts.push(`Ø§Ù„Ø£Ù†ÙˆØ§Ø¹: ${revisionTypes}`);
    }
    
    if (components.characterSuggestions.length > 0) {
      parts.push(`\n### ØªØ·ÙˆÙŠØ± Ø§Ù„Ø´Ø®ØµÙŠØ§Øª: ${components.characterSuggestions.length} Ø´Ø®ØµÙŠØ© ØªØ­ØªØ§Ø¬ ØªØ­Ø³ÙŠÙ†`);
    }
    
    if (components.conflictStrategies.length > 0) {
      parts.push(`\n### ØªØ¹Ø²ÙŠØ² Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª: ${components.conflictStrategies.length} ØµØ±Ø§Ø¹ ÙŠØ­ØªØ§Ø¬ ØªÙ‚ÙˆÙŠØ©`);
    }
    
    parts.push(`\n### Ø§Ù„ØªÙˆØµÙŠØ© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:`);
    if (this.diagnostics.criticalityLevel === 'critical') {
      parts.push(`Ø§Ù„Ø´Ø¨ÙƒØ© ÙÙŠ Ø­Ø§Ù„Ø© Ø­Ø±Ø¬Ø© ÙˆØªØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ Ù…Ø±Ø§Ø¬Ø¹Ø© Ø´Ø§Ù…Ù„Ø© ÙÙˆØ±ÙŠØ©.`);
    } else if (this.diagnostics.criticalityLevel === 'major_issues') {
      parts.push(`ØªÙˆØ¬Ø¯ Ù…Ø´Ø§ÙƒÙ„ ÙƒØ¨ÙŠØ±Ø© ØªØªØ·Ù„Ø¨ Ù…Ø¹Ø§Ù„Ø¬Ø© Ù…Ù†Ù‡Ø¬ÙŠØ© Ù‚Ø¨Ù„ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©.`);
    } else if (this.diagnostics.criticalityLevel === 'moderate_issues') {
      parts.push(`Ø§Ù„Ø´Ø¨ÙƒØ© ÙÙŠ Ø­Ø§Ù„Ø© Ø¬ÙŠØ¯Ø© Ù…Ø¹ Ø¨Ø¹Ø¶ Ø§Ù„Ù…Ø¬Ø§Ù„Ø§Øª Ø§Ù„ØªÙŠ ØªØ­ØªØ§Ø¬ ØªØ­Ø³ÙŠÙ†.`);
    } else {
      parts.push(`Ø§Ù„Ø´Ø¨ÙƒØ© ÙÙŠ Ø­Ø§Ù„Ø© ØµØ­ÙŠØ© Ø¬ÙŠØ¯Ø©. Ø§Ù„ØªØ±ÙƒÙŠØ² Ø¹Ù„Ù‰ Ø§Ù„ØµÙ‚Ù„ ÙˆØ§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ø¯Ù‚ÙŠÙ‚Ø©.`);
    }
    
    return parts.join('\n');
  }
}

/**
 * Ù…Ù‚Ø§ÙŠÙŠØ³ Ø§Ù„ÙƒÙØ§Ø¡Ø© Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©
 */
class AdvancedEfficiencyMetrics {
  constructor(private network: ConflictNetwork) {}
  
  /**
   * Ø­Ø³Ø§Ø¨ Ù…Ù‚Ø§ÙŠÙŠØ³ Ù…Ø§ Ø¨Ø¹Ø¯ Ø§Ù„ØªØ´Ø®ÙŠØµ
   */
  calculatePostDiagnosticMetrics(
    diagnostics: NetworkDiagnosticsReport
  ): AdvancedEfficiencyMetrics {
    const baseEfficiency = this.calculateBaseEfficiency();
    const improvementPotential = this.calculateImprovementPotential(diagnostics);
    const treatmentFeasibility = this.assessTreatmentFeasibility(diagnostics);
    const expectedOutcome = this.projectExpectedOutcomes(
      baseEfficiency,
      improvementPotential,
      treatmentFeasibility
    );
    const riskAssessment = this.assessImplementationRisks(diagnostics);
    
    return {
      postDiagnosticScore: baseEfficiency,
      improvementPotential,
      treatmentFeasibility,
      expectedOutcome,
      riskAssessment
    };
  }
  
  private calculateBaseEfficiency(): number {
    // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù†ÙØ³ Ù…Ù†Ø·Ù‚ Ø§Ù„Ù…Ø­Ø·Ø© Ø§Ù„Ø±Ø§Ø¨Ø¹Ø©
    const analyzer = new EfficiencyMetricsAnalyzer();
    
    const conflictCohesion = analyzer.calculateConflictCohesion(this.network);
    const dramaticBalance = analyzer.calculateDramaticBalance(this.network);
    const narrativeEfficiency = analyzer.calculateNarrativeEfficiency(this.network);
    const redundancy = analyzer.analyzeRedundancy(this.network);
    const narrativeDensity = analyzer.calculateNarrativeDensity(this.network);
    
    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…ØªÙˆØ³Ø· Ø§Ù„Ù…ÙˆØ²ÙˆÙ†
    return (
      conflictCohesion * 0.25 +
      dramaticBalance.balanceScore * 0.25 +
      narrativeEfficiency.narrativeEfficiencyScore * 0.25 +
      (1 - redundancy.redundancyScore) * 0.15 +
      narrativeDensity.densityScores.storyDensity * 0.10
    );
  }
  
  private calculateImprovementPotential(
    diagnostics: NetworkDiagnosticsReport
  ): number {
    // Ø§Ù„Ø¥Ù…ÙƒØ§Ù†ÙŠØ© Ø§Ù„Ø¹Ø§Ù„ÙŠØ© Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù…Ø´Ø§ÙƒÙ„ Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„Ø­Ù„ Ø¨Ø³Ù‡ÙˆÙ„Ø©
    let potential = 0;
    
    // Ø§Ù„Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„Ù‡ÙŠÙƒÙ„ÙŠØ© Ø§Ù„Ø¨Ø³ÙŠØ·Ø© = Ø¥Ù…ÙƒØ§Ù†ÙŠØ© Ø¹Ø§Ù„ÙŠØ©
    const simpleStructuralIssues = diagnostics.structuralIssues.filter(
      i => i.severity === 'low' || i.severity === 'medium'
    ).length;
    potential += simpleStructuralIssues * 5;
    
    // Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ø¹Ø²ÙˆÙ„Ø© = Ø¥Ù…ÙƒØ§Ù†ÙŠØ© Ù…ØªÙˆØ³Ø·Ø©
    potential += diagnostics.isolatedCharacters.length * 3;
    
    // Ø§Ù„ØªÙƒØ±Ø§Ø±Ø§Øª = Ø¥Ù…ÙƒØ§Ù†ÙŠØ© Ø¹Ø§Ù„ÙŠØ© (Ø³Ù‡Ù„Ø© Ø§Ù„Ø¥ØµÙ„Ø§Ø­)
    potential += diagnostics.redundancyIssues.length * 4;
    
    // Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª Ø§Ù„Ø¶Ø¹ÙŠÙØ© = Ø¥Ù…ÙƒØ§Ù†ÙŠØ© Ø¹Ø§Ù„ÙŠØ©
    potential += diagnostics.weakConnections.length * 4;
    
    // ØªØ·Ø¨ÙŠØ¹ Ø¥Ù„Ù‰ 0-1
    return Math.min(1, potential / 100);
  }
  
  private assessTreatmentFeasibility(
    diagnostics: NetworkDiagnosticsReport
  ): number {
    let feasibility = 1.0;
    
    // Ø§Ù„Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„Ø­Ø±Ø¬Ø© ØªÙ‚Ù„Ù„ Ø§Ù„Ø¬Ø¯ÙˆÙ‰
    const criticalIssues = diagnostics.structuralIssues.filter(
      i => i.severity === 'critical'
    ).length;
    feasibility -= criticalIssues * 0.15;
    
    // Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„ÙƒØ¨ÙŠØ± Ù…Ù† Ø§Ù„Ù…Ø´Ø§ÙƒÙ„ ÙŠÙ‚Ù„Ù„ Ø§Ù„Ø¬Ø¯ÙˆÙ‰
    const totalIssues = 
      diagnostics.structuralIssues.length +
      diagnostics.isolatedCharacters.length +
      diagnostics.abandonedConflicts.length +
      diagnostics.overloadedCharacters.length;
    
    if (totalIssues > 20) feasibility -= 0.2;
    else if (totalIssues > 10) feasibility -= 0.1;
    
    return Math.max(0, feasibility);
  }
  
  private projectExpectedOutcomes(
    baseEfficiency: number,
    improvementPotential: number,
    feasibility: number
  ): AdvancedEfficiencyMetrics['expectedOutcome'] {
    // Ø§Ù„Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆ Ø§Ù„Ù…ØªÙØ§Ø¦Ù„: ØªØ­Ù‚ÙŠÙ‚ ÙƒØ§Ù…Ù„ Ø§Ù„Ø¥Ù…ÙƒØ§Ù†Ø§Øª
    const optimisticScore = Math.min(1, baseEfficiency + (improvementPotential * feasibility));
    
    // Ø§Ù„Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆ Ø§Ù„ÙˆØ§Ù‚Ø¹ÙŠ: ØªØ­Ù‚ÙŠÙ‚ 60% Ù…Ù† Ø§Ù„Ø¥Ù…ÙƒØ§Ù†Ø§Øª
    const realisticScore = Math.min(1, baseEfficiency + (improvementPotential * feasibility * 0.6));
    
    // Ø§Ù„Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆ Ø§Ù„Ù…ØªØ´Ø§Ø¦Ù…: ØªØ­Ù‚ÙŠÙ‚ 30% Ù…Ù† Ø§Ù„Ø¥Ù…ÙƒØ§Ù†Ø§Øª
    const pessimisticScore = Math.min(1, baseEfficiency + (improvementPotential * feasibility * 0.3));
    
    return {
      optimisticScore,
      realisticScore,
      pessimisticScore
    };
  }
  
  private assessImplementationRisks(
    diagnostics: NetworkDiagnosticsReport
  ): AdvancedEfficiencyMetrics['riskAssessment'] {
    const risks: string[] = [];
    
    // Ù…Ø®Ø§Ø·Ø± Ù…Ù† Ø§Ù„Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„Ù‡ÙŠÙƒÙ„ÙŠØ©
    if (diagnostics.structuralIssues.some(i => i.type === 'disconnected_components')) {
      risks.push('Ø®Ø·Ø± ÙÙ‚Ø¯Ø§Ù† Ø§Ù„ØªÙ…Ø§Ø³Ùƒ Ø§Ù„Ø³Ø±Ø¯ÙŠ Ø¹Ù†Ø¯ Ø±Ø¨Ø· Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª Ø§Ù„Ù…Ù†ÙØµÙ„Ø©');
    }
    
    if (diagnostics.structuralIssues.some(i => i.type === 'bottleneck_character')) {
      risks.push('Ø®Ø·Ø± Ø¥Ø¶Ø¹Ø§Ù Ø§Ù„Ø´Ø®ØµÙŠØ© Ø§Ù„Ù…Ø±ÙƒØ²ÙŠØ© Ø¹Ù†Ø¯ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªÙˆØ²ÙŠØ¹');
    }
    
    // Ù…Ø®Ø§Ø·Ø± Ù…Ù† Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ø­Ù…Ù„Ø©
    if (diagnostics.overloadedCharacters.length > 0) {
      risks.push('Ø®Ø·Ø± ØªÙØªÙŠØª Ø¯ÙˆØ± Ø§Ù„Ø´Ø®ØµÙŠØ© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ø¹Ù†Ø¯ ØªØ®ÙÙŠÙ Ø§Ù„Ø­Ù…Ù„');
    }
    
    // Ù…Ø®Ø§Ø·Ø± Ù…Ù† Ø§Ù„ØªÙƒØ±Ø§Ø±Ø§Øª
    if (diagnostics.redundancyIssues.length > 5) {
      risks.push('Ø®Ø·Ø± ÙÙ‚Ø¯Ø§Ù† ØªÙ†ÙˆØ¹ Ø§Ù„Ø³Ø±Ø¯ Ø¹Ù†Ø¯ Ø¯Ù…Ø¬ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù…ÙƒØ±Ø±Ø©');
    }
    
    // Ø­Ø³Ø§Ø¨ Ù…Ø®Ø§Ø·Ø± Ø§Ù„Ø§ØªØ³Ø§Ù‚
    const narrativeCoherenceRisk = this.calculateCoherenceRisk(diagnostics);
    const characterConsistencyRisk = this.calculateConsistencyRisk(diagnostics);
    
    return {
      implementationRisks: risks,
      narrativeCoherenceRisk,
      characterConsistencyRisk
    };
  }
  
  private calculateCoherenceRisk(diagnostics: NetworkDiagnosticsReport): number {
    // Ø®Ø·Ø± Ø£Ø¹Ù„Ù‰ Ù…Ø¹ Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª Ø§Ù„Ù‡ÙŠÙƒÙ„ÙŠØ©
    let risk = 0;
    
    risk += diagnostics.structuralIssues.filter(i => 
      i.type === 'disconnected_components' || i.type === 'circular_dependency'
    ).length * 0.15;
    
    risk += diagnostics.abandonedConflicts.length * 0.05;
    
    return Math.min(1, risk);
  }
  
  private calculateConsistencyRisk(diagnostics: NetworkDiagnosticsReport): number {
    // Ø®Ø·Ø± Ø£Ø¹Ù„Ù‰ Ù…Ø¹ ØªØºÙŠÙŠØ±Ø§Øª ÙƒØ¨ÙŠØ±Ø© ÙÙŠ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª
    let risk = 0;
    
    risk += diagnostics.isolatedCharacters.length * 0.08;
    risk += diagnostics.overloadedCharacters.length * 0.12;
    
    return Math.min(1, risk);
  }
}

/**
 * Ø§Ù„Ù…Ø­Ø·Ø© Ø§Ù„Ø³Ø§Ø¯Ø³Ø©: Ø§Ù„ØªØ´Ø®ÙŠØµ ÙˆØ§Ù„Ø¹Ù„Ø§Ø¬
 */
class Station6DiagnosticsAndTreatment extends BaseStation<Station6Input, Station6Output> {
  protected async process(input: Station6Input): Promise<Station6Output> {
    const startTime = Date.now();
    const network = input.conflictNetwork;
    
    logger.info("S6: Starting diagnostics...");
    
    // 1. ØªØ´ØºÙŠÙ„ Ø§Ù„ØªØ´Ø®ÙŠØµØ§Øª
    const diagnosticsEngine = new NetworkDiagnostics();
    const diagnosticsReport = diagnosticsEngine.runAllDiagnostics(network);
    
    logger.info(`S6: Diagnostics complete. Health Score: ${diagnosticsReport.overallHealthScore}`);
    
    // 2. ØªØ·ÙˆÙŠØ± Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø§Ù„Ø¹Ù„Ø§Ø¬
    const treatmentEngine = new TreatmentStrategies(network, diagnosticsReport);
    const treatmentRecommendations = treatmentEngine.analyzeAndRecommendTreatments();
    
    logger.info(`S6: Generated ${treatmentRecommendations.prioritizedActions.length} prioritized actions`);
    
    // 3. Ø­Ø³Ø§Ø¨ Ù…Ù‚Ø§ÙŠÙŠØ³ Ø§Ù„ÙƒÙØ§Ø¡Ø© Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©
    const advancedMetrics = new AdvancedEfficiencyMetrics(network);
    const advancedEfficiencyMetrics = advancedMetrics.calculatePostDiagnosticMetrics(
      diagnosticsReport
    );
    
    logger.info(`S6: Advanced metrics calculated. Improvement potential: ${(advancedEfficiencyMetrics.improvementPotential * 100).toFixed(1)}%`);
    
    const analysisTime = Date.now() - startTime;
    
    return {
      diagnosticsReport,
      treatmentRecommendations,
      advancedEfficiencyMetrics,
      metadata: {
        analysisTimestamp: new Date(),
        status: 'Success',
        analysisTime
      }
    };
  }
  
  protected extractRequiredData(input: Station6Input): any {
    return {
      network: input.conflictNetwork,
      station5Output: input.station5Output
    };
  }
  
  protected getErrorFallback(): Station6Output {
    return {
      diagnosticsReport: {
        structuralIssues: [],
        isolatedCharacters: [],
        abandonedConflicts: [],
        overloadedCharacters: [],
        weakConnections: [],
        redundancyIssues: [],
        overallHealthScore: 0,
        criticalityLevel: 'critical'
      },
      treatmentRecommendations: {
        prioritizedActions: [],
        quickFixes: [],
        structuralRevisions: [],
        characterDevelopmentSuggestions: [],
        conflictEnhancementStrategies: [],
        consolidatedSummary: 'Analysis failed - unable to generate recommendations'
      },
      advancedEfficiencyMetrics: {
        postDiagnosticScore: 0,
        improvementPotential: 0,
        treatmentFeasibility: 0,
        expectedOutcome: {
          optimisticScore: 0,
          realisticScore: 0,
          pessimisticScore: 0
        },
        riskAssessment: {
          implementationRisks: ['Analysis failed'],
          narrativeCoherenceRisk: 1,
          characterConsistencyRisk: 1
        }
      },
      metadata: {
        analysisTimestamp: new Date(),
        status: 'Failed',
        analysisTime: 0
      }
    };
  }
}

Ø§Ù„Ù…Ø­Ø·Ø© Ø§Ù„Ø³Ø§Ø¨Ø¹Ø©: Ø§Ù„Ø¥Ù†Ù‡Ø§Ø¡ ÙˆØ§Ù„ØªØµÙˆØ±
// stations/station7/station7-finalization.ts

interface Station7Input {
  conflictNetwork: ConflictNetwork;
  station6Output: Station6Output;
  allPreviousStationsData: Map<number, any>; // Ù„Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø­Ø·Ø§Øª Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©
}

interface Station7Output {
  visualizationResults: VisualizationResults;
  platformAdaptationSuggestions: PlatformAdaptationResults;
  finalReport: FinalAnalysisReport;
  exportPackage: ExportPackage;
  metadata: {
    analysisTimestamp: Date;
    status: 'Success' | 'Partial' | 'Failed';
    processingTime: number;
  };
}

interface VisualizationResults {
  networkGraphs: Map<string, VisualizationArtifact>;
  timelineVisualizations: Map<string, VisualizationArtifact>;
  statisticalCharts: Map<string, VisualizationArtifact>;
  interactiveElements: InteractiveVisualization[];
}

interface VisualizationArtifact {
  id: string;
  type: 'static_image' | 'interactive_html' | 'vector_graphic' | 'd3_visualization';
  format: 'png' | 'svg' | 'html' | 'json';
  path: string;
  metadata: {
    title: string;
    description: string;
    dimensions: { width: number; height: number };
    generatedAt: Date;
  };
}

interface InteractiveVisualization {
  id: string;
  type: 'network_explorer' | 'timeline_navigator' | 'conflict_analyzer';
  htmlPath: string;
  dependencies: string[];
  features: string[];
}

interface PlatformAdaptationResults {
  episodicBreakdown: EpisodicAdaptation;
  cinematicSuggestions: CinematicAdaptation;
  serializedNovelStructure: SerializedAdaptation;
  comparativeAnalysis: string;
}

interface EpisodicAdaptation {
  series: {
    totalSeasons: number;
    episodesPerSeason: number;
    recommendedRuntime: number; // minutes
  };
  seasonBreakdown: Map<number, SeasonPlan>;
  cliffhangerSuggestions: Map<number, string[]>; // season -> cliffhangers
  characterArcMapping: Map<string, string[]>; // characterId -> episode numbers
}

interface SeasonPlan {
  seasonNumber: number;
  mainConflicts: string[];
  characterFocus: string[];
  thematicProgression: string;
  keyMilestones: string[];
}

interface CinematicAdaptation {
  recommendedRuntime: number; // minutes
  actBreakdown: {
    act1: { duration: number; keyScenes: string[]; };
    act2: { duration: number; keyScenes: string[]; };
    act3: { duration: number; keyScenes: string[]; };
  };
  visualStyle: string;
  pacingSuggestions: string;
  condensationStrategy: string;
}

interface SerializedAdaptation {
  recommendedChapterCount: number;
  volumeStructure: Map<number, VolumeDetails>;
  cliffhangerPlacement: number[];
  narrativePacing: string;
}

interface VolumeDetails {
  volumeNumber: number;
  chapterRange: [number, number];
  mainConflicts: string[];
  thematicFocus: string;
}

interface FinalAnalysisReport {
  executiveSummary: string;
  strengthsAnalysis: string[];
  weaknessesIdentified: string[];
  opportunitiesForImprovement: string[];
  threatsToCohesion: string[];
  overallAssessment: {
    narrativeQualityScore: number;
    structuralIntegrityScore: number;
    characterDevelopmentScore: number;
    conflictEffectivenessScore: number;
    overallScore: number;
    rating: 'Excellent' | 'Good' | 'Fair' | 'Needs Improvement' | 'Critical';
  };
  detailedFindings: Map<string, any>; // Ù…Ù† ÙƒÙ„ Ù…Ø­Ø·Ø©
}

interface ExportPackage {
  formats: Map<string, ExportFormat>;
  deliverables: string[];
  packagePath: string;
}

interface ExportFormat {
  formatType: 'json' | 'pdf' | 'html' | 'markdown' | 'excel';
  filePath: string;
  contentSummary: string;
}

/**
 * Ù…Ø­Ø±Ùƒ Ø§Ù„ØªØµÙˆØ± Ø§Ù„Ø¨ØµØ±ÙŠ
 */
class VisualizationEngine {
  constructor(
    private network: ConflictNetwork,
    private outputDir: string
  ) {
    // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø¬Ù„Ø¯Ø§Øª Ø§Ù„ÙØ±Ø¹ÙŠØ© Ù„Ù„ØªØµÙˆØ±Ø§Øª
    fs.mkdirSync(path.join(outputDir, 'graphs'), { recursive: true });
    fs.mkdirSync(path.join(outputDir, 'charts'), { recursive: true });
    fs.mkdirSync(path.join(outputDir, 'interactive'), { recursive: true });
  }
  
  /**
   * Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØµÙˆØ±Ø§Øª
   */
  async generateAllVisualizations(): Promise<VisualizationResults> {
    const networkGraphs = await this.generateNetworkGraphs();
    const timelineViz = await this.generateTimelineVisualizations();
    const statisticalCharts = await this.generateStatisticalCharts();
    const interactiveElements = await this.generateInteractiveVisualizations();
    
    return {
      networkGraphs,
      timelineVisualizations: timelineViz,
      statisticalCharts,
      interactiveElements
    };
  }
  
  /**
   * Ø¥Ù†Ø´Ø§Ø¡ Ø±Ø³ÙˆÙ… Ø§Ù„Ø´Ø¨ÙƒØ©
   */
  private async generateNetworkGraphs(): Promise<Map<string, VisualizationArtifact>> {
    const graphs = new Map<string, VisualizationArtifact>();
    
    // 1. Ø±Ø³Ù… Ø´Ø¨ÙƒØ© Ø§Ù„Ø´Ø®ØµÙŠØ§Øª
    const characterGraph = await this.createCharacterNetworkGraph();
    graphs.set('character_network', characterGraph);
    
    // 2. Ø±Ø³Ù… Ø´Ø¨ÙƒØ© Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
    const conflictGraph = await this.createConflictNetworkGraph();
    graphs.set('conflict_network', conflictGraph);
    
    // 3. Ø±Ø³Ù… Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„ÙƒØ§Ù…Ù„Ø© (Bipartite)
    const fullGraph = await this.createFullBipartiteGraph();
    graphs.set('full_network', fullGraph);
    
    // 4. Ø±Ø³Ù… Ø§Ù„Ø´Ø¨ÙƒØ© Ø­Ø³Ø¨ Ø§Ù„Ø£Ù‡Ù…ÙŠØ© (Weighted)
    const weightedGraph = await this.createWeightedImportanceGraph();
    graphs.set('weighted_importance', weightedGraph);
    
    return graphs;
  }
  
  private async createCharacterNetworkGraph(): Promise<VisualizationArtifact> {
    // Ø§Ø³ØªØ®Ø¯Ø§Ù… D3.js Ø£Ùˆ Ù…ÙƒØªØ¨Ø© Ø±Ø³Ù… Ø£Ø®Ø±Ù‰ Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø±Ø³Ù… ØªÙØ§Ø¹Ù„ÙŠ
    const graphData = this.prepareCharacterGraphData();
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù HTML ØªÙØ§Ø¹Ù„ÙŠ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… D3.js
    const htmlContent = this.generateD3CharacterGraph(graphData);
    const outputPath = path.join(this.outputDir, 'graphs', 'character_network.html');
    
    fs.writeFileSync(outputPath, htmlContent, 'utf-8');
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ø£ÙŠØ¶Ø§Ù‹ Ù†Ø³Ø®Ø© PNG Ø«Ø§Ø¨ØªØ©
    const pngPath = await this.renderGraphToPNG(htmlContent, 'character_network.png');
    
    return {
      id: 'character_network',
      type: 'interactive_html',
      format: 'html',
      path: outputPath,
      metadata: {
        title: 'Ø´Ø¨ÙƒØ© Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª Ø¨ÙŠÙ† Ø§Ù„Ø´Ø®ØµÙŠØ§Øª',
        description: 'ØªØµÙˆØ± ØªÙØ§Ø¹Ù„ÙŠ Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª Ø¨ÙŠÙ† Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©',
        dimensions: { width: 1200, height: 800 },
        generatedAt: new Date()
      }
    };
  }
  
  private prepareCharacterGraphData(): any {
    const nodes: any[] = [];
    const links: any[] = [];
    
    // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¹Ù‚Ø¯ (Ø§Ù„Ø´Ø®ØµÙŠØ§Øª)
    for (const [charId, char] of this.network.characters) {
      nodes.push({
        id: charId,
        name: char.name,
        description: char.description,
        group: this.determineCharacterGroup(char),
        metadata: char.metadata
      });
    }
    
    // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø±ÙˆØ§Ø¨Ø· (Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª)
    for (const rel of this.network.relationships.values()) {
      links.push({
        source: rel.source,
        target: rel.target,
        strength: rel.strength,
        type: rel.type.name,
        nature: rel.nature.name,
        description: rel.description
      });
    }
    
    return { nodes, links };
  }
  
  private determineCharacterGroup(char: Character): number {
    // ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø­Ø³Ø¨ Ù…Ø¹Ø§ÙŠÙŠØ± Ù…Ø®ØªÙ„ÙØ©
    // Ù…Ø«Ù„Ø§Ù‹: Ø­Ø³Ø¨ Ø¹Ø¯Ø¯ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ© ÙÙŠÙ‡Ø§
    let conflictCount = 0;
    for (const conflict of this.network.conflicts.values()) {
      if (conflict.involvedCharacters.includes(char.id)) {
        conflictCount++;
      }
    }
    
    if (conflictCount >= 3) return 1; // Ø´Ø®ØµÙŠØ§Øª Ø±Ø¦ÙŠØ³ÙŠØ©
    if (conflictCount >= 1) return 2; // Ø´Ø®ØµÙŠØ§Øª Ø«Ø§Ù†ÙˆÙŠØ©
    return 3; // Ø´Ø®ØµÙŠØ§Øª Ù‡Ø§Ù…Ø´ÙŠØ©
  }
  
  private generateD3CharacterGraph(graphData: any): string {
    // ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ HTML/JavaScript Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… D3.js
    return `
<!DOCTYPE html>
<html dir="rtl" lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø´Ø¨ÙƒØ© Ø§Ù„Ø´Ø®ØµÙŠØ§Øª</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Arial, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
        #graph { width: 100%; height: 800px; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .node { cursor: pointer; }
        .node:hover { stroke: #000; stroke-width: 2px; }
        .link { stroke: #999; stroke-opacity: 0.6; }
        .tooltip { position: absolute; padding: 10px; background: rgba(0,0,0,0.8); color: white; border-radius: 4px; pointer-events: none; display: none; }
    </style>
</head>
<body>
    <h1>Ø´Ø¨ÙƒØ© Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª Ø¨ÙŠÙ† Ø§Ù„Ø´Ø®ØµÙŠØ§Øª</h1>
    <div id="graph"></div>
    <div class="tooltip" id="tooltip"></div>
    
    <script>
        const data = ${JSON.stringify(graphData, null, 2)};
        
        const width = document.getElementById('graph').clientWidth;
        const height = 800;
        
        const svg = d3.select('#graph')
            .append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const simulation = d3.forceSimulation(data.nodes)
            .force('link', d3.forceLink(data.links).id(d => d.id).distance(100))
            .force('charge', d3.forceManyBody().strength(-300))
            .force('center', d3.forceCenter(width / 2, height / 2))
            .force('collision', d3.forceCollide().radius(30));
        
        const link = svg.append('g')
            .selectAll('line')
            .data(data.links)
            .enter().append('line')
            .attr('class', 'link')
            .style('stroke-width', d => Math.sqrt(d.strength));
        
        const node = svg.append('g')
            .selectAll('circle')
            .data(data.nodes)
            .enter().append('circle')
            .attr('class', 'node')
            .attr('r', 10)
            .attr('fill', d => d.group === 1 ? '#ff6b6b' : d.group === 2 ? '#4ecdc4' :
            '#95e1d3')
            .call(d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended))
            .on('mouseover', showTooltip)
            .on('mouseout', hideTooltip);
        
        const label = svg.append('g')
            .selectAll('text')
            .data(data.nodes)
            .enter().append('text')
            .attr('text-anchor', 'middle')
            .attr('dy', -15)
            .style('font-size', '12px')
            .style('font-weight', 'bold')
            .text(d => d.name);
        
        simulation.on('tick', () => {
            link
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);
            
            node
                .attr('cx', d => d.x)
                .attr('cy', d => d.y);
            
            label
                .attr('x', d => d.x)
                .attr('y', d => d.y);
        });
        
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }
        
        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }
        
        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
        
        function showTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');
            tooltip.style.display = 'block';
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY + 10) + 'px';
            tooltip.innerHTML = \`
                <strong>\${d.name}</strong><br>
                \${d.description || 'Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙˆØµÙ'}
            \`;
        }
        
        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }
    </script>
</body>
</html>
    `;
  }
  
  private async renderGraphToPNG(htmlContent: string, filename: string): Promise<string> {
    // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…ÙƒØªØ¨Ø© Ù…Ø«Ù„ puppeteer Ù„ØªØ­ÙˆÙŠÙ„ HTML Ø¥Ù„Ù‰ PNG
    // Ù‡Ø°Ø§ Ù…Ø«Ø§Ù„ ØªÙˆØ¶ÙŠØ­ÙŠ - ÙŠØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ ØªØ·Ø¨ÙŠÙ‚ ÙØ¹Ù„ÙŠ
    const outputPath = path.join(this.outputDir, 'graphs', filename);
    // await puppeteer.render(htmlContent, outputPath);
    return outputPath;
  }
  
  private async createConflictNetworkGraph(): Promise<VisualizationArtifact> {
    // Ù…Ø´Ø§Ø¨Ù‡ Ù„Ù€ createCharacterNetworkGraph Ù„ÙƒÙ† Ù„Ù„ØµØ±Ø§Ø¹Ø§Øª
    const graphData = this.prepareConflictGraphData();
    const htmlContent = this.generateD3ConflictGraph(graphData);
    const outputPath = path.join(this.outputDir, 'graphs', 'conflict_network.html');
    
    fs.writeFileSync(outputPath, htmlContent, 'utf-8');
    
    return {
      id: 'conflict_network',
      type: 'interactive_html',
      format: 'html',
      path: outputPath,
      metadata: {
        title: 'Ø´Ø¨ÙƒØ© Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª',
        description: 'ØªØµÙˆØ± Ù„Ù„ØµØ±Ø§Ø¹Ø§Øª ÙˆØ§Ø±ØªØ¨Ø§Ø·Ø§ØªÙ‡Ø§ Ø¨Ø§Ù„Ø´Ø®ØµÙŠØ§Øª',
        dimensions: { width: 1200, height: 800 },
        generatedAt: new Date()
      }
    };
  }
  
  private prepareConflictGraphData(): any {
    const nodes: any[] = [];
    const links: any[] = [];
    
    // Ø¥Ø¶Ø§ÙØ© Ø¹Ù‚Ø¯ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª
    for (const [charId, char] of this.network.characters) {
      nodes.push({
        id: charId,
        name: char.name,
        type: 'character',
        group: 0
      });
    }
    
    // Ø¥Ø¶Ø§ÙØ© Ø¹Ù‚Ø¯ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
    for (const [confId, conflict] of this.network.conflicts) {
      nodes.push({
        id: confId,
        name: conflict.name,
        type: 'conflict',
        group: 1,
        subject: conflict.subject.name,
        strength: conflict.strength
      });
      
      // Ø±Ø¨Ø· Ø§Ù„ØµØ±Ø§Ø¹ Ø¨Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ©
      for (const charId of conflict.involvedCharacters) {
        links.push({
          source: charId,
          target: confId,
          type: 'involvement'
        });
      }
    }
    
    return { nodes, links };
  }
  
  private generateD3ConflictGraph(graphData: any): string {
    // Ù…Ø´Ø§Ø¨Ù‡ Ù„Ù€ generateD3CharacterGraph Ù…Ø¹ ØªØ®ØµÙŠØµØ§Øª Ù„Ù„ØµØ±Ø§Ø¹Ø§Øª
    return `<!DOCTYPE html>
<html dir="rtl" lang="ar">
<head>
    <meta charset="UTF-8">
    <title>Ø´Ø¨ÙƒØ© Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Arial, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
        #graph { width: 100%; height: 800px; background: white; border-radius: 8px; }
        .character-node { fill: #4ecdc4; }
        .conflict-node { fill: #ff6b6b; }
    </style>
</head>
<body>
    <h1>Ø´Ø¨ÙƒØ© Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª ÙˆØ§Ù„Ø´Ø®ØµÙŠØ§Øª</h1>
    <div id="graph"></div>
    <script>
        const data = ${JSON.stringify(graphData, null, 2)};
        // ... ÙƒÙˆØ¯ D3.js Ù…Ù…Ø§Ø«Ù„ Ù…Ø¹ ØªÙ…ÙŠÙŠØ² Ø¨ÙŠÙ† Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø¹Ù‚Ø¯
    </script>
</body>
</html>`;
  }
  
  private async createFullBipartiteGraph(): Promise<VisualizationArtifact> {
    // Ø±Ø³Ù… Ø«Ù†Ø§Ø¦ÙŠ Ø§Ù„ØªÙ‚Ø³ÙŠÙ… ÙŠÙˆØ¶Ø­ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª ÙˆØ§Ù„ØµØ±Ø§Ø¹Ø§Øª Ù…Ø¹Ø§Ù‹
    const outputPath = path.join(this.outputDir, 'graphs', 'full_bipartite.svg');
    
    // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…ÙƒØªØ¨Ø© Ø±Ø³Ù… SVG
    const svgContent = this.generateBipartiteSVG();
    fs.writeFileSync(outputPath, svgContent, 'utf-8');
    
    return {
      id: 'full_bipartite',
      type: 'vector_graphic',
      format: 'svg',
      path: outputPath,
      metadata: {
        title: 'Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„ÙƒØ§Ù…Ù„Ø© (Ø«Ù†Ø§Ø¦ÙŠØ© Ø§Ù„ØªÙ‚Ø³ÙŠÙ…)',
        description: 'ØªØµÙˆØ± Ø´Ø§Ù…Ù„ Ù„Ù„Ø´Ø®ØµÙŠØ§Øª ÙˆØ§Ù„ØµØ±Ø§Ø¹Ø§Øª ÙÙŠ Ø´Ø¨ÙƒØ© ÙˆØ§Ø­Ø¯Ø©',
        dimensions: { width: 1600, height: 1000 },
        generatedAt: new Date()
      }
    };
  }
  
  private generateBipartiteSVG(): string {
    // ØªÙˆÙ„ÙŠØ¯ SVG Ù„Ù„Ø±Ø³Ù… Ø§Ù„Ø«Ù†Ø§Ø¦ÙŠ
    const characters = Array.from(this.network.characters.values());
    const conflicts = Array.from(this.network.conflicts.values());
    
    const width = 1600;
    const height = 1000;
    const leftX = 200;
    const rightX = 1400;
    
    let svg = `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">`;
    svg += `<style>
        .char-circle { fill: #4ecdc4; stroke: #333; stroke-width: 2; }
        .conf-rect { fill: #ff6b6b; stroke: #333; stroke-width: 2; }
        .link { stroke: #999; stroke-width: 1; opacity: 0.6; }
        text { font-family: Arial, sans-serif; font-size: 12px; text-anchor: middle; }
    </style>`;
    
    // Ø±Ø³Ù… Ø§Ù„Ø±ÙˆØ§Ø¨Ø· Ø£ÙˆÙ„Ø§Ù‹ (ÙÙŠ Ø§Ù„Ø®Ù„ÙÙŠØ©)
    for (const conflict of conflicts) {
      const confY = conflicts.indexOf(conflict) * (height / (conflicts.length + 1)) + 50;
      
      for (const charId of conflict.involvedCharacters) {
        const charIndex = characters.findIndex(c => c.id === charId);
        if (charIndex !== -1) {
          const charY = charIndex * (height / (characters.length + 1)) + 50;
          svg += `<line class="link" x1="${leftX}" y1="${charY}" x2="${rightX}" y2="${confY}" />`;
        }
      }
    }
    
    // Ø±Ø³Ù… Ø§Ù„Ø´Ø®ØµÙŠØ§Øª (ÙŠØ³Ø§Ø±)
    characters.forEach((char, i) => {
      const y = i * (height / (characters.length + 1)) + 50;
      svg += `<circle class="char-circle" cx="${leftX}" cy="${y}" r="20" />`;
      svg += `<text x="${leftX}" y="${y + 5}">${char.name}</text>`;
    });
    
    // Ø±Ø³Ù… Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª (ÙŠÙ…ÙŠÙ†)
    conflicts.forEach((conf, i) => {
      const y = i * (height / (conflicts.length + 1)) + 50;
      svg += `<rect class="conf-rect" x="${rightX - 30}" y="${y - 15}" width="60" height="30" rx="5" />`;
      svg += `<text x="${rightX}" y="${y + 5}">${conf.name.substring(0, 15)}...</text>`;
    });
    
    svg += `</svg>`;
    return svg;
  }
  
  private async createWeightedImportanceGraph(): Promise<VisualizationArtifact> {
    // Ø±Ø³Ù… ÙŠÙˆØ¶Ø­ Ø£Ù‡Ù…ÙŠØ© ÙƒÙ„ Ø´Ø®ØµÙŠØ© Ø­Ø³Ø¨ Ù…Ø´Ø§Ø±ÙƒØªÙ‡Ø§ ÙÙŠ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
    const outputPath = path.join(this.outputDir, 'graphs', 'weighted_importance.html');
    
    const importanceData = this.calculateCharacterImportance();
    const htmlContent = this.generateWeightedImportanceHTML(importanceData);
    
    fs.writeFileSync(outputPath, htmlContent, 'utf-8');
    
    return {
      id: 'weighted_importance',
      type: 'interactive_html',
      format: 'html',
      path: outputPath,
      metadata: {
        title: 'Ø´Ø¨ÙƒØ© Ø§Ù„Ø£Ù‡Ù…ÙŠØ© Ø§Ù„Ù…ÙˆØ²ÙˆÙ†Ø©',
        description: 'ØªØµÙˆØ± ÙŠÙˆØ¶Ø­ Ø£Ù‡Ù…ÙŠØ© ÙƒÙ„ Ø´Ø®ØµÙŠØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù…Ø´Ø§Ø±ÙƒØªÙ‡Ø§',
        dimensions: { width: 1200, height: 800 },
        generatedAt: new Date()
      }
    };
  }
  
  private calculateCharacterImportance(): Map<string, number> {
    const importance = new Map<string, number>();
    
    for (const [charId, char] of this.network.characters) {
      let score = 0;
      
      // Ø§Ù„Ù†Ù‚Ø§Ø· Ù…Ù† Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ© ÙÙŠ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
      for (const conflict of this.network.conflicts.values()) {
        if (conflict.involvedCharacters.includes(charId)) {
          score += conflict.strength;
        }
      }
      
      // Ø§Ù„Ù†Ù‚Ø§Ø· Ù…Ù† Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
      for (const rel of this.network.relationships.values()) {
        if (rel.source === charId || rel.target === charId) {
          score += rel.strength * 0.5;
        }
      }
      
      importance.set(charId, score);
    }
    
    return importance;
  }
  
  private generateWeightedImportanceHTML(importanceData: Map<string, number>): string {
    const data = Array.from(importanceData.entries()).map(([charId, score]) => ({
      id: charId,
      name: this.network.characters.get(charId)?.name || charId,
      score
    })).sort((a, b) => b.score - a.score);
    
    return `<!DOCTYPE html>
<html dir="rtl" lang="ar">
<head>
    <meta charset="UTF-8">
    <title>Ø£Ù‡Ù…ÙŠØ© Ø§Ù„Ø´Ø®ØµÙŠØ§Øª</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        #chart { background: white; padding: 20px; border-radius: 8px; }
        .bar { fill: #4ecdc4; }
        .bar:hover { fill: #ff6b6b; }
    </style>
</head>
<body>
    <h1>ØªØµÙ†ÙŠÙ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø­Ø³Ø¨ Ø§Ù„Ø£Ù‡Ù…ÙŠØ©</h1>
    <div id="chart"></div>
    <script>
        const data = ${JSON.stringify(data, null, 2)};
        
        const margin = {top: 20, right: 30, bottom: 60, left: 150};
        const width = 800 - margin.left - margin.right;
        const height = 600 - margin.top - margin.bottom;
        
        const svg = d3.select('#chart')
            .append('svg')
            .attr('width', width + margin.left + margin.right)
            .attr('height', height + margin.top + margin.bottom)
            .append('g')
            .attr('transform', \`translate(\${margin.left},\${margin.top})\`);
        
        const x = d3.scaleLinear()
            .domain([0, d3.max(data, d => d.score)])
            .range([0, width]);
        
        const y = d3.scaleBand()
            .domain(data.map(d => d.name))
            .range([0, height])
            .padding(0.1);
        
        svg.selectAll('.bar')
            .data(data)
            .enter().append('rect')
            .attr('class', 'bar')
            .attr('y', d => y(d.name))
            .attr('height', y.bandwidth())
            .attr('x', 0)
            .attr('width', d => x(d.score));
        
        svg.append('g')
            .attr('transform', \`translate(0,\${height})\`)
            .call(d3.axisBottom(x));
        
        svg.append('g')
            .call(d3.axisLeft(y));
        
        svg.selectAll('.label')
            .data(data)
            .enter().append('text')
            .attr('class', 'label')
            .attr('x', d => x(d.score) + 5)
            .attr('y', d => y(d.name) + y.bandwidth() / 2)
            .attr('dy', '.35em')
            .text(d => d.score.toFixed(1));
    </script>
</body>
</html>`;
  }
  
  /**
   * Ø¥Ù†Ø´Ø§Ø¡ ØªØµÙˆØ±Ø§Øª Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø²Ù…Ù†ÙŠ
   */
  private async generateTimelineVisualizations(): Promise<Map<string, VisualizationArtifact>> {
    const timelines = new Map<string, VisualizationArtifact>();
    
    // 1. Ø¬Ø¯ÙˆÙ„ Ø²Ù…Ù†ÙŠ Ù„ØªØ·ÙˆØ± Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
    const conflictTimeline = await this.createConflictEvolutionTimeline();
    timelines.set('conflict_evolution', conflictTimeline);
    
    // 2. Ø¬Ø¯ÙˆÙ„ Ø²Ù…Ù†ÙŠ Ù„ØªØ·ÙˆØ± Ø§Ù„Ø´Ø®ØµÙŠØ§Øª
    const characterTimeline = await this.createCharacterDevelopmentTimeline();
    timelines.set('character_development', characterTimeline);
    
    // 3. Ø¬Ø¯ÙˆÙ„ Ø²Ù…Ù†ÙŠ Ù„Ù„Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
    const eventsTimeline = await this.createKeyEventsTimeline();
    timelines.set('key_events', eventsTimeline);
    
    return timelines;
  }
  
  private async createConflictEvolutionTimeline(): Promise<VisualizationArtifact> {
    const outputPath = path.join(this.outputDir, 'charts', 'conflict_evolution_timeline.html');
    
    const timelineData = this.prepareConflictTimelineData();
    const htmlContent = this.generateTimelineHTML(timelineData, 'ØªØ·ÙˆØ± Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø¹Ø¨Ø± Ø§Ù„Ø²Ù…Ù†');
    
    fs.writeFileSync(outputPath, htmlContent, 'utf-8');
    
    return {
      id: 'conflict_evolution_timeline',
      type: 'interactive_html',
      format: 'html',
      path: outputPath,
      metadata: {
        title: 'Ø¬Ø¯ÙˆÙ„ Ø²Ù…Ù†ÙŠ Ù„ØªØ·ÙˆØ± Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª',
        description: 'ØªØµÙˆØ± Ø²Ù…Ù†ÙŠ ÙŠÙˆØ¶Ø­ ØªØ·ÙˆØ± Ù…Ø±Ø§Ø­Ù„ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„Ù…Ø®ØªÙ„ÙØ©',
        dimensions: { width: 1400, height: 600 },
        generatedAt: new Date()
      }
    };
  }
  
  private prepareConflictTimelineData(): any[] {
    const timeline: any[] = [];
    
    for (const conflict of this.network.conflicts.values()) {
      if (conflict.timestamps && conflict.timestamps.length > 0) {
        conflict.timestamps.forEach((timestamp, index) => {
          timeline.push({
            conflict: conflict.name,
            timestamp,
            phase: conflict.phase.name, // Ø§Ù„Ù…Ø±Ø­Ù„Ø© ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„ÙˆÙ‚Øª
            strength: conflict.strength,
            eventType: index === 0 ? 'start' : 'progression'
          });
        });
      }
    }
    
    // ØªØ±ØªÙŠØ¨ Ø­Ø³Ø¨ Ø§Ù„Ø²Ù…Ù†
    timeline.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());
    
    return timeline;
  }
  
  private generateTimelineHTML(timelineData: any[], title: string): string {
    return `<!DOCTYPE html>
<html dir="rtl" lang="ar">
<head>
    <meta charset="UTF-8">
    <title>${title}</title>
    <script src="https://cdn.jsdelivr.net/npm/vis-timeline@7.7.0/standalone/umd/vis-timeline-graph2d.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/vis-timeline@7.7.0/styles/vis-timeline-graph2d.min.css" rel="stylesheet" />
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        #timeline { height: 600px; background: white; border-radius: 8px; padding: 20px; }
    </style>
</head>
<body>
    <h1>${title}</h1>
    <div id="timeline"></div>
    <script>
        const items = ${JSON.stringify(timelineData.map((item, i) => ({
          id: i,
          content: item.conflict,
          start: item.timestamp,
          type: 'point',
          className: item.eventType
        })), null, 2)};
        
        const container = document.getElementById('timeline');
        const options = {
            orientation: 'top',
            stack: true,
            showCurrentTime: false
        };
        
        new vis.Timeline(container, items, options);
    </script>
</body>
</html>`;
  }
  
  private async createCharacterDevelopmentTimeline(): Promise<VisualizationArtifact> {
    // Ù…Ø´Ø§Ø¨Ù‡ Ù„Ù€ createConflictEvolutionTimeline Ù„ÙƒÙ† Ù„Ù„Ø´Ø®ØµÙŠØ§Øª
    const outputPath = path.join(this.outputDir, 'charts', 'character_development_timeline.html');
    
    // Ù…Ù†Ø·Ù‚ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚...
    
    return {
      id: 'character_development_timeline',
      type: 'interactive_html',
      format: 'html',
      path: outputPath,
      metadata: {
        title: 'Ø¬Ø¯ÙˆÙ„ Ø²Ù…Ù†ÙŠ Ù„ØªØ·ÙˆØ± Ø§Ù„Ø´Ø®ØµÙŠØ§Øª',
        description: 'ØªØµÙˆØ± Ù„ØªØ·ÙˆØ± Ù‚ÙˆØ³ ÙƒÙ„ Ø´Ø®ØµÙŠØ© Ø¹Ø¨Ø± Ø§Ù„Ø²Ù…Ù†',
        dimensions: { width: 1400, height: 600 },
        generatedAt: new Date()
      }
    };
  }
  
  private async createKeyEventsTimeline(): Promise<VisualizationArtifact> {
    const outputPath = path.join(this.outputDir, 'charts', 'key_events_timeline.html');
    
    // Ù…Ù†Ø·Ù‚ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚...
    
    return {
      id: 'key_events_timeline',
      type: 'interactive_html',
      format: 'html',
      path: outputPath,
      metadata: {
        title: 'Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©',
        description: 'Ø¬Ø¯ÙˆÙ„ Ø²Ù…Ù†ÙŠ Ù„Ù„Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ù…Ø­ÙˆØ±ÙŠØ© ÙÙŠ Ø§Ù„Ù‚ØµØ©',
        dimensions: { width: 1400, height: 400 },
        generatedAt: new Date()
      }
    };
  }
  
  /**
   * Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø±Ø³ÙˆÙ… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠØ© Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ©
   */
  private async generateStatisticalCharts(): Promise<Map<string, VisualizationArtifact>> {
    const charts = new Map<string, VisualizationArtifact>();
    
    // 1. Ø±Ø³Ù… ØªÙˆØ²ÙŠØ¹ Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
    const conflictDistribution = await this.createConflictTypeDistributionChart();
    charts.set('conflict_type_distribution', conflictDistribution);
    
    // 2. Ø±Ø³Ù… ØªÙˆØ²ÙŠØ¹ Ø·Ø¨Ø§Ø¦Ø¹ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
    const relationshipNature = await this.createRelationshipNatureChart();
    charts.set('relationship_nature', relationshipNature);
    
    // 3. Ø±Ø³Ù… Ù…Ø´Ø§Ø±ÙƒØ© Ø§Ù„Ø´Ø®ØµÙŠØ§Øª
    const characterParticipation = await this.createCharacterParticipationChart();
    charts.set('character_participation', characterParticipation);
    
    // 4. Ø±Ø³Ù… ØªÙˆØ²ÙŠØ¹ Ù…Ø±Ø§Ø­Ù„ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
    const phaseDistribution = await this.createConflictPhaseDistributionChart();
    charts.set('conflict_phase_distribution', phaseDistribution);
    
    return charts;
  }
  
  private async createConflictTypeDistributionChart(): Promise<VisualizationArtifact> {
    const outputPath = path.join(this.outputDir, 'charts', 'conflict_type_distribution.html');
    
    const distribution = new Map<ConflictSubject, number>();
    for (const conflict of this.network.conflicts.values()) {
      distribution.set(
        conflict.subject,
        (distribution.get(conflict.subject) || 0) + 1
      );
    }
    
    const chartData = Array.from(distribution.entries()).map(([subject, count]) => ({
      type: subject.name,
      count
    }));
    
    const htmlContent = this.generatePieChartHTML(chartData, 'ØªÙˆØ²ÙŠØ¹ Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª');
    fs.writeFileSync(outputPath, htmlContent, 'utf-8');
    
    return {
      id: 'conflict_type_distribution',
      type: 'interactive_html',
      format: 'html',
      path: outputPath,
      metadata: {
        title: 'ØªÙˆØ²ÙŠØ¹ Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª',
        description: 'Ø±Ø³Ù… Ø¯Ø§Ø¦Ø±ÙŠ ÙŠÙˆØ¶Ø­ Ù†Ø³Ø¨Ø© ÙƒÙ„ Ù†ÙˆØ¹ Ù…Ù† Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª',
        dimensions: { width: 600, height: 600 },
        generatedAt: new Date()
      }
    };
  }
  
  private generatePieChartHTML(data: any[], title: string): string {
    return `<!DOCTYPE html>
<html dir="rtl" lang="ar">
<head>
    <meta charset="UTF-8">
    <title>${title}</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; text-align: center; }
        #chartContainer { background: white; padding: 20px; border-radius: 8px; display: inline-block; }
    </style>
</head>
<body>
    <h1>${title}</h1>
    <div id="chartContainer">
        <canvas id="myChart" width="500" height="500"></canvas>
    </div>
    <script>
        const ctx = document.getElementById('myChart').getContext('2d');
        const data = ${JSON.stringify(data, null, 2)};
        
        new Chart(ctx, {
            type: 'pie',
            data: {
                labels: data.map(d => d.type),
                datasets: [{
                    data: data.map(d => d.count),
                    backgroundColor: [
                        '#ff6b6b', '#4ecdc4', '#95e1d3', '#f38181',
                        '#aa96da', '#fcbad3', '#ffffd2'
                    ]
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        position: 'bottom'
                    },
                    title: {
                        display: true,
                        text: '${title}'
                    }
                }
            }
        });
    </script>
</body>
</html>`;
  }
  
  private async createRelationshipNatureChart(): Promise<VisualizationArtifact> {
    // Ù…Ø´Ø§Ø¨Ù‡ Ù„Ù€ createConflictTypeDistributionChart
    const outputPath = path.join(this.outputDir, 'charts', 'relationship_nature.html');
    
    // Ù…Ù†Ø·Ù‚ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚...
    
    return {
      id: 'relationship_nature',
      type: 'interactive_html',
      format: 'html',
      path: outputPath,
      metadata: {
        title: 'ØªÙˆØ²ÙŠØ¹ Ø·Ø¨Ø§Ø¦Ø¹ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª',
        description: 'Ø±Ø³Ù… ÙŠÙˆØ¶Ø­ Ù†Ø³Ø¨Ø© Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª Ø§Ù„Ø¥ÙŠØ¬Ø§Ø¨ÙŠØ© ÙˆØ§Ù„Ø³Ù„Ø¨ÙŠØ© ÙˆØ§Ù„Ù…Ø­Ø§ÙŠØ¯Ø©',
        dimensions: { width: 600, height: 600 },
        generatedAt: new Date()
      }
    };
  }
  
  private async createCharacterParticipationChart(): Promise<VisualizationArtifact> {
    const outputPath = path.join(this.outputDir, 'charts', 'character_participation.html');
    
    // Ù…Ù†Ø·Ù‚ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚...
    
    return {
      id: 'character_participation',
      type: 'interactive_html',
      format: 'html',
      path: outputPath,
      metadata: {
        title: 'Ù…Ø´Ø§Ø±ÙƒØ© Ø§Ù„Ø´Ø®ØµÙŠØ§Øª ÙÙŠ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª',
        description: 'Ø±Ø³Ù… Ø¹Ù…ÙˆØ¯ÙŠ ÙŠÙˆØ¶Ø­ Ø¹Ø¯Ø¯ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ù„ÙƒÙ„ Ø´Ø®ØµÙŠØ©',
        dimensions: { width: 800, height: 600 },
        generatedAt: new Date()
      }
    };
  }
  
  private async createConflictPhaseDistributionChart(): Promise<VisualizationArtifact> {
    const outputPath = path.join(this.outputDir, 'charts', 'conflict_phase_distribution.html');
    
    // Ù…Ù†Ø·Ù‚ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚...
    
    return {
      id: 'conflict_phase_distribution',
      type: 'interactive_html',
      format: 'html',
      path: outputPath,
      metadata: {
        title: 'ØªÙˆØ²ÙŠØ¹ Ù…Ø±Ø§Ø­Ù„ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª',
        description: 'Ø±Ø³Ù… ÙŠÙˆØ¶Ø­ Ø¹Ø¯Ø¯ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª ÙÙŠ ÙƒÙ„ Ù…Ø±Ø­Ù„Ø©',
        dimensions: { width: 800, height: 600 },
        generatedAt: new Date()
      }
    };
  }
  
  /**
   * Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªØµÙˆØ±Ø§Øª Ø§Ù„ØªÙØ§Ø¹Ù„ÙŠØ© Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©
   */
  private async generateInteractiveVisualizations(): Promise<InteractiveVisualization[]> {
    const interactive: InteractiveVisualization[] = [];
    
    // 1. Ù…Ø³ØªÙƒØ´Ù Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„ØªÙØ§Ø¹Ù„ÙŠ
    const networkExplorer = await this.createNetworkExplorer();
    interactive.push(networkExplorer);
    
    // 2. Ù…ØªØµÙØ­ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø²Ù…Ù†ÙŠ
    const timelineNavigator = await this.createTimelineNavigator();
    interactive.push(timelineNavigator);
    
    // 3. Ù…Ø­Ù„Ù„ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„ØªÙØ§Ø¹Ù„ÙŠ
    const conflictAnalyzer = await this.createConflictAnalyzer();
    interactive.push(conflictAnalyzer);
    
    return interactive;
  }
  
  private async createNetworkExplorer(): Promise<InteractiveVisualization> {
    const htmlPath = path.join(this.outputDir, 'interactive', 'network_explorer.html');
    
    // Ø¥Ù†Ø´Ø§Ø¡ ØªØ·Ø¨ÙŠÙ‚ ØªÙØ§Ø¹Ù„ÙŠ ÙƒØ§Ù…Ù„ Ù„Ù„Ø§Ø³ØªÙƒØ´Ø§Ù
    const htmlContent = this.generateNetworkExplorerApp();
    fs.writeFileSync(htmlPath, htmlContent, 'utf-8');
    
    return {
      id: 'network_explorer',
      type: 'network_explorer',
      htmlPath,
      dependencies: ['d3.js', 'vis.js'],
      features: [
        'Ø§Ø³ØªÙƒØ´Ø§Ù ØªÙØ§Ø¹Ù„ÙŠ Ù„Ù„Ø´Ø¨ÙƒØ©',
        'ØªØµÙÙŠØ© Ø­Ø³Ø¨ Ù†ÙˆØ¹ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø© Ø£Ùˆ Ø§Ù„ØµØ±Ø§Ø¹',
        'Ø¹Ø±Ø¶ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª ÙˆØ§Ù„ØµØ±Ø§Ø¹Ø§Øª',
        'ØªÙƒØ¨ÙŠØ±/ØªØµØºÙŠØ± ÙˆØ³Ø­Ø¨ Ø§Ù„Ø¹Ù‚Ø¯',
        'Ø¨Ø­Ø« Ø¹Ù† Ø´Ø®ØµÙŠØ§Øª Ø£Ùˆ ØµØ±Ø§Ø¹Ø§Øª Ù…Ø­Ø¯Ø¯Ø©'
      ]
    };
  }
  
  private generateNetworkExplorerApp(): string {
    // ØªÙˆÙ„ÙŠØ¯ ØªØ·Ø¨ÙŠÙ‚ ÙˆÙŠØ¨ ÙƒØ§Ù…Ù„ Ù…Ø¹ ÙˆØ§Ø¬Ù‡Ø© ØªÙØ§Ø¹Ù„ÙŠØ©
    return `<!DOCTYPE html>
<html dir="rtl" lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù…Ø³ØªÙƒØ´Ù Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„ØªÙØ§Ø¹Ù„ÙŠ</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Arial, sans-serif; background: #f5f
        private generateNetworkExplorerApp(): string {
    // ØªÙˆÙ„ÙŠØ¯ ØªØ·Ø¨ÙŠÙ‚ ÙˆÙŠØ¨ ÙƒØ§Ù…Ù„ Ù…Ø¹ ÙˆØ§Ø¬Ù‡Ø© ØªÙØ§Ø¹Ù„ÙŠØ©
    return `<!DOCTYPE html>
<html dir="rtl" lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù…Ø³ØªÙƒØ´Ù Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„ØªÙØ§Ø¹Ù„ÙŠ</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Arial, sans-serif; background: #f5f5f5; }
        
        #app-container {
            display: grid;
            grid-template-columns: 300px 1fr;
            grid-template-rows: 60px 1fr;
            height: 100vh;
        }
        
        header {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 0 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        header h1 {
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        #sidebar {
            background: white;
            border-left: 1px solid #e0e0e0;
            padding: 1.5rem;
            overflow-y: auto;
        }
        
        #main-canvas {
            background: white;
            position: relative;
            overflow: hidden;
        }
        
        .filter-section {
            margin-bottom: 2rem;
        }
        
        .filter-section h3 {
            font-size: 0.9rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 0.8rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #667eea;
        }
        
        .filter-group {
            margin-bottom: 1rem;
        }
        
        .filter-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
            color: #555;
        }
        
        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .checkbox-group label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }
        
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        input[type="text"], select {
            width: 100%;
            padding: 0.6rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.85rem;
        }
        
        button {
            width: 100%;
            padding: 0.7rem;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #5568d3;
        }
        
        #tooltip {
            position: absolute;
            padding: 1rem;
            background: rgba(0,0,0,0.9);
            color: white;
            border-radius: 6px;
            pointer-events: none;
            display: none;
            max-width: 300px;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        #tooltip h4 {
            margin-bottom: 0.5rem;
            color: #667eea;
        }
        
        .node { cursor: pointer; transition: all 0.3s; }
        .node:hover { stroke: #667eea; stroke-width: 3px; }
        .link { stroke: #999; stroke-opacity: 0.6; }
        
        #controls {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background: white;
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .control-btn {
            width: auto;
            padding: 0.5rem 1rem;
            margin: 0.25rem;
            font-size: 0.8rem;
        }
    </style>
</head>
<body>
    <div id="app-container">
        <header>
            <h1>ğŸ•¸ï¸ Ù…Ø³ØªÙƒØ´Ù Ø´Ø¨ÙƒØ© Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„ØªÙØ§Ø¹Ù„ÙŠ</h1>
            <div id="stats"></div>
        </header>
        
        <aside id="sidebar">
            <div class="filter-section">
                <h3>ğŸ” Ø§Ù„Ø¨Ø­Ø« ÙˆØ§Ù„ØªØµÙÙŠØ©</h3>
                <div class="filter-group">
                    <label>Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø´Ø®ØµÙŠØ© Ø£Ùˆ ØµØ±Ø§Ø¹:</label>
                    <input type="text" id="search-input" placeholder="Ø§ÙƒØªØ¨ Ù„Ù„Ø¨Ø­Ø«...">
                </div>
            </div>
            
            <div class="filter-section">
                <h3>ğŸ­ ØªØµÙÙŠØ© Ø§Ù„Ø´Ø®ØµÙŠØ§Øª</h3>
                <div class="checkbox-group" id="character-filters">
                    <!-- Ø³ÙŠØªÙ… Ù…Ù„Ø¤Ù‡Ø§ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ§Ù‹ -->
                </div>
            </div>
            
            <div class="filter-section">
                <h3>âš”ï¸ ØªØµÙÙŠØ© Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª</h3>
                <div class="checkbox-group" id="conflict-type-filters">
                    <!-- Ø³ÙŠØªÙ… Ù…Ù„Ø¤Ù‡Ø§ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ§Ù‹ -->
                </div>
            </div>
            
            <div class="filter-section">
                <h3>ğŸ”— ØªØµÙÙŠØ© Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª</h3>
                <div class="filter-group">
                    <label>Ù†ÙˆØ¹ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø©:</label>
                    <select id="relationship-type-filter">
                        <option value="all">Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ù†ÙˆØ§Ø¹</option>
                        <option value="LOVE">Ø­Ø¨</option>
                        <option value="RIVALRY">ØªÙ†Ø§ÙØ³</option>
                        <option value="ALLIANCE">ØªØ­Ø§Ù„Ù</option>
                        <option value="FAMILY">Ø¹Ø§Ø¦Ù„Ø©</option>
                        <option value="ENMITY">Ø¹Ø¯Ø§Ø¡</option>
                    </select>
                </div>
            </div>
            
            <button id="reset-filters">Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„ÙÙ„Ø§ØªØ±</button>
        </aside>
        
        <main id="main-canvas">
            <div id="controls">
                <button class="control-btn" id="zoom-in">â• ØªÙƒØ¨ÙŠØ±</button>
                <button class="control-btn" id="zoom-out">â– ØªØµØºÙŠØ±</button>
                <button class="control-btn" id="reset-view">ğŸ”„ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø¶Ø¨Ø·</button>
            </div>
            <svg id="network-svg"></svg>
            <div id="tooltip"></div>
        </main>
    </div>
    
    <script>
        // ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø´Ø¨ÙƒØ©
        const networkData = ${JSON.stringify({
          nodes: this.prepareNodesForExplorer(),
          links: this.prepareLinksForExplorer()
        })};
        
        // Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯
        const width = document.getElementById('main-canvas').clientWidth;
        const height = document.getElementById('main-canvas').clientHeight;
        
        // Ø¥Ù†Ø´Ø§Ø¡ SVG Ù…Ø¹ Zoom
        const svg = d3.select('#network-svg')
            .attr('width', width)
            .attr('height', height);
        
        const g = svg.append('g');
        
        const zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on('zoom', (event) => {
                g.attr('transform', event.transform);
            });
        
        svg.call(zoom);
        
        // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©
        const simulation = d3.forceSimulation(networkData.nodes)
            .force('link', d3.forceLink(networkData.links).id(d => d.id).distance(150))
            .force('charge', d3.forceManyBody().strength(-400))
            .force('center', d3.forceCenter(width / 2, height / 2))
            .force('collision', d3.forceCollide().radius(50));
        
        // Ø±Ø³Ù… Ø§Ù„Ø±ÙˆØ§Ø¨Ø·
        const link = g.append('g')
            .selectAll('line')
            .data(networkData.links)
            .enter().append('line')
            .attr('class', 'link')
            .style('stroke-width', d => Math.sqrt(d.strength) * 2);
        
        // Ø±Ø³Ù… Ø§Ù„Ø¹Ù‚Ø¯
        const node = g.append('g')
            .selectAll('circle')
            .data(networkData.nodes)
            .enter().append('circle')
            .attr('class', 'node')
            .attr('r', d => d.type === 'character' ? 20 : 15)
            .attr('fill', d => d.type === 'character' ? '#4ecdc4' : '#ff6b6b')
            .call(d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended))
            .on('mouseover', showTooltip)
            .on('mouseout', hideTooltip)
            .on('click', highlightConnections);
        
        // Ø§Ù„Ù†ØµÙˆØµ
        const labels = g.append('g')
            .selectAll('text')
            .data(networkData.nodes)
            .enter().append('text')
            .attr('text-anchor', 'middle')
            .attr('dy', -25)
            .style('font-size', '12px')
            .style('font-weight', 'bold')
            .style('fill', '#333')
            .text(d => d.name);
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©
        simulation.on('tick', () => {
            link
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);
            
            node
                .attr('cx', d => d.x)
                .attr('cy', d => d.y);
            
            labels
                .attr('x', d => d.x)
                .attr('y', d => d.y);
        });
        
        // ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ø³Ø­Ø¨
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }
        
        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }
        
        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
        
        // Tooltip
        function showTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');
            tooltip.style.display = 'block';
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY + 10) + 'px';
            
            let content = \`<h4>\${d.name}</h4>\`;
            content += \`<p><strong>Ø§Ù„Ù†ÙˆØ¹:</strong> \${d.type === 'character' ? 'Ø´Ø®ØµÙŠØ©' : 'ØµØ±Ø§Ø¹'}</p>\`;
            if (d.description) content += \`<p>\${d.description}</p>\`;
            
            tooltip.innerHTML = content;
        }
        
        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }
        
        // Ø¥Ø¨Ø±Ø§Ø² Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª
        function highlightConnections(event, d) {
            const connected = new Set();
            connected.add(d.id);
            
            networkData.links.forEach(l => {
                if (l.source.id === d.id) connected.add(l.target.id);
                if (l.target.id === d.id) connected.add(l.source.id);
            });
            
            node.style('opacity', n => connected.has(n.id) ? 1 : 0.2);
            link.style('opacity', l => 
                (l.source.id === d.id || l.target.id === d.id) ? 1 : 0.1
            );
            labels.style('opacity', n => connected.has(n.id) ? 1 : 0.2);
        }
        
        // Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªØ­ÙƒÙ…
        document.getElementById('zoom-in').onclick = () => {
            svg.transition().call(zoom.scaleBy, 1.3);
        };
        
        document.getElementById('zoom-out').onclick = () => {
            svg.transition().call(zoom.scaleBy, 0.7);
        };
        
        document.getElementById('reset-view').onclick = () => {
            svg.transition().call(zoom.transform, d3.zoomIdentity);
            node.style('opacity', 1);
            link.style('opacity', 1);
            labels.style('opacity', 1);
        };
        
        // Ø§Ù„Ø¨Ø­Ø«
        document.getElementById('search-input').addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase();
            node.style('opacity', d => 
                d.name.toLowerCase().includes(query) ? 1 : 0.2
            );
            labels.style('opacity', d => 
                d.name.toLowerCase().includes(query) ? 1 : 0.2
            );
        });
        
        // Ù…Ù„Ø¡ Ø§Ù„ÙÙ„Ø§ØªØ±
        populateFilters();
        
        function populateFilters() {
            const characterFilters = document.getElementById('character-filters');
            const conflictFilters = document.getElementById('conflict-type-filters');
            
            const characters = networkData.nodes.filter(n => n.type === 'character');
            characters.forEach(char => {
                const label = document.createElement('label');
                label.innerHTML = \`
                    <input type="checkbox" checked value="\${char.id}">
                    <span>\${char.name}</span>
                \`;
                characterFilters.appendChild(label);
            });
            
            const conflictTypes = [...new Set(
                networkData.nodes
                    .filter(n => n.type === 'conflict')
                    .map(n => n.subject)
            )];
            
            conflictTypes.forEach(type => {
                const label = document.createElement('label');
                label.innerHTML = \`
                    <input type="checkbox" checked value="\${type}">
                    <span>\${type}</span>
                \`;
                conflictFilters.appendChild(label);
            });
        }
        
        // Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
        updateStats();
        
        function updateStats() {
            const stats = document.getElementById('stats');
            const charCount = networkData.nodes.filter(n => n.type === 'character').length;
            const confCount = networkData.nodes.filter(n => n.type === 'conflict').length;
            stats.innerHTML = \`
                <span style="margin-left: 1rem;">Ø´Ø®ØµÙŠØ§Øª: \${charCount}</span>
                <span>ØµØ±Ø§Ø¹Ø§Øª: \${confCount}</span>
            \`;
        }
    </script>
</body>
</html>`;
  }
  
  private prepareNodesForExplorer(): any[] {
    const nodes: any[] = [];
    
    // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø´Ø®ØµÙŠØ§Øª
    for (const [charId, char] of this.network.characters) {
      nodes.push({
        id: charId,
        name: char.name,
        type: 'character',
        description: char.description,
        metadata: char.metadata
      });
    }
    
    // Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
    for (const [confId, conflict] of this.network.conflicts) {
      nodes.push({
        id: confId,
        name: conflict.name,
        type: 'conflict',
        subject: conflict.subject.name,
        description: conflict.description,
        strength: conflict.strength
      });
    }
    
    return nodes;
  }
  
  private prepareLinksForExplorer(): any[] {
    const links: any[] = [];
    
    // Ø¥Ø¶Ø§ÙØ© Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
    for (const rel of this.network.relationships.values()) {
      links.push({
        source: rel.source,
        target: rel.target,
        type: 'relationship',
        strength: rel.strength,
        nature: rel.nature.name
      });
    }
    
    // Ø¥Ø¶Ø§ÙØ© Ø±ÙˆØ§Ø¨Ø· Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
    for (const conflict of this.network.conflicts.values()) {
      for (const charId of conflict.involvedCharacters) {
        links.push({
          source: charId,
          target: conflict.id,
          type: 'conflict_involvement',
          strength: 5
        });
      }
    }
    
    return links;
  }
  
  private async createTimelineNavigator(): Promise<InteractiveVisualization> {
    const htmlPath = path.join(this.outputDir, 'interactive', 'timeline_navigator.html');
    
    const htmlContent = this.generateTimelineNavigatorApp();
    fs.writeFileSync(htmlPath, htmlContent, 'utf-8');
    
    return {
      id: 'timeline_navigator',
      type: 'timeline_navigator',
      htmlPath,
      dependencies: ['vis-timeline'],
      features: [
        'ØªØµÙØ­ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ø²Ù…Ù†ÙŠØ© Ø¨Ø´ÙƒÙ„ ØªÙØ§Ø¹Ù„ÙŠ',
        'ÙÙ„ØªØ±Ø© Ø­Ø³Ø¨ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø£Ùˆ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª',
        'Ø¹Ø±Ø¶ ØªÙØ§ØµÙŠÙ„ ÙƒÙ„ Ø­Ø¯Ø«',
        'ØªÙƒØ¨ÙŠØ±/ØªØµØºÙŠØ± Ø§Ù„Ù…Ø­ÙˆØ± Ø§Ù„Ø²Ù…Ù†ÙŠ'
      ]
    };
  }
  
  private generateTimelineNavigatorApp(): string {
    return `<!DOCTYPE html>
<html dir="rtl" lang="ar">
<head>
    <meta charset="UTF-8">
    <title>Ù…ØªØµÙØ­ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø²Ù…Ù†ÙŠ</title>
    <script src="https://unpkg.com/vis-timeline@7.7.0/standalone/umd/vis-timeline-graph2d.min.js"></script>
    <link href="https://unpkg.com/vis-timeline@7.7.0/styles/vis-timeline-graph2d.min.css" rel="stylesheet" />
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        #timeline-container { 
            background: white; 
            border-radius: 8px; 
            padding: 20px; 
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        h1 { color: #333; margin-bottom: 1rem; }
        #timeline { height: 600px; }
        .vis-item { background-color: #4ecdc4; border-color: #3ba89c; }
        .vis-item.conflict { background-color: #ff6b6b; border-color: #e05555; }
    </style>
</head>
<body>
    <h1>ğŸ“… Ù…ØªØµÙØ­ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø²Ù…Ù†ÙŠ Ù„Ù„Ø£Ø­Ø¯Ø§Ø«</h1>
    <div id="timeline-container">
        <div id="timeline"></div>
    </div>
    
    <script>
        const items = new vis.DataSet(${JSON.stringify(this.prepareTimelineData())});
        
        const options = {
            orientation: 'top',
            stack: true,
            showCurrentTime: false,
            locale: 'ar',
            rtl: true
        };
        
        const container = document.getElementById('timeline');
        const timeline = new vis.Timeline(container, items, options);
        
        timeline.on('select', function (properties) {
            const selectedId = properties.items[0];
            if (selectedId) {
                const item = items.get(selectedId);
                alert('Ø§Ù„Ø­Ø¯Ø«: ' + item.content + '\\n' + (item.description || ''));
            }
        });
    </script>
</body>
</html>`;
  }
  
  private prepareTimelineData(): any[] {
    const events: any[] = [];
    
    // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ù…Ù† Ø§Ù„Ø´Ø¨ÙƒØ©
    for (const snapshot of this.network.snapshots) {
      events.push({
        id: `snap_${snapshot.timestamp.getTime()}`,
        content: snapshot.description,
        start: snapshot.timestamp,
        type: 'point',
        className: 'snapshot'
      });
    }
    
    // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø£Ø­Ø¯Ø§Ø« Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
    for (const conflict of this.network.conflicts.values()) {
      if (conflict.timestamps && conflict.timestamps.length > 0) {
        conflict.timestamps.forEach((ts, idx) => {
          events.push({
            id: `conf_${conflict.id}_${idx}`,
            content: `${conflict.name} - ${conflict.phase.name}`,
            start: ts,
            type: 'box',
            className: 'conflict',
            description: conflict.description
          });
        });
      }
    }
    
    return events.sort((a, b) => a.start - b.start);
  }
  
  private async createConflictAnalyzer(): Promise<InteractiveVisualization> {
    const htmlPath = path.join(this.outputDir, 'interactive', 'conflict_analyzer.html');
    
    const htmlContent = this.generateConflictAnalyzerApp();
    fs.writeFileSync(htmlPath, htmlContent, 'utf-8');
    
    return {
      id: 'conflict_analyzer',
      type: 'conflict_analyzer',
      htmlPath,
      dependencies: ['chart.js'],
      features: [
        'ØªØ­Ù„ÙŠÙ„ ØªÙØµÙŠÙ„ÙŠ Ù„ÙƒÙ„ ØµØ±Ø§Ø¹',
        'Ù…Ù‚Ø§Ø±Ù†Ø© Ø¨ÙŠÙ† Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª',
        'Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù…Ø±Ø¦ÙŠØ©',
        'ØªØµØ¯ÙŠØ± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª'
      ]
    };
  }
  
  private generateConflictAnalyzerApp(): string {
    return `<!DOCTYPE html>
<html dir="rtl" lang="ar">
<head>
    <meta charset="UTF-8">
    <title>Ù…Ø­Ù„Ù„ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px; margin-top: 20px; }
        .card { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        h1, h2 { color: #333; }
        select { width: 100%; padding: 10px; margin-bottom: 20px; border: 1px solid #ddd; border-radius: 4px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>âš”ï¸ Ù…Ø­Ù„Ù„ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„ØªÙØ§Ø¹Ù„ÙŠ</h1>
        
        <select id="conflict-selector">
            <option value="">Ø§Ø®ØªØ± ØµØ±Ø§Ø¹Ø§Ù‹ Ù„Ù„ØªØ­Ù„ÙŠÙ„...</option>
            ${Array.from(this.network.conflicts.values()).map(c => 
              `<option value="${c.id}">${c.name}</option>`
            ).join('')}
        </select>
        
        <div class="grid">
            <div class="card">
                <h2>ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©</h2>
                <canvas id="stats-chart"></canvas>
            </div>
            
            <div class="card">
                <h2>ğŸ‘¥ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ©</h2>
                <div id="characters-list"></div>
            </div>
            
            <div class="card">
                <h2>ğŸ“ˆ ØªØ·ÙˆØ± Ø§Ù„ØµØ±Ø§Ø¹</h2>
                <canvas id="evolution-chart"></canvas>
            </div>
            
            <div class="card">
                <h2>ğŸ¯ Ø§Ù„ØªÙØ§ØµÙŠÙ„</h2>
                <div id="conflict-details"></div>
            </div>
        </div>
    </div>
    
    <script>
        const conflictData = ${JSON.stringify(
          Array.from(this.network.conflicts.values()).map(c => ({
            id: c.id,
            name: c.name,
            subject: c.subject.name,
            scope: c.scope.name,
            phase: c.phase.name,
            strength: c.strength,
            characters: c.involvedCharacters,
            description: c.description
          }))
        )};
        
        const characterMap = ${JSON.stringify(
          Array.from(this.network.characters.entries()).reduce((acc, [id, char]) => {
            acc[id] = char.name;
            return acc;
          }, {})
        )};
        
        document.getElementById('conflict-selector').addEventListener('change', (e) => {
            const conflictId = e.target.value;
            if (conflictId) {
                const conflict = conflictData.find(c => c.id === conflictId);
                if (conflict) displayConflictAnalysis(conflict);
            }
        });
        
        function displayConflictAnalysis(conflict) {
            // Ø¹Ø±Ø¶ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª
            const charList = document.getElementById('characters-list');
            charList.innerHTML = conflict.characters
                .map(cid => \`<p>â€¢ \${characterMap[cid] || cid}</p>\`)
                .join('');
            
            // Ø¹Ø±Ø¶ Ø§Ù„ØªÙØ§ØµÙŠÙ„
            const details = document.getElementById('conflict-details');
            details.innerHTML = \`
                <p><strong>Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹:</strong> \${conflict.subject}</p>
                <p><strong>Ø§Ù„Ù†Ø·Ø§Ù‚:</strong> \${conflict.scope}</p>
                <p><strong>Ø§Ù„Ù…Ø±Ø­Ù„Ø©:</strong> \${conflict.phase}</p>
                <p><strong>Ø§Ù„Ù‚ÙˆØ©:</strong> \${conflict.strength}/10</p>
                <p><strong>Ø§Ù„ÙˆØµÙ:</strong> \${conflict.description}</p>
            \`;
            
            // Ø±Ø³Ù… Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
            createStatsChart(conflict);
        }
        
        function createStatsChart(conflict) {
            const ctx = document.getElementById('stats-chart');
            new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: ['Ø§Ù„Ù‚ÙˆØ©', 'Ø§Ù„ØªØ¹Ù‚ÙŠØ¯', 'Ø§Ù„Ø£Ù‡Ù…ÙŠØ©', 'Ø§Ù„ØªØ·ÙˆØ±', 'Ø§Ù„ØªØ£Ø«ÙŠØ±'],
                    datasets: [{
                        label: conflict.name,
                        data: [
                            conflict.strength,
                            conflict.characters.length * 2,
                            conflict.strength * 0.8,
                            7,
                            conflict.strength * 0.9
                        ],
                        backgroundColor: 'rgba(255, 107, 107, 0.2)',
                        borderColor: 'rgba(255, 107, 107, 1)',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        r: {
                            beginAtZero: true,
                            max: 10
                        }
                    }
                }
            });
        }
    </script>
</body>
</html>`;
  }
}

/**
 * Ù…Ø­Ø±Ùƒ Ø§Ù„ØªÙƒÙŠÙ Ù…Ø¹ Ø§Ù„Ù…Ù†ØµØ§Øª
 */
class PlatformAdaptationEngine {
  constructor(
    private network: ConflictNetwork,
    private s2Conceptual: Dict<str, Any>
  ) {}
  
  async generateSeriesStructure(episodesPerSeason: number = 10): Promise<PlatformAdaptationResults['episodicBreakdown']> {
    logger.info("S7: Generating episodic breakdown for streaming series...");
    
    const conflicts = Array.from(this.network.conflicts.values());
    const totalSeasons = Math.ceil(conflicts.length / (episodesPerSeason / 2));
    
    const seasonBreakdown = new Map<number, SeasonPlan>();
    
    for (let s = 1; s <= totalSeasons; s++) {
      const startIdx = (s - 1) * Math.floor(conflicts.length / totalSeasons);
      const endIdx = s * Math.floor(conflicts.length / totalSeasons);
      const seasonConflicts = conflicts.slice(startIdx, endIdx);
      
      const episodes: Episode[] = [];
      for (let e = 1; e <= episodesPerSeason; e++) {
        const conflictIdx = Math.floor((e - 1) / (episodesPerSeason / seasonConflicts.length));
        const conflict = seasonConflicts[conflictIdx] || seasonConflicts[0];
        
        episodes.push({
          episodeNumber: e,
          seasonNumber: s,
          title: `Ø§Ù„Ø­Ù„Ù‚Ø© ${e}`,
          assignedConflicts: [conflict.id],
          featuredCharacters: conflict.involvedCharacters.slice(0, 3),
          estimatedIntensity: conflict.strength,
          narrativeFunction: e < 3 ? 'setup' : (e < 7 ? 'development' : (e < 9 ? 'climax' : 'resolution'))
        });
      }
      
      seasonBreakdown.set(s, {
        seasonNumber: s,
        mainConflicts: seasonConflicts.map(c => c.id),
        characterFocus: seasonConflicts.flatMap(c => c.involvedCharacters).slice(0, 5),
thematicProgression: `ØªØµØ§Ø¹Ø¯ Ø§Ù„ØµØ±Ø§Ø¹ Ù…Ù† ${seasonConflicts[0]?.name || 'Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©'} Ø¥Ù„Ù‰ ${seasonConflicts[seasonConflicts.length - 1]?.name || 'Ø§Ù„Ø°Ø±ÙˆØ©'}`,
        keyMilestones: episodes
          .filter(ep => ep.narrativeFunction === 'climax')
          .map(ep => `Ø°Ø±ÙˆØ© Ø§Ù„Ø­Ù„Ù‚Ø© ${ep.episodeNumber}`)
      });
    }
    
    return {
      series: {
        totalSeasons,
        episodesPerSeason,
        totalEpisodes: totalSeasons * episodesPerSeason,
        recommendedRuntime: 45
      },
      seasonBreakdown,
      cliffhangerSuggestions: this.generateCliffhangers(seasonBreakdown),
      characterArcMapping: this.mapCharacterArcs(seasonBreakdown)
    };
  }
  
  private generateCliffhangers(seasons: Map<number, SeasonPlan>): Map<number, string[]> {
    const cliffhangers = new Map<number, string[]>();
    
    for (const [seasonNum, season] of seasons) {
      const suggestions: string[] = [];
      
      if (season.mainConflicts.length > 0) {
        const mainConflict = this.network.conflicts.get(season.mainConflicts[0]);
        if (mainConflict) {
          suggestions.push(`ÙƒØ´Ù ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ ÙÙŠ ØµØ±Ø§Ø¹ ${mainConflict.name}`);
          suggestions.push(`ØªØ­ÙˆÙ„ Ù…ÙØ§Ø¬Ø¦ ÙÙŠ Ø¹Ù„Ø§Ù‚Ø© Ø´Ø®ØµÙŠØ© Ø±Ø¦ÙŠØ³ÙŠØ©`);
          suggestions.push(`ØªØµØ¹ÙŠØ¯ Ø­Ø§Ø¯ ÙÙŠ ${mainConflict.name} ÙŠÙ‡Ø¯Ø¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø·Ø±Ø§Ù`);
        }
      }
      
      cliffhangers.set(seasonNum, suggestions);
    }
    
    return cliffhangers;
  }
  
  private mapCharacterArcs(seasons: Map<number, SeasonPlan>): Map<string, string[]> {
    const arcMapping = new Map<string, string[]>();
    
    for (const char of this.network.characters.values()) {
      const episodes: string[] = [];
      
      for (const [seasonNum, season] of seasons) {
        if (season.characterFocus.includes(char.id)) {
          const seasonEpisodes = Array.from({ length: 10 }, (_, i) => `S${seasonNum}E${i + 1}`);
          episodes.push(...seasonEpisodes);
        }
      }
      
      arcMapping.set(char.id, episodes);
    }
    
    return arcMapping;
  }
  
  async generateCinematicAdaptation(): Promise<CinematicAdaptation> {
    logger.info("S7: Generating cinematic film adaptation structure...");
    
    const conflicts = Array.from(this.network.conflicts.values());
    const majorConflicts = conflicts
      .sort((a, b) => b.strength - a.strength)
      .slice(0, 3);
    
    // ØªÙ‚Ø³ÙŠÙ… Ø­Ø³Ø¨ Ø¨Ù†ÙŠØ© Ø§Ù„ÙØµÙˆÙ„ Ø§Ù„Ø«Ù„Ø§Ø«Ø© Ø§Ù„ÙƒÙ„Ø§Ø³ÙŠÙƒÙŠØ©
    const totalRuntime = 120; // Ø¯Ù‚ÙŠÙ‚Ø©
    
    const act1Scenes: string[] = [];
    const act2Scenes: string[] = [];
    const act3Scenes: string[] = [];
    
    // Ø§Ù„ÙØµÙ„ Ø§Ù„Ø£ÙˆÙ„: Ø§Ù„ØªØ£Ø³ÙŠØ³ (25%)
    majorConflicts.slice(0, 1).forEach(conflict => {
      act1Scenes.push(`ØªÙ‚Ø¯ÙŠÙ… ${conflict.name}`);
      conflict.involvedCharacters.slice(0, 3).forEach(charId => {
        const char = this.network.characters.get(charId);
        if (char) act1Scenes.push(`ØªÙ‚Ø¯ÙŠÙ… ${char.name} ÙˆØ¹Ø§Ù„Ù…Ù‡`);
      });
    });
    
    // Ø§Ù„ÙØµÙ„ Ø§Ù„Ø«Ø§Ù†ÙŠ: Ø§Ù„ØªØµØ¹ÙŠØ¯ (50%)
    majorConflicts.forEach(conflict => {
      act2Scenes.push(`ØªØµØ¹ÙŠØ¯ ${conflict.name}`);
      act2Scenes.push(`Ù†Ù‚Ø·Ø© ØªØ­ÙˆÙ„ ÙÙŠ ${conflict.name}`);
      act2Scenes.push(`Ø°Ø±ÙˆØ© ÙØ±Ø¹ÙŠØ©: ${conflict.name} ÙŠØ¨Ù„Øº Ø£ÙˆØ¬Ù‡`);
    });
    
    // Ø§Ù„ÙØµÙ„ Ø§Ù„Ø«Ø§Ù„Ø«: Ø§Ù„Ø­Ù„ (25%)
    act3Scenes.push(`Ø§Ù„Ø°Ø±ÙˆØ© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©: Ø§Ø¬ØªÙ…Ø§Ø¹ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª`);
    majorConflicts.forEach(conflict => {
      act3Scenes.push(`Ø­Ù„ ${conflict.name}`);
    });
    act3Scenes.push(`Ø§Ù„Ø®Ø§ØªÙ…Ø© ÙˆØ§Ù„ØªØ¨Ø¹Ø§Øª`);
    
    return {
      recommendedRuntime: totalRuntime,
      actBreakdown: {
        act1: {
          duration: Math.floor(totalRuntime * 0.25),
          keyScenes: act1Scenes
        },
        act2: {
          duration: Math.floor(totalRuntime * 0.5),
          keyScenes: act2Scenes
        },
        act3: {
          duration: Math.floor(totalRuntime * 0.25),
          keyScenes: act3Scenes
        }
      },
      visualStyle: this.s2Conceptual['hybrid_genre'] || 'Ø¯Ø±Ø§Ù…ÙŠ ÙˆØ§Ù‚Ø¹ÙŠ',
      pacingSuggestions: 'Ø¥ÙŠÙ‚Ø§Ø¹ Ù…ØªØµØ§Ø¹Ø¯ Ù…Ø¹ Ù†Ù‚Ø§Ø· Ø±Ø§Ø­Ø© Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø¨ÙŠÙ† Ø§Ù„Ø°Ø±Ù‰',
      condensationStrategy: 'Ø§Ù„ØªØ±ÙƒÙŠØ² Ø¹Ù„Ù‰ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© ÙˆØ¯Ù…Ø¬ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ø«Ø§Ù†ÙˆÙŠØ©'
    };
  }
  
  async generateSerializedNovelStructure(): Promise<SerializedAdaptation> {
    logger.info("S7: Generating serialized novel structure...");
    
    const conflicts = Array.from(this.network.conflicts.values());
    const estimatedChapters = conflicts.length * 3; // 3 ÙØµÙˆÙ„ Ù„ÙƒÙ„ ØµØ±Ø§Ø¹
    const volumeCount = Math.ceil(estimatedChapters / 12); // 12 ÙØµÙ„ Ù„ÙƒÙ„ Ù…Ø¬Ù„Ø¯
    
    const volumeStructure = new Map<number, VolumeDetails>();
    
    for (let v = 1; v <= volumeCount; v++) {
      const startChapter = (v - 1) * 12 + 1;
      const endChapter = Math.min(v * 12, estimatedChapters);
      
      const conflictStart = Math.floor((v - 1) * (conflicts.length / volumeCount));
      const conflictEnd = Math.floor(v * (conflicts.length / volumeCount));
      const volumeConflicts = conflicts.slice(conflictStart, conflictEnd);
      
      volumeStructure.set(v, {
        volumeNumber: v,
        chapterRange: [startChapter, endChapter],
        mainConflicts: volumeConflicts.map(c => c.id),
        thematicFocus: volumeConflicts.length > 0 
          ? `Ø§Ù„ØªØ±ÙƒÙŠØ² Ø¹Ù„Ù‰ ${volumeConflicts[0].subject.name}` 
          : 'Ù…ØªÙ†ÙˆØ¹'
      });
    }
    
    // Ø§Ù‚ØªØ±Ø§Ø­ Ù…ÙˆØ§Ø¶Ø¹ Ø§Ù„Ù€ Cliffhangers
    const cliffhangerPlacements: number[] = [];
    for (let v = 1; v < volumeCount; v++) {
      cliffhangerPlacements.push(v * 12); // Ù†Ù‡Ø§ÙŠØ© ÙƒÙ„ Ù…Ø¬Ù„Ø¯
    }
    
    return {
      recommendedChapterCount: estimatedChapters,
      volumeStructure,
      cliffhangerPlacement: cliffhangerPlacements,
      narrativePacing: 'Ø¥ÙŠÙ‚Ø§Ø¹ Ù…ØªØ¯Ø±Ø¬ Ù…Ø¹ Ø°Ø±Ù‰ ÙÙŠ Ù†Ù‡Ø§ÙŠØ© ÙƒÙ„ Ù…Ø¬Ù„Ø¯'
    };
  }
  
  async generateComparativeAnalysis(): Promise<string> {
    const episodic = await this.generateSeriesStructure();
    const cinematic = await this.generateCinematicAdaptation();
    const novel = await this.generateSerializedNovelStructure();
    
    return `
# Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ù‚Ø§Ø±Ù† Ù„Ù„Ù…Ù†ØµØ§Øª

## Ø§Ù„Ù…Ø³Ù„Ø³Ù„ Ø§Ù„Ø­Ù„Ù‚ÙŠ (Streaming Series)
- **Ø§Ù„Ù…ÙˆØ§Ø³Ù…:** ${episodic.series.totalSeasons}
- **Ø§Ù„Ø­Ù„Ù‚Ø§Øª Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠØ©:** ${episodic.series.totalEpisodes}
- **Ø§Ù„Ù…Ø¯Ø© Ø§Ù„Ù…Ù‚ØªØ±Ø­Ø©:** ${episodic.series.recommendedRuntime} Ø¯Ù‚ÙŠÙ‚Ø©/Ø­Ù„Ù‚Ø©
- **Ø§Ù„Ù…Ø²Ø§ÙŠØ§:** Ù‚Ø¯Ø±Ø© Ø¹Ù„Ù‰ ØªØ·ÙˆÙŠØ± Ø´Ø®ØµÙŠØ§Øª Ø¹Ù…ÙŠÙ‚ØŒ Ø§Ø³ØªÙƒØ´Ø§Ù ØµØ±Ø§Ø¹Ø§Øª Ù…ØªØ¹Ø¯Ø¯Ø©
- **Ø§Ù„ØªØ­Ø¯ÙŠØ§Øª:** Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„ØªÙˆØªØ± Ø¹Ø¨Ø± Ù…ÙˆØ§Ø³Ù… Ù…ØªØ¹Ø¯Ø¯Ø©

## Ø§Ù„ÙÙŠÙ„Ù… Ø§Ù„Ø³ÙŠÙ†Ù…Ø§Ø¦ÙŠ (Feature Film)
- **Ø§Ù„Ù…Ø¯Ø© Ø§Ù„ÙƒÙ„ÙŠØ©:** ${cinematic.recommendedRuntime} Ø¯Ù‚ÙŠÙ‚Ø©
- **Ø§Ù„Ø¨Ù†ÙŠØ©:** 3 ÙØµÙˆÙ„ ÙƒÙ„Ø§Ø³ÙŠÙƒÙŠØ©
- **Ø§Ù„Ù…Ø²Ø§ÙŠØ§:** ØªØ£Ø«ÙŠØ± Ø¹Ø§Ø·ÙÙŠ Ù…ÙƒØ«ÙØŒ ØªØ¬Ø±Ø¨Ø© Ø³ÙŠÙ†Ù…Ø§Ø¦ÙŠØ© Ù…ÙˆØ­Ø¯Ø©
- **Ø§Ù„ØªØ­Ø¯ÙŠØ§Øª:** Ø¶Ø±ÙˆØ±Ø© Ø§Ø®ØªØ²Ø§Ù„ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª ÙˆØ§Ù„Ø´Ø®ØµÙŠØ§Øª

## Ø§Ù„Ø±ÙˆØ§ÙŠØ© Ø§Ù„Ù…Ø³Ù„Ø³Ù„Ø© (Serialized Novel)
- **Ø§Ù„Ù…Ø¬Ù„Ø¯Ø§Øª:** ${novel.volumeStructure.size}
- **Ø§Ù„ÙØµÙˆÙ„ Ø§Ù„ÙƒÙ„ÙŠØ©:** ${novel.recommendedChapterCount}
- **Ø§Ù„Ù…Ø²Ø§ÙŠØ§:** Ø­Ø±ÙŠØ© Ø³Ø±Ø¯ÙŠØ© ÙƒØ§Ù…Ù„Ø©ØŒ Ø¹Ù…Ù‚ Ù†ÙØ³ÙŠ
- **Ø§Ù„ØªØ­Ø¯ÙŠØ§Øª:** Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ ØªÙØ§Ø¹Ù„ Ø§Ù„Ù‚Ø§Ø±Ø¦ Ø¹Ø¨Ø± Ù…Ø¬Ù„Ø¯Ø§Øª Ù…ØªØ¹Ø¯Ø¯Ø©

## Ø§Ù„ØªÙˆØµÙŠØ©
Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ ØªØ­Ù„ÙŠÙ„ Ø´Ø¨ÙƒØ© Ø§Ù„ØµØ±Ø§Ø¹ØŒ ÙØ¥Ù† **${this.recommendBestPlatform(episodic, cinematic, novel)}** Ù‡ÙŠ Ø§Ù„Ù…Ù†ØµØ© Ø§Ù„Ø£Ù†Ø³Ø¨ Ù„Ù‡Ø°Ø§ Ø§Ù„Ø¹Ù…Ù„.
`;
  }
  
  private recommendBestPlatform(episodic: any, cinematic: any, novel: any): string {
    const conflictCount = this.network.conflicts.size;
    const characterCount = this.network.characters.size;
    
    // Ù…Ù†Ø·Ù‚ Ø§ØªØ®Ø§Ø° Ø§Ù„Ù‚Ø±Ø§Ø±
    if (conflictCount > 5 && characterCount > 7) {
      return 'Ø§Ù„Ù…Ø³Ù„Ø³Ù„ Ø§Ù„Ø­Ù„Ù‚ÙŠ';
    } else if (conflictCount <= 3 && characterCount <= 5) {
      return 'Ø§Ù„ÙÙŠÙ„Ù… Ø§Ù„Ø³ÙŠÙ†Ù…Ø§Ø¦ÙŠ';
    } else {
      return 'Ø§Ù„Ø±ÙˆØ§ÙŠØ© Ø§Ù„Ù…Ø³Ù„Ø³Ù„Ø©';
    }
  }
}

/**
 * Ù…Ø­Ø±Ùƒ Ø§Ù„ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ
 */
class FinalReportGenerator {
  constructor(
    private network: ConflictNetwork,
    private allStationsData: Map<number, any>
  ) {}
  
  async generateComprehensiveReport(): Promise<FinalAnalysisReport> {
    logger.info("S7: Generating comprehensive final report...");
    
    const executiveSummary = this.buildExecutiveSummary();
    const strengthsAnalysis = this.analyzeStrengths();
    const weaknessesIdentified = this.identifyWeaknesses();
    const opportunitiesForImprovement = this.findOpportunities();
    const threatsToCohesion = this.assessThreats();
    const overallAssessment = this.calculateOverallAssessment();
    const detailedFindings = this.compileDetailedFindings();
    
    return {
      executiveSummary,
      strengthsAnalysis,
      weaknessesIdentified,
      opportunitiesForImprovement,
      threatsToCohesion,
      overallAssessment,
      detailedFindings
    };
  }
  
  private buildExecutiveSummary(): string {
    const charCount = this.network.characters.size;
    const relCount = this.network.relationships.size;
    const confCount = this.network.conflicts.size;
    
    return `
ØªÙ… Ø¥Ø¬Ø±Ø§Ø¡ ØªØ­Ù„ÙŠÙ„ Ø´Ø§Ù…Ù„ ÙˆÙ…ØªØ¹Ù…Ù‚ Ù„Ù„Ù†Øµ Ø§Ù„Ø³Ø±Ø¯ÙŠ Ø¹Ø¨Ø± 7 Ù…Ø­Ø·Ø§Øª ØªØ­Ù„ÙŠÙ„ÙŠØ© Ù…ØªØ®ØµØµØ©.

**Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„ÙƒÙ…ÙŠØ©:**
- Ø¹Ø¯Ø¯ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©: ${charCount}
- Ø¹Ø¯Ø¯ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©: ${relCount}
- Ø¹Ø¯Ø¯ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„Ù…Ø³ØªÙ†Ø¨Ø·Ø©: ${confCount}
- Ø¹Ø¯Ø¯ Ø§Ù„Ù„Ù‚Ø·Ø§Øª Ø§Ù„Ø²Ù…Ù†ÙŠØ©: ${this.network.snapshots.length}

**Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ:** ${this.getQualitativeRating()}

**Ø§Ù„Ù…Ù„Ø®Øµ Ø§Ù„ØªÙ†ÙÙŠØ°ÙŠ:**
${this.generateNarrativeSummary()}
`;
  }
  
  private getQualitativeRating(): string {
    const s4Data = this.allStationsData.get(4);
    if (s4Data?.results?.overall_efficiency_score) {
      const score = s4Data.results.overall_efficiency_score;
      if (score >= 0.8) return 'Ù…Ù…ØªØ§Ø² - Ø¨Ù†ÙŠØ© Ù‚ÙˆÙŠØ© ÙˆÙ…ØªÙ…Ø§Ø³ÙƒØ©';
      if (score >= 0.6) return 'Ø¬ÙŠØ¯ - Ø¨Ù†ÙŠØ© Ù‚ÙˆÙŠØ© Ù…Ø¹ Ø¨Ø¹Ø¶ Ù†Ù‚Ø§Ø· Ø§Ù„ØªØ­Ø³ÙŠÙ†';
      if (score >= 0.4) return 'Ù…Ù‚Ø¨ÙˆÙ„ - ÙŠØ­ØªØ§Ø¬ ØªØ­Ø³ÙŠÙ†Ø§Øª Ù‡ÙŠÙƒÙ„ÙŠØ©';
      return 'Ø¶Ø¹ÙŠÙ - ÙŠØªØ·Ù„Ø¨ Ø¥Ø¹Ø§Ø¯Ø© Ù‡ÙŠÙƒÙ„Ø© ÙƒØ¨Ø±Ù‰';
    }
    return 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯ - Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ÙƒØ§ÙÙŠØ©';
  }
  
  private generateNarrativeSummary(): string {
    const s1Data = this.allStationsData.get(1);
    const s2Data = this.allStationsData.get(2);
    
    const storyStatement = s2Data?.conceptual_outputs?.user_selections?.final_story_statement || 'Ø¨ÙŠØ§Ù† Ø§Ù„Ù‚ØµØ© ØºÙŠØ± Ù…ØªÙˆÙØ±';
    const mainChars = s1Data?.analysis_outputs?.major_characters_identified?.major_characters || [];
    
    return `
Ø§Ù„Ø¹Ù…Ù„ ÙŠØ¯ÙˆØ± Ø­ÙˆÙ„ ${mainChars.slice(0, 3).join(' Ùˆ')} ÙÙŠ ${storyStatement.substring(0, 100)}...
ØªÙ… Ø¨Ù†Ø§Ø¡ Ø´Ø¨ÙƒØ© ØµØ±Ø§Ø¹ Ù…Ø¹Ù‚Ø¯Ø© ØªØ±Ø¨Ø· Ø¨ÙŠÙ† Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø¹Ø¨Ø± ${this.network.relationships.size} Ø¹Ù„Ø§Ù‚Ø© Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©.
`;
  }
  
  private analyzeStrengths(): string[] {
    const strengths: string[] = [];
    
    const s4Data = this.allStationsData.get(4);
    if (s4Data?.results) {
      const results = s4Data.results;
      
      if (results.conflict_cohesion > 0.6) {
        strengths.push(`ØªÙ…Ø§Ø³Ùƒ Ø¹Ø§Ù„Ù Ø¨ÙŠÙ† Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª (${(results.conflict_cohesion * 100).toFixed(1)}%)`);
      }
      
      if (results.dramatic_balance?.balance_score > 0.7) {
        strengths.push('ØªÙˆØ§Ø²Ù† Ù…Ù…ØªØ§Ø² ÙÙŠ ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø£Ø¯ÙˆØ§Ø± Ø§Ù„Ø¯Ø±Ø§Ù…ÙŠØ© Ø¨ÙŠÙ† Ø§Ù„Ø´Ø®ØµÙŠØ§Øª');
      }
      
      if (results.narrative_efficiency?.narrative_efficiency_score > 0.7) {
        strengths.push('ÙƒÙØ§Ø¡Ø© Ø³Ø±Ø¯ÙŠØ© Ø¹Ø§Ù„ÙŠØ© Ù…Ø¹ Ø§Ø³ØªØºÙ„Ø§Ù„ Ø£Ù…Ø«Ù„ Ù„Ù„Ø´Ø®ØµÙŠØ§Øª');
      }
      
      if (results.redundancy?.redundancy_level === 'Low') {
        strengths.push('Ù…Ø³ØªÙˆÙ‰ Ù…Ù†Ø®ÙØ¶ Ù…Ù† Ø§Ù„ØªÙƒØ±Ø§Ø± - Ø³Ø±Ø¯ Ø§Ù‚ØªØµØ§Ø¯ÙŠ ÙˆÙØ¹Ù‘Ø§Ù„');
      }
    }
    
    const s5Data = this.allStationsData.get(5);
    if (s5Data?.symbolic_analysis_results?.depth_score > 7) {
      strengths.push('Ø¹Ù…Ù‚ Ø±Ù…Ø²ÙŠ Ù…Ù„Ø­ÙˆØ¸ ÙÙŠ Ø§Ù„Ø·Ø¨Ù‚Ø§Øª Ø§Ù„Ø¯Ù„Ø§Ù„ÙŠØ©');
    }
    
    if (s5Data?.stylistic_analysis_results?.overallToneAssessment?.tone_consistency > 8) {
      strengths.push('Ø§ØªØ³Ø§Ù‚ Ø£Ø³Ù„ÙˆØ¨ÙŠ Ù‚ÙˆÙŠ Ø¹Ø¨Ø± Ø§Ù„Ù†Øµ');
    }
    
    if (strengths.length === 0) {
      strengths.push('ØªØ­Ù„ÙŠÙ„ Ù…ØªÙˆØ§Ø²Ù† ÙŠØ­ØªØ§Ø¬ Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„ØªØ­Ø¯ÙŠØ¯ Ù†Ù‚Ø§Ø· Ø§Ù„Ù‚ÙˆØ©');
    }
    
    return strengths;
  }
  
  private identifyWeaknesses(): string[] {
    const weaknesses: string[] = [];
    
    const s4Data = this.allStationsData.get(4);
    if (s4Data?.results) {
      const results = s4Data.results;
      
      if (results.conflict_cohesion < 0.4) {
        weaknesses.push(`ØªÙ…Ø§Ø³Ùƒ Ø¶Ø¹ÙŠÙ Ø¨ÙŠÙ† Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª (${(results.conflict_cohesion * 100).toFixed(1)}%)`);
      }
      
      if (results.dramatic_balance?.character_involvement_gini > 0.6) {
        weaknesses.push('Ø¹Ø¯Ù… ØªÙˆØ§Ø²Ù† ÙƒØ¨ÙŠØ± ÙÙŠ Ø£Ù‡Ù…ÙŠØ© Ø§Ù„Ø´Ø®ØµÙŠØ§Øª - Ø¨Ø¹Ø¶ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ù…Ù‡Ù…Ø´Ø©');
      }
      
      if (results.redundancy?.redundancy_level === 'High' || results.redundancy?.redundancy_level === 'Critical') {
        weaknesses.push(`Ù…Ø³ØªÙˆÙ‰ ØªÙƒØ±Ø§Ø± ${results.redundancy.redundancy_level} - ÙˆØ¬ÙˆØ¯ Ø¹Ù†Ø§ØµØ± Ù…ÙƒØ±Ø±Ø©`);
      }
      
      if (results.narrative_density?.density_scores?.story_density < 0.3) {
        weaknesses.push('ÙƒØ«Ø§ÙØ© Ø³Ø±Ø¯ÙŠØ© Ù…Ù†Ø®ÙØ¶Ø© - Ø§Ù„Ù‚ØµØ© Ù‚Ø¯ ØªØ¨Ø¯Ùˆ Ù…ÙÙƒÙƒØ©');
      }
    }
    
    const s6Data = this.allStationsData.get(6);
    if (s6Data?.results?.diagnostics_report) {
      const diag = s6Data.results.diagnostics_report;
      
      if (diag.isolated_characters?.length > 0) {
        weaknesses.push(`ÙˆØ¬ÙˆØ¯ ${diag.isolated_characters.length} Ø´Ø®ØµÙŠØ© Ù…Ø¹Ø²ÙˆÙ„Ø© ØºÙŠØ± Ù…Ø¯Ù…Ø¬Ø© ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©`);
      }
      
      if (diag.abandoned_conflicts?.length > 0) {
        weaknesses.push(`${diag.abandoned_conflicts.length} ØµØ±Ø§Ø¹ Ù…Ù‡Ø¬ÙˆØ± Ø£Ùˆ ØºÙŠØ± Ù…ÙƒØªÙ…Ù„`);
      }
    }
    
    if (weaknesses.length === 0) {
      weaknesses.push('Ù„Ù… ÙŠØªÙ… Ø±ØµØ¯ Ù†Ù‚Ø§Ø· Ø¶Ø¹Ù ÙƒØ¨Ø±Ù‰ ÙÙŠ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø­Ø§Ù„ÙŠ');
    }
    
    return weaknesses;
  }
  
  private findOpportunities(): string[] {
    const opportunities: string[] = [];
    
    const s6Data = this.allStationsData.get(6);
    if (s6Data?.results?.treatment_recommendations) {
      const treatments = s6Data.results.treatment_recommendations;
      
      if (treatments.character_development_suggestions?.length > 0) {
        opportunities.push('ØªØ·ÙˆÙŠØ± Ø£Ø¹Ù…Ù‚ Ù„Ù‚ÙˆØ³ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ù‚ØªØ±Ø­Ø©');
      }
      
      if (treatments.conflict_enhancement_strategies?.length > 0) {
        opportunities.push('ØªØ¹Ø²ÙŠØ² Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø© Ù„Ø²ÙŠØ§Ø¯Ø© Ø§Ù„ØªÙˆØªØ± Ø§Ù„Ø¯Ø±Ø§Ù…ÙŠ');
      }
      
      if (treatments.structural_revisions?.length > 0) {
        opportunities.push('Ø¥Ø¹Ø§Ø¯Ø© Ù‡ÙŠÙƒÙ„Ø© Ø¨Ø¹Ø¶ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„ØªØ¯ÙÙ‚ Ø§Ù„Ø³Ø±Ø¯ÙŠ');
      }
    }
    
    const s5Data = this.allStationsData.get(5);
    if (s5Data?.episodic_integration_results?.balance_report) {
      const balance = s5Data.episodic_integration_results.balance_report;
      if (balance.overall_balance < 0.7) {
        opportunities.push('Ø¥Ø¹Ø§Ø¯Ø© ØªÙˆØ²ÙŠØ¹ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø¹Ø¨Ø± Ø§Ù„Ø­Ù„Ù‚Ø§Øª Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„ØªÙˆØ§Ø²Ù†');
      }
    }
    
    if (opportunities.length === 0) {
      opportunities.push('Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù…Ø¹ ØµÙ‚Ù„ ØªØ¯Ø±ÙŠØ¬ÙŠ');
    }
    
    return opportunities;
  }
  
  private assessThreats(): string[] {
    const threats: string[] = [];
    
    const s4Data = this.allStationsData.get(4);
    if (s4Data?.results?.issues) {
      const issues = s4Data.results.issues;
      
      issues.forEach((issue: any) => {
        if (issue.severity === 'critical' || issue.severity === 'major') {
          threats.push(`${issue.description} - Ø®Ø·Ø±: ${issue.severity}`);
        }
      });
    }
    
    const s6Data = this.allStationsData.get(6);
    if (s6Data?.results?.advanced_efficiency_metrics?.risk_assessment) {
      const risks = s6Data.results.advanced_efficiency_metrics.risk_assessment;
      
      if (risks.narrative_coherence_risk > 0.5) {
        threats.push('Ø®Ø·Ø± Ù…ØªÙˆØ³Ø· Ø¥Ù„Ù‰ Ø¹Ø§Ù„Ù Ù„ÙÙ‚Ø¯Ø§Ù† Ø§Ù„ØªÙ…Ø§Ø³Ùƒ Ø§Ù„Ø³Ø±Ø¯ÙŠ');
      }
      
      if (risks.character_consistency_risk > 0.5) {
        threats.push('Ø®Ø·Ø± Ø¹Ø¯Ù… Ø§ØªØ³Ø§Ù‚ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø¹Ø¨Ø± Ø§Ù„Ù‚ØµØ©');
      }
    }
    
    if (threats.length === 0) {
      threats.push('Ù„Ø§ ØªÙˆØ¬Ø¯ ØªÙ‡Ø¯ÙŠØ¯Ø§Øª ÙƒØ¨Ø±Ù‰ Ù„Ù„ØªÙ…Ø§Ø³Ùƒ Ø§Ù„Ø³Ø±Ø¯ÙŠ');
    }
    
    return threats;
  }
  
  private calculateOverallAssessment(): FinalAnalysisReport['overallAssessment'] {
    const s4Data = this.allStationsData.get(4);
    const s5Data = this.allStationsData.get(5);
    const s6Data = this.allStationsData.get(6);
    
    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¯Ø±Ø¬Ø§Øª
    const narrativeQuality = s5Data?.stylistic_analysis_results?.overall_tone_assessment?.tone_consistency / 10 || 0.5;
    const structuralIntegrity = s4Data?.results?.conflict_cohesion || 0.5;
    const characterDevelopment = s4Data?.results?.dramatic_balance?.balance_score || 0.5;
    const conflictEffectiveness = s4Data?.results?.narrative_efficiency?.conflict_efficiency || 0.5;
    
    const overallScore = (
      narrativeQuality * 0.25 +
      structuralIntegrity * 0.25 +
      characterDevelopment * 0.25 +
      conflictEffectiveness * 0.25
    );
    
    let rating: 'Excellent' | 'Good' | 'Fair' | 'Needs Improvement' | 'Critical';
    if (overallScore >= 0.8) rating = 'Excellent';
    else if (overallScore >= 0.6) rating = 'Good';
    else if (overallScore >= 0.4) rating = 'Fair';
    else if (overallScore >= 0.2) rating = 'Needs Improvement';
    else rating = 'Critical';
    
    return {
      narrativeQualityScore: narrativeQuality,
      structuralIntegrityScore: structuralIntegrity,
      characterDevelopmentScore: characterDevelopment,
      conflictEffectivenessScore: conflictEffectiveness,
      overallScore,
      rating
    };
  }
  
  private compileDetailedFindings(): Map<string, any> {
    const findings = new Map<string, any>();
    
    for (const [stationNum, stationData] of this.allStationsData) {
      findings.set(`station_${stationNum}`, {
        station_name: `Ø§Ù„Ù…Ø­Ø·Ø© ${stationNum}`,
        key_outputs: this.extractKeyOutputs(stationNum, stationData),
        performance: stationData.performance_stats || {}
      });
    }
    
    return findings;
  }
  
  private extractKeyOutputs(stationNum: number, data: any): any {
    switch (stationNum) {
      case 1:
        return {
          major_characters: data.analysis_outputs?.major_characters_identified?.major_characters?.length || 0,
          relationships_analyzed: data.analysis_outputs?.relationship_analysis?.key_relationships?.length || 0
        };
      case 2:
        return {
          story_statement: data.conceptual_outputs?.user_selections?.final_story_statement?.substring(0, 100) || 'N/A',
          hybrid_genre: data.conceptual_outputs?.user_selections?.final_hybrid_genre || 'N/A'
        };
      case 3:
        return {
          network_built: data.results?.network_summary || {}
        };
      case 4:
        return {
          efficiency_score: data.results?.overall_efficiency_score || 0,
          rating: data.results?.overall_rating || 'N/A'
        };
      case 5:
        return {
          dynamic_analysis: data.dynamic_analysis_results ? 'Completed' : 'N/A',
          symbolic_depth: data.symbolic_analysis_results?.depth_score || 0
        };
      case 6:
        return {
          diagnostics_run: data.results?.diagnostics_report ? 'Completed' : 'N/A',
          treatment_recommendations: data.results?.treatment_recommendations?.prioritized_actions?.length || 0
        };
      case 7:
        return {
          visualizations_generated: 'In Progress',
          final_report: 'In Progress'
        };
      default:
        return {};
    }
  }
}

/**
 * Ù†Ø¸Ø§Ù… Ø§Ù„ØªØµØ¯ÙŠØ± Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ
 */
class ExportPackageGenerator {
  constructor(
    private outputDir: string,
    private allStationsData: Map<number, any>,
    private finalReport: FinalAnalysisReport
  ) {}
  
  async generateExportPackage(): Promise<ExportPackage> {
    logger.info("S7: Generating comprehensive export package...");
    
    const formats = new Map<string, ExportFormat>();
    const deliverables: string[] = [];
    
    // ØªØµØ¯ÙŠØ± JSON
    const jsonPath = await this.exportAsJSON();
    formats.set('json', {
      formatType: 'json',
      filePath: jsonPath,
      contentSummary: 'Ø¨ÙŠØ§Ù†Ø§Øª ÙƒØ§Ù…Ù„Ø© Ø¨ØµÙŠØºØ© JSON Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„Ø¨Ø±Ù…Ø¬Ø©'
    });
    deliverables.push(jsonPath);
    
    // ØªØµØ¯ÙŠØ± Markdown
    const mdPath = await this.exportAsMarkdown();
    formats.set('markdown', {
      formatType: 'markdown',
      filePath: mdPath,
      contentSummary: 'ØªÙ‚Ø±ÙŠØ± Ø´Ø§Ù…Ù„ Ø¨ØµÙŠØºØ© Markdown Ù‚Ø§Ø¨Ù„ Ù„Ù„Ù‚Ø±Ø§Ø¡Ø©'
    });
    deliverables.push(mdPath);
    
    // ØªØµØ¯ÙŠØ± PDF (Ù…Ø­Ø§ÙƒØ§Ø© - ÙŠØªØ·Ù„Ø¨ Ù…ÙƒØªØ¨Ø© Ø®Ø§Ø±Ø¬ÙŠØ© ÙÙŠ Ø§Ù„Ø¥Ù†ØªØ§Ø¬)
    logger.info("S7: PDF export would require additional dependencies (e.g., puppeteer)");
    
    const packagePath = this.outputDir;
    
    return {
      formats,
      deliverables,
      packagePath
    };
  }
  
  private async exportAsJSON(): Promise<string> {
    const jsonPath = path.join(this.outputDir, 'complete_analysis.json');
    
    const exportData = {
      metadata: {
        export_timestamp: new Date().toISOString(),
        version: '1.0.0',
        generator: 'Station7_FinalReportGenerator'
      },
      stations_data: Object.fromEntries(this.allStationsData),
      final_report: {
        executive_summary: this.finalReport.executiveSummary,
        strengths: this.finalReport.strengthsAnalysis,
        weaknesses: this.finalReport.weaknessesIdentified,
        opportunities: this.finalReport.opportunitiesForImprovement,
        threats: this.finalReport.threatsToCohesion,
        overall_assessment: this.finalReport.overallAssessment,
        detailed_findings: Object.fromEntries(this.finalReport.detailedFindings)
      }
    };
    
    fs.writeFileSync(jsonPath, JSON.stringify(exportData, null, 2), 'utf-8');
    logger.info(`S7: JSON export saved to: ${jsonPath}`);
    
    return jsonPath;
  }
  
  private async exportAsMarkdown(): Promise<string> {
    const mdPath = path.join(this.outputDir, 'final_report.md');
    
    let markdown = `# Ø§Ù„ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ Ø§Ù„Ø´Ø§Ù…Ù„ Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù†Øµ Ø§Ù„Ø³Ø±Ø¯ÙŠ

**ØªØ§Ø±ÙŠØ® Ø§Ù„ØªØµØ¯ÙŠØ±:** ${new Date().toLocaleString('ar-EG')}

---

## ğŸ“‹ Ø§Ù„Ù…Ù„Ø®Øµ Ø§Ù„ØªÙ†ÙÙŠØ°ÙŠ

${this.finalReport.executiveSummary}

---

## âœ… Ù†Ù‚Ø§Ø· Ø§Ù„Ù‚ÙˆØ©

${this.finalReport.strengthsAnalysis.map((s, i) => `${i + 1}. ${s}`).join('\n')}

---

## âš ï¸ Ù†Ù‚Ø§Ø· Ø§Ù„Ø¶Ø¹Ù

${this.finalReport.weaknessesIdentified.map((w, i) => `${i + 1}. ${w}`).join('\n')}

---

## ğŸš€ ÙØ±Øµ Ø§Ù„ØªØ­Ø³ÙŠÙ†

${this.finalReport.opportunitiesForImprovement.map((o, i) => `${i + 1}. ${o}`).join('\n')}

---

"""
ÙˆØ­Ø¯Ø© Ø§Ù„ØªØ´Ø®ÙŠØµ Ø§Ù„Ø´Ø¨ÙƒÙŠ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©
==============================
ØªÙ‚ÙˆÙ… Ø¨ÙØ­Øµ Ø´Ø§Ù…Ù„ Ù„Ø´Ø¨ÙƒØ© Ø§Ù„ØµØ±Ø§Ø¹ ÙˆØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„Ù‡ÙŠÙƒÙ„ÙŠØ© ÙˆØ§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª Ø§Ù„Ø¶Ø¹ÙŠÙØ©
ÙˆØ§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ø¹Ø²ÙˆÙ„Ø© ÙˆØ§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„Ù…Ù‡Ù…Ù„Ø©.

Ø§Ù„Ù…Ø¤Ù„Ù: Ù†Ø¸Ø§Ù… ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù†ØµÙˆØµ Ø§Ù„Ø¯Ø±Ø§Ù…ÙŠØ©
Ø§Ù„Ø¥ØµØ¯Ø§Ø±: 2.0.0 (Production Ready)
"""

import logging
from typing import Dict, List, Any, Optional, Set, Tuple
from datetime import datetime, timedelta
from collections import defaultdict
import networkx as nx

from core.base_entities import (
    ConflictNetwork, 
    Conflict, 
    Character, 
    Relationship,
    ConflictPhase,
    RelationshipNature
)

logger = logging.getLogger(__name__)


class NetworkDiagnostics:
    """
    Ù…Ø­Ù„Ù„ ØªØ´Ø®ÙŠØµÙŠ Ù…ØªÙ‚Ø¯Ù… Ù„Ø´Ø¨ÙƒØ§Øª Ø§Ù„ØµØ±Ø§Ø¹ Ø§Ù„Ø¯Ø±Ø§Ù…ÙŠØ©
    
    ÙŠÙ‚ÙˆÙ… Ø¨ÙØ­Øµ Ø´Ø§Ù…Ù„ Ù„Ù„Ø´Ø¨ÙƒØ© ÙˆÙŠØ­Ø¯Ø¯:
    - Ø§Ù„Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„Ù‡ÙŠÙƒÙ„ÙŠØ© (Ù…ÙƒÙˆÙ†Ø§Øª Ù…Ù†ÙØµÙ„Ø©ØŒ Ø¹Ù†Ù‚ Ø§Ù„Ø²Ø¬Ø§Ø¬Ø©)
    - Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ø¹Ø²ÙˆÙ„Ø© Ø£Ùˆ Ø§Ù„Ù…Ø­Ù…Ù„Ø© Ø¨Ø´ÙƒÙ„ Ø²Ø§Ø¦Ø¯
    - Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„Ù…Ù‡Ù…Ù„Ø© Ø£Ùˆ Ø§Ù„Ø¶Ø¹ÙŠÙØ©
    - Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª Ø§Ù„Ø¶Ø¹ÙŠÙØ©
    - Ø§Ù„ØªÙƒØ±Ø§Ø±Ø§Øª ÙˆØ§Ù„Ø§Ø²Ø¯ÙˆØ§Ø¬ÙŠØ©
    """
    
    def __init__(self, network: ConflictNetwork):
        """
        ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø­Ù„Ù„ Ø§Ù„ØªØ´Ø®ÙŠØµÙŠ
        
        Args:
            network: Ø´Ø¨ÙƒØ© Ø§Ù„ØµØ±Ø§Ø¹ Ø§Ù„Ù…Ø±Ø§Ø¯ ØªØ­Ù„ÙŠÙ„Ù‡Ø§
        """
        self.network = network
        self.nx_graph = self._build_networkx_graph()
        
        # Ù†ØªØ§Ø¦Ø¬ Ø§Ù„ØªØ´Ø®ÙŠØµ
        self.structural_issues: List[Dict[str, Any]] = []
        self.isolated_characters: List[Dict[str, Any]] = []
        self.abandoned_conflicts: List[Dict[str, Any]] = []
        self.overloaded_characters: List[Dict[str, Any]] = []
        self.weak_connections: List[Dict[str, Any]] = []
        self.redundancy_issues: List[Dict[str, Any]] = []
        
        logger.info(f"NetworkDiagnostics initialized for network: {network.name}")
    
    def _build_networkx_graph(self) -> nx.Graph:
        """
        Ø¨Ù†Ø§Ø¡ Ø±Ø³Ù… Ø¨ÙŠØ§Ù†ÙŠ NetworkX Ù…Ù† Ø´Ø¨ÙƒØ© Ø§Ù„ØµØ±Ø§Ø¹ Ù„ØªØ­Ù„ÙŠÙ„ Ù‡ÙŠÙƒÙ„ÙŠ Ù…ØªÙ‚Ø¯Ù…
        
        Returns:
            Ø±Ø³Ù… Ø¨ÙŠØ§Ù†ÙŠ NetworkX
        """
        G = nx.Graph()
        
        # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¹Ù‚Ø¯ (Ø§Ù„Ø´Ø®ØµÙŠØ§Øª)
        for char_id, character in self.network.characters.items():
            G.add_node(char_id, 
                      name=character.name,
                      type='character',
                      data=character)
        
        # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø­ÙˆØ§Ù (Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª)
        for rel_id, relationship in self.network.relationships.items():
            if relationship.source in G.nodes and relationship.target in G.nodes:
                G.add_edge(relationship.source, 
                          relationship.target,
                          weight=relationship.strength,
                          rel_id=rel_id,
                          data=relationship)
        
        logger.info(f"Built NetworkX graph: {G.number_of_nodes()} nodes, {G.number_of_edges()} edges")
        return G
    
    def run_all_diagnostics(self) -> Dict[str, Any]:
        """
        ØªØ´ØºÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ´Ø®ÙŠØµØ§Øª Ø§Ù„Ù…Ù…ÙƒÙ†Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø¨ÙƒØ©
        
        Returns:
            ØªÙ‚Ø±ÙŠØ± ØªØ´Ø®ÙŠØµÙŠ Ø´Ø§Ù…Ù„
        """
        logger.info("="*60)
        logger.info("Starting comprehensive network diagnostics...")
        logger.info("="*60)
        
        # ØªØ´Ø®ÙŠØµ Ø§Ù„Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„Ù‡ÙŠÙƒÙ„ÙŠØ©
        self.structural_issues = self._diagnose_structural_issues()
        logger.info(f"âœ“ Structural issues identified: {len(self.structural_issues)}")
        
        # ØªØ´Ø®ÙŠØµ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ø¹Ø²ÙˆÙ„Ø©
        self.isolated_characters = self._identify_isolated_characters()
        logger.info(f"âœ“ Isolated characters found: {len(self.isolated_characters)}")
        
        # ØªØ´Ø®ÙŠØµ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„Ù…Ù‡Ù…Ù„Ø©
        self.abandoned_conflicts = self._identify_abandoned_conflicts()
        logger.info(f"âœ“ Abandoned conflicts detected: {len(self.abandoned_conflicts)}")
        
        # ØªØ´Ø®ÙŠØµ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ø­Ù…Ù„Ø©
        self.overloaded_characters = self._identify_overloaded_characters()
        logger.info(f"âœ“ Overloaded characters found: {len(self.overloaded_characters)}")
        
        # ØªØ´Ø®ÙŠØµ Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª Ø§Ù„Ø¶Ø¹ÙŠÙØ©
        self.weak_connections = self._identify_weak_connections()
        logger.info(f"âœ“ Weak connections identified: {len(self.weak_connections)}")
        
        # ØªØ´Ø®ÙŠØµ Ø§Ù„ØªÙƒØ±Ø§Ø±Ø§Øª
        self.redundancy_issues = self._identify_redundancies()
        logger.info(f"âœ“ Redundancy issues found: {len(self.redundancy_issues)}")
        
        # Ø­Ø³Ø§Ø¨ Ø¯Ø±Ø¬Ø© Ø§Ù„ØµØ­Ø© Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠØ©
        overall_health_score = self._calculate_health_score()
        criticality_level = self._determine_criticality_level(overall_health_score)
        
        logger.info("="*60)
        logger.info(f"Network Health Score: {overall_health_score:.2f}/100")
        logger.info(f"Criticality Level: {criticality_level}")
        logger.info("="*60)
        
        return {
            'structural_issues': self.structural_issues,
            'isolated_characters': {
                'total_isolated': len(self.isolated_characters),
                'characters': self.isolated_characters
            },
            'abandoned_conflicts': {
                'total_abandoned': len(self.abandoned_conflicts),
                'conflicts': self.abandoned_conflicts
            },
            'overloaded_characters': {
                'total_overloaded': len(self.overloaded_characters),
                'characters': self.overloaded_characters
            },
            'weak_connections': {
                'total_weak': len(self.weak_connections),
                'connections': self.weak_connections
            },
            'redundancy_issues': {
                'total_redundant': len(self.redundancy_issues),
                'issues': self.redundancy_issues
            },
            'overall_health_score': overall_health_score,
            'criticality_level': criticality_level,
            'summary': self._generate_diagnostic_summary(
                overall_health_score, 
                criticality_level
            )
        }
    
    def _diagnose_structural_issues(self) -> List[Dict[str, Any]]:
        """
        ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„Ù‡ÙŠÙƒÙ„ÙŠØ© ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©
        
        Returns:
            Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø§Ù„Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„Ù‡ÙŠÙƒÙ„ÙŠØ© Ø§Ù„Ù…ÙƒØªØ´ÙØ©
        """
        issues = []
        
        # 1. ÙØ­Øµ Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª Ø§Ù„Ù…Ù†ÙØµÙ„Ø©
        if not nx.is_connected(self.nx_graph):
            components = list(nx.connected_components(self.nx_graph))
            if len(components) > 1:
                issues.append({
                    'type': 'disconnected_components',
                    'severity': 'high' if len(components) > 2 else 'medium',
                    'description': f'Ø§Ù„Ø´Ø¨ÙƒØ© ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ {len(components)} Ù…ÙƒÙˆÙ†Ø§Øª Ù…Ù†ÙØµÙ„Ø©',
                    'affected_entities': {
                        'components': [list(comp) for comp in components],
                        'component_sizes': [len(comp) for comp in components]
                    },
                    'potential_impact': 'ÙÙ‚Ø¯Ø§Ù† Ø§Ù„ØªÙ…Ø§Ø³Ùƒ Ø§Ù„Ø³Ø±Ø¯ÙŠ ÙˆØªÙÙƒÙƒ Ø§Ù„Ù‚ØµØ©',
                    'recommendation': 'Ø¥Ø¶Ø§ÙØ© Ø´Ø®ØµÙŠØ§Øª Ø¬Ø³Ø± Ø£Ùˆ Ø£Ø­Ø¯Ø§Ø« ØªØ±Ø¨Ø· Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª Ø§Ù„Ù…Ù†ÙØµÙ„Ø©'
                })
        
        # 2. ÙØ­Øµ Ø¹Ù†Ù‚ Ø§Ù„Ø²Ø¬Ø§Ø¬Ø© (Bottleneck)
        if nx.number_of_nodes(self.nx_graph) > 3:
            try:
                articulation_points = list(nx.articulation_points(self.nx_graph))
                if articulation_points:
                    for ap in articulation_points:
                        char_name = self.nx_graph.nodes[ap].get('name', ap)
                        issues.append({
                            'type': 'bottleneck_character',
                            'severity': 'medium',
                            'description': f'Ø§Ù„Ø´Ø®ØµÙŠØ© "{char_name}" ØªÙ…Ø«Ù„ Ù†Ù‚Ø·Ø© Ø§Ø®ØªÙ†Ø§Ù‚ ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©',
                            'affected_entities': {
                                'character_id': ap,
                                'character_name': char_name
                            },
                            'potential_impact': 'Ø¥Ø²Ø§Ù„Ø© Ù‡Ø°Ù‡ Ø§Ù„Ø´Ø®ØµÙŠØ© Ø³ØªÙØµÙ„ Ø§Ù„Ø´Ø¨ÙƒØ©',
                            'recommendation': 'Ø¥Ø¶Ø§ÙØ© Ø§ØªØµØ§Ù„Ø§Øª Ø¨Ø¯ÙŠÙ„Ø© Ù„ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯ Ø¹Ù„Ù‰ Ù‡Ø°Ù‡ Ø§Ù„Ø´Ø®ØµÙŠØ©'
                        })
            except Exception as e:
                logger.warning(f"Could not calculate articulation points: {e}")
        
        # 3. ÙØ­Øµ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø¨Ø¯ÙˆÙ† Ù…Ø®Ø±Ø¬ (Dead-end)
        for conflict_id, conflict in self.network.conflicts.items():
            if conflict.phase == ConflictPhase.STALEMATE:
                # ÙØ­Øµ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ØµØ±Ø§Ø¹ ÙÙŠ Ø­Ø§Ù„Ø© Ø¬Ù…ÙˆØ¯ Ù…Ù†Ø° ÙØªØ±Ø© Ø·ÙˆÙŠÙ„Ø©
                if conflict.timestamps and len(conflict.timestamps) > 0:
                    last_update = conflict.timestamps[-1] if isinstance(conflict.timestamps[-1], datetime) else datetime.now()
                    days_stale = (datetime.now() - last_update).days
                    
                    if days_stale > 30:  # Ø£ÙƒØ«Ø± Ù…Ù† Ø´Ù‡Ø± Ø¨Ø¯ÙˆÙ† ØªØ·ÙˆØ±
                        issues.append({
                            'type': 'dead_end_conflict',
                            'severity': 'low',
                            'description': f'Ø§Ù„ØµØ±Ø§Ø¹ "{conflict.name}" ÙÙŠ Ø­Ø§Ù„Ø© Ø¬Ù…ÙˆØ¯ Ù…Ù†Ø° {days_stale} ÙŠÙˆÙ…',
                            'affected_entities': {
                                'conflict_id': conflict_id,
                                'conflict_name': conflict.name,
                                'days_stale': days_stale
                            },
                            'potential_impact': 'Ù‚Ø¯ ÙŠÙÙ‚Ø¯ Ø§Ù„Ù‚Ø§Ø±Ø¦/Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯ Ø§Ù„Ø§Ù‡ØªÙ…Ø§Ù… Ø¨Ù‡Ø°Ø§ Ø§Ù„Ø®Ø· Ø§Ù„Ø³Ø±Ø¯ÙŠ',
                            'recommendation': 'Ø¥Ø¶Ø§ÙØ© Ù†Ù‚Ø·Ø© ØªØ­ÙˆÙ„ Ø£Ùˆ ØªØµØ¹ÙŠØ¯ Ù„Ù„ØµØ±Ø§Ø¹'
                        })
        
        return issues
    
    def _identify_isolated_characters(self) -> List[Dict[str, Any]]:
        """
        ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ø¹Ø²ÙˆÙ„Ø© Ø£Ùˆ Ø¶Ø¹ÙŠÙØ© Ø§Ù„Ø§ØªØµØ§Ù„
        
        Returns:
            Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ø¹Ø²ÙˆÙ„Ø©
        """
        isolated = []
        
        for char_id, character in self.network.characters.items():
            # Ø­Ø³Ø§Ø¨ Ø¹Ø¯Ø¯ Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª
            if char_id in self.nx_graph:
                degree = self.nx_graph.degree(char_id)
                
                # Ø´Ø®ØµÙŠØ© Ù…Ø¹Ø²ÙˆÙ„Ø© ØªÙ…Ø§Ù…Ø§Ù‹
                if degree == 0:
                    isolated.append({
                        'character_id': char_id,
                        'character_name': character.name,
                        'isolation_type': 'completely_isolated',
                        'connection_count': 0,
                        'suggested_connections': self._suggest_connections(char_id),
                        'severity': 'high',
                        'recommendation': 'Ø¯Ù…Ø¬ Ø§Ù„Ø´Ø®ØµÙŠØ© ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ© Ø£Ùˆ Ø¥Ø²Ø§Ù„ØªÙ‡Ø§ Ù…Ù† Ø§Ù„Ù‚ØµØ©'
                    })
                
                # Ø´Ø®ØµÙŠØ© Ø¶Ø¹ÙŠÙØ© Ø§Ù„Ø§ØªØµØ§Ù„
                elif degree == 1:
                    isolated.append({
                        'character_id': char_id,
                        'character_name': character.name,
                        'isolation_type': 'weakly_connected',
                        'connection_count': 1,
                        'suggested_connections': self._suggest_connections(char_id),
                        'severity': 'medium',
                        'recommendation': 'Ø¥Ø¶Ø§ÙØ© Ø¹Ù„Ø§Ù‚Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ© Ù„ØªØ¹Ø²ÙŠØ² Ø¯ÙˆØ± Ø§Ù„Ø´Ø®ØµÙŠØ©'
                    })
            else:
                # Ø§Ù„Ø´Ø®ØµÙŠØ© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ (Ø®Ø·Ø£ Ø¨ÙŠØ§Ù†Ø§Øª)
                isolated.append({
                    'character_id': char_id,
                    'character_name': character.name,
                    'isolation_type': 'not_in_graph',
                    'connection_count': 0,
                    'suggested_connections': [],
                    'severity': 'critical',
                    'recommendation': 'Ù…Ø±Ø§Ø¬Ø¹Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø´Ø®ØµÙŠØ© - Ù‚Ø¯ ØªÙƒÙˆÙ† Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨Ù†Ø§Ø¡'
                })
        
        return isolated
    
    def _identify_abandoned_conflicts(self) -> List[Dict[str, Any]]:
        """
        ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„Ù…Ù‡Ù…Ù„Ø© Ø£Ùˆ Ø§Ù„ØªÙŠ Ù„Ù… ØªØªØ·ÙˆØ±
        
        Returns:
            Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„Ù…Ù‡Ù…Ù„Ø©
        """
        abandoned = []
        now = datetime.now()
        
        for conflict_id, conflict in self.network.conflicts.items():
            issue_detected = False
            issue_type = None
            days_inactive = 0
            
            # 1. ØµØ±Ø§Ø¹ Ø¨Ø¯ÙˆÙ† ØªØ·ÙˆØ± Ø²Ù…Ù†ÙŠ
            if not conflict.timestamps or len(conflict.timestamps) <= 1:
                issue_detected = True
                issue_type = 'no_progression'
                days_inactive = -1  # ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ
            
            # 2. ØµØ±Ø§Ø¹ Ø¹Ø§Ù„Ù‚ ÙÙŠ Ù…Ø±Ø­Ù„Ø© Ù…Ø¹ÙŠÙ†Ø©
            elif len(conflict.timestamps) > 1:
                last_update = conflict.timestamps[-1] if isinstance(conflict.timestamps[-1], datetime) else datetime.now()
                days_inactive = (now - last_update).days
                
                if days_inactive > 45 and conflict.phase in [ConflictPhase.LATENT, ConflictPhase.STALEMATE]:
                    issue_detected = True
                    issue_type = 'stuck_in_phase'
            
            # 3. ØµØ±Ø§Ø¹ Ø¨Ù…Ø´Ø§Ø±ÙƒØ© ØºÙŠØ± ÙƒØ§ÙÙŠØ©
            if len(conflict.involved_characters) < 2:
                issue_detected = True
                issue_type = 'insufficient_involvement'
            
            if issue_detected:
                abandoned.append({
                    'conflict_id': conflict_id,
                    'conflict_name': conflict.name,
                    'issue_type': issue_type,
                    'current_phase': conflict.phase.name if hasattr(conflict.phase, 'name') else str(conflict.phase),
                    'days_inactive': days_inactive,
                    'involved_characters_count': len(conflict.involved_characters),
                    'severity': 'high' if issue_type == 'no_progression' else 'medium',
                    'suggested_actions': self._suggest_conflict_revival(conflict, issue_type),
                    'recommendation': f'Ø¥Ø¹Ø§Ø¯Ø© ØªÙ†Ø´ÙŠØ· Ø§Ù„ØµØ±Ø§Ø¹ Ø¨Ù€{self._get_revival_strategy(issue_type)}'
                })
        
        return abandoned
    
    def _identify_overloaded_characters(self) -> List[Dict[str, Any]]:
        """
        ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ø­Ù…Ù„Ø© Ø¨Ø¹Ø¯Ø¯ ÙƒØ¨ÙŠØ± Ù…Ù† Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª ÙˆØ§Ù„ØµØ±Ø§Ø¹Ø§Øª
        
        Returns:
            Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ø­Ù…Ù„Ø©
        """
        overloaded = []
        
        # Ø­Ø³Ø§Ø¨ Ù…ØªÙˆØ³Ø· Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ©
        total_chars = len(self.network.characters)
        if total_chars == 0:
            return overloaded
        
        total_relationships = len(self.network.relationships)
        total_conflicts = len(self.network.conflicts)
        
        avg_relationships_per_char = total_relationships / total_chars if total_chars > 0 else 0
        avg_conflicts_per_char = total_conflicts / total_chars if total_chars > 0 else 0
        
        # Ø­Ø¯ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø²Ø§Ø¦Ø¯: 2x Ø§Ù„Ù…ØªÙˆØ³Ø·
        overload_threshold_rel = avg_relationships_per_char * 2
        overload_threshold_conf = avg_conflicts_per_char * 2
        
        for char_id, character in self.network.characters.items():
            # Ø¹Ø¯ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
            rel_count = sum(1 for rel in self.network.relationships.values() 
                           if rel.source == char_id or rel.target == char_id)
            
            # Ø¹Ø¯ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
            conf_count = sum(1 for conf in self.network.conflicts.values() 
                            if char_id in conf.involved_characters)
            
            # Ø­Ø³Ø§Ø¨ Ø¯Ø±Ø¬Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„
            overload_score = (rel_count / max(avg_relationships_per_char, 1)) + \
                           (conf_count / max(avg_conflicts_per_char, 1))
            
            if rel_count > overload_threshold_rel or conf_count > overload_threshold_conf:
                overloaded.append({
                    'character_id': char_id,
                    'character_name': character.name,
                    'relationship_count': rel_count,
                    'conflict_count': conf_count,
                    'overload_score': overload_score,
                    'severity': 'high' if overload_score > 4 else 'medium',
                    'suggested_redistribution': self._suggest_load_redistribution(
                        char_id, rel_count, conf_count
                    ),
                    'recommendation': f'Ø¥Ø¹Ø§Ø¯Ø© ØªÙˆØ²ÙŠØ¹ {int(rel_count * 0.3)} Ø¹Ù„Ø§Ù‚Ø© Ùˆ {int(conf_count * 0.2)} ØµØ±Ø§Ø¹'
                })
        
        return overloaded
    
    def _identify_weak_connections(self) -> List[Dict[str, Any]]:
        """
        ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª Ø§Ù„Ø¶Ø¹ÙŠÙØ© (Ø¹Ù„Ø§Ù‚Ø§Øª Ø¶Ø¹ÙŠÙØ© Ø£Ùˆ Ø±ÙˆØ§Ø¨Ø· ØµØ±Ø§Ø¹ Ù‡Ø´Ø©)
        
        Returns:
            Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª Ø§Ù„Ø¶Ø¹ÙŠÙØ©
        """
        weak = []
        
        # ÙØ­Øµ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª Ø§Ù„Ø¶Ø¹ÙŠÙØ©
        for rel_id, relationship in self.network.relationships.items():
            if relationship.strength <= 3:  # Ù‚ÙˆØ© Ø¶Ø¹ÙŠÙØ© (1-3 Ù…Ù† 10)
                char1 = self.network.characters.get(relationship.source)
                char2 = self.network.characters.get(relationship.target)
                
                if char1 and char2:
                    weak.append({
                        'connection_id': rel_id,
                        'connection_type': 'relationship',
                        'entities': [char1.name, char2.name],
                        'entity_ids': [relationship.source, relationship.target],
                        'strength_score': relationship.strength,
                        'severity': 'low',
                        'reason_for_weakness': 'Ø¹Ù„Ø§Ù‚Ø© Ø¶Ø¹ÙŠÙØ© Ù‚Ø¯ Ù„Ø§ ØªØ¯Ø¹Ù… Ø§Ù„ØµØ±Ø§Ø¹ Ø¨Ø´ÙƒÙ„ ÙØ¹Ø§Ù„',
                        'suggested_strengthening': f'ØªØ¹Ø²ÙŠØ² Ø§Ù„Ø¹Ù„Ø§Ù‚Ø© Ø¨ÙŠÙ† {char1.name} Ùˆ {char2.name} Ù…Ù† Ø®Ù„Ø§Ù„ Ù…Ø´Ø§Ù‡Ø¯ ØªÙØ§Ø¹Ù„ÙŠØ© Ø¥Ø¶Ø§ÙÙŠØ©'
                    })
        
        # ÙØ­Øµ Ø±ÙˆØ§Ø¨Ø· Ø§Ù„ØµØ±Ø§Ø¹ Ø§Ù„Ø¶Ø¹ÙŠÙØ©
        for conflict_id, conflict in self.network.conflicts.items():
            if conflict.strength <= 4 and conflict.phase not in [ConflictPhase.RESOLUTION, ConflictPhase.AFTERMATH]:
                weak.append({
                    'connection_id': conflict_id,
                    'connection_type': 'conflict',
                    'entities': conflict.involved_characters[:3],  # Ø£ÙˆÙ„ 3 Ø´Ø®ØµÙŠØ§Øª
                    'entity_ids': conflict.involved_characters[:3],
                    'strength_score': conflict.strength,
                    'severity': 'medium' if conflict.strength <= 2 else 'low',
                    'reason_for_weakness': f'ØµØ±Ø§Ø¹ "{conflict.name}" Ø¨Ù‚ÙˆØ© Ù…Ù†Ø®ÙØ¶Ø© ({conflict.strength}/10)',
                    'suggested_strengthening': f'ØªØµØ¹ÙŠØ¯ Ø§Ù„ØµØ±Ø§Ø¹ ÙˆØ²ÙŠØ§Ø¯Ø© Ø§Ù„Ù…Ø®Ø§Ø·Ø± Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø© Ø¨Ù‡'
                })
        
        return weak
    
    def _identify_redundancies(self) -> List[Dict[str, Any]]:
        """
        ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ØªÙƒØ±Ø§Ø±Ø§Øª ÙˆØ§Ù„Ø§Ø²Ø¯ÙˆØ§Ø¬ÙŠØ© ÙÙŠ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª ÙˆØ§Ù„ØµØ±Ø§Ø¹Ø§Øª
        
        Returns:
            Ù‚Ø§Ø¦Ù…Ø© Ø¨Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„ØªÙƒØ±Ø§Ø±
        """
        redundancies = []
        
        # ÙØ­Øµ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª Ø§Ù„Ù…ÙƒØ±Ø±Ø©
        relationship_pairs = defaultdict(list)
        for rel_id, rel in self.network.relationships.items():
            pair = tuple(sorted([rel.source, rel.target]))
            relationship_pairs[pair].append((rel_id, rel))
        
        for pair, rels in relationship_pairs.items():
            if len(rels) > 1:
                char1 = self.network.characters.get(pair[0])
                char2 = self.network.characters.get(pair[1])
                
                if char1 and char2:
                    redundancies.append({
                        'type': 'duplicate_relationships',
                        'entities': [char1.name, char2.name],
                        'entity_ids': list(pair),
                        'duplicate_count': len(rels),
                        'similarity_score': 0.85,  # Ø§ÙØªØ±Ø§Ø¶ÙŠ
                        'severity': 'low',
                        'suggested_merge': f'Ø¯Ù…Ø¬ {len(rels)} Ø¹Ù„Ø§Ù‚Ø§Øª Ø¨ÙŠÙ† {char1.name} Ùˆ {char2.name} ÙÙŠ Ø¹Ù„Ø§Ù‚Ø© ÙˆØ§Ø­Ø¯Ø© Ù…Ø¹Ù‚Ø¯Ø©',
                        'recommendation': 'Ø§Ù„Ø§Ø­ØªÙØ§Ø¸ Ø¨Ø§Ù„Ø¹Ù„Ø§Ù‚Ø© Ø§Ù„Ø£Ù‚ÙˆÙ‰ ÙˆØ¯Ù…Ø¬ Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø£Ø®Ø±ÙŠØ§Øª'
                    })
        
        # ÙØ­Øµ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„Ù…ØªØ´Ø§Ø¨Ù‡Ø©
        conflicts_list = list(self.network.conflicts.items())
        for i in range(len(conflicts_list)):
            for j in range(i + 1, len(conflicts_list)):
                conf1_id, conf1 = conflicts_list[i]
                conf2_id, conf2 = conflicts_list[j]
                
                # Ø­Ø³Ø§Ø¨ Ø§Ù„ØªØ´Ø§Ø¨Ù‡ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ø´ØªØ±ÙƒØ© ÙˆØ§Ù„Ù…ÙˆØ¶ÙˆØ¹
                shared_chars = set(conf1.involved_characters) & set(conf2.involved_characters)
                similarity = len(shared_chars) / max(len(conf1.involved_characters), len(conf2.involved_characters), 1)
                
                if similarity > 0.6 and conf1.subject == conf2.subject:
                    redundancies.append({
                        'type': 'overlapping_conflicts',
                        'entities': [conf1.name, conf2.name],
                        'entity_ids': [conf1_id, conf2_id],
                        'similarity_score': similarity,
                        'shared_characters': len(shared_chars),
                        'severity': 'medium',
                        'suggested_merge': f'Ø¯Ù…Ø¬ Ø§Ù„ØµØ±Ø§Ø¹ÙŠÙ† "{conf1.name}" Ùˆ "{conf2.name}" ÙÙŠ ØµØ±Ø§Ø¹ ÙˆØ§Ø­Ø¯ Ø£ÙƒØ«Ø± ØªØ¹Ù‚ÙŠØ¯Ø§Ù‹',
                        'recommendation': 'ØªØ¨Ø³ÙŠØ· Ø§Ù„Ø¨Ù†ÙŠØ© Ø¨Ø¯Ù…Ø¬ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„Ù…ØªØ¯Ø§Ø®Ù„Ø©'
                    })
        
        return redundancies
    
    def _calculate_health_score(self) -> float:
        """
        Ø­Ø³Ø§Ø¨ Ø¯Ø±Ø¬Ø© ØµØ­Ø© Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠØ© (0-100)
        
        Returns:
            Ø¯Ø±Ø¬Ø© Ø§Ù„ØµØ­Ø© Ù…Ù† 0 Ø¥Ù„Ù‰ 100
        """
        score = 100.0
        
        # Ø®ØµÙ… Ù†Ù‚Ø§Ø· Ù„Ù„Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„Ù‡ÙŠÙƒÙ„ÙŠØ©
        for issue in self.structural_issues:
            if issue['severity'] == 'critical':
                score -= 15
            elif issue['severity'] == 'high':
                score -= 10
            elif issue['severity'] == 'medium':
                score -= 5
            else:
                score -= 2
        
        # Ø®ØµÙ… Ù†Ù‚Ø§Ø· Ù„Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ø¹Ø²ÙˆÙ„Ø©
        score -= len(self.isolated_characters) * 3
        
        # Ø®ØµÙ… Ù†Ù‚Ø§Ø· Ù„Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„Ù…Ù‡Ù…Ù„Ø©
        score -= len(self.abandoned_conflicts) * 5
        
        # Ø®ØµÙ… Ù†Ù‚Ø§Ø· Ù„Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ø­Ù…Ù„Ø©
        score -= len(self.overloaded_characters) * 4
        
        # Ø®ØµÙ… Ù†Ù‚Ø§Ø· Ù„Ù„Ø§ØªØµØ§Ù„Ø§Øª Ø§Ù„Ø¶Ø¹ÙŠÙØ©
        score -= len(self.weak_connections) * 1
        
        # Ø®ØµÙ… Ù†Ù‚Ø§Ø· Ù„Ù„ØªÙƒØ±Ø§Ø±Ø§Øª
        score -= len(self.redundancy_issues) * 2
        
        return max(0.0, min(100.0, score))
    
    def _determine_criticality_level(self, health_score: float) -> str:
        """
        ØªØ­Ø¯ÙŠØ¯ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø®Ø·ÙˆØ±Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø¯Ø±Ø¬Ø© Ø§Ù„ØµØ­Ø©
        
        Args:
            health_score: Ø¯Ø±Ø¬Ø© Ø§Ù„ØµØ­Ø© (0-100)
            
        Returns:
            Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø®Ø·ÙˆØ±Ø©
        """
        if health_score >= 80:
            return 'healthy'
        elif health_score >= 60:
            return 'minor_issues'
        elif health_score >= 40:
            return 'moderate_issues'
        elif health_score >= 20:
            return 'major_issues'
        else:
            return 'critical'
    
    def _suggest_connections(self, char_id: str) -> List[str]:
        """
        Ø§Ù‚ØªØ±Ø§Ø­ Ø§ØªØµØ§Ù„Ø§Øª Ù…Ù…ÙƒÙ†Ø© Ù„Ø´Ø®ØµÙŠØ© Ù…Ø¹Ø²ÙˆÙ„Ø©
        
        Args:
            char_id: Ù…Ø¹Ø±Ù‘Ù Ø§Ù„Ø´Ø®ØµÙŠØ©
            
        Returns:
            Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª Ø§Ù„Ø§ØªØµØ§Ù„
        """
        suggestions = []
        
        # Ø§Ù‚ØªØ±Ø§Ø­ Ø§Ù„Ø§ØªØµØ§Ù„ Ù…Ø¹ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ø±ÙƒØ²ÙŠØ©
        if self.nx_graph.number_of_nodes() > 0:
            try:
                centrality = nx.degree_centrality(self.nx_graph)
                top_central = sorted(centrality.items(), key=lambda x: x[1], reverse=True)[:3]
                
                for central_char_id, _ in top_central:
                    if central_char_id != char_id:
                        char_name = self.nx_graph.nodes[central_char_id].get('name', central_char_id)
                        suggestions.append(f'Ø±Ø¨Ø· Ù…Ø¹ Ø§Ù„Ø´Ø®ØµÙŠØ© Ø§Ù„Ù…Ø±ÙƒØ²ÙŠØ©: {char_name}')
            except:
                pass
        
        if not suggestions:
            suggestions.append('Ø¥Ø¶Ø§ÙØ© Ø¹Ù„Ø§Ù‚Ø© Ù…Ø¹ Ø£ÙŠ Ø´Ø®ØµÙŠØ© Ø±Ø¦ÙŠØ³ÙŠØ© ÙÙŠ Ø§Ù„Ù‚ØµØ©')
        
        return suggestions
    
    def _suggest_conflict_revival(self, conflict: Conflict, issue_type: str) -> List[str]:
        """
        Ø§Ù‚ØªØ±Ø§Ø­ Ø·Ø±Ù‚ Ù„Ø¥Ø­ÙŠØ§Ø¡ ØµØ±Ø§Ø¹ Ù…Ù‡Ù…Ù„
        
        Args:
            conflict: Ø§Ù„ØµØ±Ø§Ø¹ Ø§Ù„Ù…Ù‡Ù…Ù„
            issue_type: Ù†ÙˆØ¹ Ø§Ù„Ù…Ø´ÙƒÙ„Ø©
            
        Returns:
            Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª
        """
        suggestions = []
        
        if issue_type == 'no_progression':
            suggestions.extend([
                'Ø¥Ø¶Ø§ÙØ© Ù†Ù‚Ø·Ø© ØªØ­ÙˆÙ„ Ù…Ø­ÙˆØ±ÙŠØ© ØªØºÙŠØ± Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ© Ø§Ù„ØµØ±Ø§Ø¹',
                'Ø¥Ø¯Ø®Ø§Ù„ Ù…Ø¹Ù„ÙˆÙ…Ø© Ø¬Ø¯ÙŠØ¯Ø© Ø£Ùˆ Ø­Ø¯Ø« Ø®Ø§Ø±Ø¬ÙŠ ÙŠØµØ¹Ù‘Ø¯ Ø§Ù„Ù…ÙˆÙ‚Ù',
                'ØªØºÙŠÙŠØ± ØªÙˆØ§Ø²Ù† Ø§Ù„Ù‚ÙˆÙ‰ Ø¨ÙŠÙ† Ø§Ù„Ø£Ø·Ø±Ø§Ù Ø§Ù„Ù…ØªØµØ§Ø±Ø¹Ø©'
            ])
        
        elif issue_type == 'stuck_in_phase':
            suggestions.extend([
                f'Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ù…Ù† Ù…Ø±Ø­Ù„Ø© {conflict.phase.name} Ø¥Ù„Ù‰ Ù…Ø±Ø­Ù„Ø© Ø£ÙƒØ«Ø± Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©',
                'Ø¥Ø¶Ø§ÙØ© Ø¶ØºØ· Ø²Ù…Ù†ÙŠ Ø£Ùˆ Ù…Ù‡Ù„Ø© Ù†Ù‡Ø§Ø¦ÙŠØ©',
                'Ø¥Ø¯Ø®Ø§Ù„ Ø´Ø®ØµÙŠØ© Ø£Ùˆ Ø¹Ù†ØµØ± Ø¬Ø¯ÙŠØ¯ Ù„ÙƒØ³Ø± Ø§Ù„Ø¬Ù…ÙˆØ¯'
            ])
        
        elif issue_type == 'insufficient_involvement':
            suggestions.extend([
                'Ø¥Ø¶Ø§ÙØ© Ø´Ø®ØµÙŠØ§Øª Ø¯Ø§Ø¹Ù…Ø© Ù„Ù„ØµØ±Ø§Ø¹',
                'ØªÙˆØ³ÙŠØ¹ Ù†Ø·Ø§Ù‚ Ø§Ù„ØµØ±Ø§Ø¹ Ù„ÙŠØ´Ù…Ù„ Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ø´Ø®ØµÙŠØ§Øª',
                'Ø±Ø¨Ø· Ø§Ù„ØµØ±Ø§Ø¹ Ø¨Ø®Ø·ÙˆØ· Ø³Ø±Ø¯ÙŠØ© Ø£Ø®Ø±Ù‰'
            ])
        
        return suggestions
    
    def _get_revival_strategy(self, issue_type: str) -> str:
        """
        Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø¥Ø­ÙŠØ§Ø¡ Ù…Ø®ØªØµØ±Ø©
        
        Args:
            issue_type: Ù†ÙˆØ¹ Ø§Ù„Ù…Ø´ÙƒÙ„Ø©
            
        Returns:
            Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø§Ù„Ø¥Ø­ÙŠØ§Ø¡
        """
        strategies = {
            'no_progression': 'Ø¥Ø¶Ø§ÙØ© Ù†Ù‚Ø·Ø© ØªØ­ÙˆÙ„ Ø£Ùˆ ØªØµØ¹ÙŠØ¯',
            'stuck_in_phase': 'ØªØºÙŠÙŠØ± Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø£Ùˆ Ø¥Ø¯Ø®Ø§Ù„ Ø¹Ù†ØµØ± Ø®Ø§Ø±Ø¬ÙŠ',
            'insufficient_involvement': 'Ø¥Ø¶Ø§ÙØ© Ø´Ø®ØµÙŠØ§Øª Ø£Ùˆ ØªÙˆØ³ÙŠØ¹ Ø§Ù„Ù†Ø·Ø§Ù‚'
        }
        return strategies.get(issue_type, 'Ø¥Ø¹Ø§Ø¯Ø© ØªÙ‚ÙŠÙŠÙ… Ø¯ÙˆØ± Ø§Ù„ØµØ±Ø§Ø¹ ÙÙŠ Ø§Ù„Ù‚ØµØ©')
    
    def _suggest_load_redistribution(
        self, 
        char_id: str, 
        rel_count: int, 
        conf_count: int
    ) -> List[str]:
        """
        Ø§Ù‚ØªØ±Ø§Ø­ Ø¥Ø¹Ø§Ø¯Ø© ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø­Ù…Ù„ Ù…Ù† Ø´Ø®ØµÙŠØ© Ù…Ø­Ù…Ù„Ø©
        
        Args:
            char_id: Ù…Ø¹Ø±Ù‘Ù Ø§Ù„Ø´Ø®ØµÙŠØ©
            rel_count: Ø¹Ø¯Ø¯ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
            conf_count: Ø¹Ø¯Ø¯ Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
            
        Returns:
            Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªÙˆØ²ÙŠØ¹
        """
        suggestions = []
        character = self.network.characters.get(char_id)
        
        if character:
            if rel_count > 5:
                suggestions.append(
                    f'Ù†Ù‚Ù„ {int(rel_count * 0.3)} Ø¹Ù„Ø§Ù‚Ø§Øª Ø¥Ù„Ù‰ Ø´Ø®ØµÙŠØ§Øª Ø¯Ø§Ø¹Ù…Ø© Ø¬Ø¯ÙŠØ¯Ø©'
                )
            
            if conf_count > 3:
                suggestions.append(
                    f'ØªÙˆØ²ÙŠØ¹ {int(conf_count * 0.25)} ØµØ±Ø§Ø¹Ø§Øª Ø¹Ù„Ù‰ Ø´Ø®ØµÙŠØ§Øª Ø£Ø®Ø±Ù‰'
                )
            
            suggestions.append(
                'Ø¥Ù†Ø´Ø§Ø¡ Ø´Ø®ØµÙŠØ§Øª Ø«Ø§Ù†ÙˆÙŠØ© Ù„ØªØ®ÙÙŠÙ Ø§Ù„Ø­Ù…Ù„ Ø§Ù„Ø¯Ø±Ø§Ù…ÙŠ'
            )
        
        return suggestions
    
    def _generate_diagnostic_summary(
        self, 
        health_score: float, 
        criticality_level: str
    ) -> str:
        """
        ØªÙˆÙ„ÙŠØ¯ Ù…Ù„Ø®Øµ ØªØ´Ø®ÙŠØµÙŠ Ø´Ø§Ù…Ù„
        
        Args:
            health_score: Ø¯Ø±Ø¬Ø© Ø§Ù„ØµØ­Ø©
            criticality_level: Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø®Ø·ÙˆØ±Ø©
            
        Returns:
            Ù†Øµ Ø§Ù„Ù…Ù„Ø®Øµ
        """
        summary_parts = [
            f"ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø´Ø¨ÙƒØ©: {health_score:.1f}/100 ({criticality_level})",
            f"\nØ¹Ø¯Ø¯ Ø§Ù„Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„Ù…ÙƒØªØ´ÙØ©:",
            f"  â€¢ Ù…Ø´Ø§ÙƒÙ„ Ù‡ÙŠÙƒÙ„ÙŠØ©: {len(self.structural_issues)}",
            f"  â€¢ Ø´Ø®ØµÙŠØ§Øª Ù…Ø¹Ø²ÙˆÙ„Ø©: {len(self.isolated_characters)}",
            f"  â€¢ ØµØ±Ø§Ø¹Ø§Øª Ù…Ù‡Ù…Ù„Ø©: {len(self.abandoned_conflicts)}",
            f"  â€¢ Ø´Ø®ØµÙŠØ§Øª Ù…Ø­Ù…Ù„Ø©: {len(self.overloaded_characters)}",
            f"  â€¢ Ø§ØªØµØ§Ù„Ø§Øª Ø¶Ø¹ÙŠÙØ©: {len(self.weak_connections)}",
            f"  â€¢ Ù…Ø´Ø§ÙƒÙ„ ØªÙƒØ±Ø§Ø±: {len(self.redundancy_issues)}"
        ]
        
        # Ø§Ù„ØªÙˆØµÙŠØ© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
        if criticality_level == 'critical':
            summary_parts.append(
                "\nâš ï¸ ØªØ­Ø°ÙŠØ±: Ø§Ù„Ø´Ø¨ÙƒØ© ÙÙŠ Ø­Ø§Ù„Ø© Ø­Ø±Ø¬Ø© ÙˆØªØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ Ù…Ø±Ø§Ø¬Ø¹Ø© Ø´Ø§Ù…Ù„Ø© ÙÙˆØ±ÙŠØ©"
            )
        elif criticality_level == 'major_issues':
            summary_parts.append(
                "\nâš ï¸ ØªÙ†Ø¨ÙŠÙ‡: ØªÙˆØ¬Ø¯ Ù…Ø´Ø§ÙƒÙ„ ÙƒØ¨ÙŠØ±Ø© ØªØªØ·Ù„Ø¨ Ù…Ø¹Ø§Ù„Ø¬Ø© Ù‚Ø¨Ù„ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©"
            )
        elif criticality_level == 'moderate_issues':
            summary_parts.append(
                "\nâœ“ Ø§Ù„Ø´Ø¨ÙƒØ© ÙÙŠ Ø­Ø§Ù„Ø© Ø¬ÙŠØ¯Ø© Ù…Ø¹ Ø¨Ø¹Ø¶ Ø§Ù„Ù…Ø¬Ø§Ù„Ø§Øª Ù„Ù„ØªØ­Ø³ÙŠÙ†"
            )
        else:
            summary_parts.append(
                "\nâœ“ Ø§Ù„Ø´Ø¨ÙƒØ© ÙÙŠ Ø­Ø§Ù„Ø© ØµØ­ÙŠØ© Ù…Ù…ØªØ§Ø²Ø©"
            )
        
        return '\n'.join(summary_parts)


# Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø³Ø±ÙŠØ¹
def diagnose_network(network: ConflictNetwork) -> Dict[str, Any]:
    """
    Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„ØªØ´Ø®ÙŠØµ Ø§Ù„ÙƒØ§Ù…Ù„ Ø¹Ù„Ù‰ Ø´Ø¨ÙƒØ©
    
    Args:
        network: Ø´Ø¨ÙƒØ© Ø§Ù„ØµØ±Ø§Ø¹ Ø§Ù„Ù…Ø±Ø§Ø¯ ØªØ­Ù„ÙŠÙ„Ù‡Ø§
        
    Returns:
        ØªÙ‚Ø±ÙŠØ± ØªØ´Ø®ÙŠØµÙŠ Ø´Ø§Ù…Ù„
    """
    diagnostics = NetworkDiagnostics(network)
    return diagnostics.run_all_diagnostics()

    """
ÙˆØ­Ø¯Ø© Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø§Ù„Ø¹Ù„Ø§Ø¬ ÙˆØ§Ù„ØªØ­Ø³ÙŠÙ†
===================================
ØªÙ‚Ø¯Ù… Ø­Ù„ÙˆÙ„Ø§Ù‹ Ø¹Ù…Ù„ÙŠØ© ÙˆÙ…Ù†Ù‡Ø¬ÙŠØ© Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„Ù…ÙƒØªØ´ÙØ© ÙÙŠ Ø´Ø¨ÙƒØ© Ø§Ù„ØµØ±Ø§Ø¹
ÙˆØªØ­Ø³ÙŠÙ† Ø¬ÙˆØ¯Ø© Ø§Ù„Ø³Ø±Ø¯ Ø§Ù„Ø¯Ø±Ø§Ù…ÙŠ.

Ø§Ù„Ù…Ø¤Ù„Ù: Ù†Ø¸Ø§Ù… ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù†ØµÙˆØµ Ø§Ù„Ø¯Ø±Ø§Ù…ÙŠØ©  
Ø§Ù„Ø¥ØµØ¯Ø§Ø±: 2.0.0 (Production Ready)
"""

import logging
from typing import Dict, List, Any, Optional, Set, Tuple
from collections import defaultdict
from datetime import datetime

from core.base_entities import (
    ConflictNetwork,
    Conflict,
    Character,
    Relationship,
    ConflictPhase,
    ConflictSubject,
    RelationshipType,
    RelationshipNature
)

logger = logging.getLogger(__name__)


class TreatmentStrategies:
    """
    Ù…Ø­Ù„Ù„ ÙˆÙ…ÙˆÙ„Ø¯ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø§Ù„Ø¹Ù„Ø§Ø¬ Ù„Ù„Ø´Ø¨ÙƒØ§Øª Ø§Ù„Ø¯Ø±Ø§Ù…ÙŠØ©
    
    ÙŠÙ‚Ø¯Ù…:
    - Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø°Ø§Øª Ø£ÙˆÙ„ÙˆÙŠØ© Ø¹Ø§Ù„ÙŠØ© Ù„Ù„Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„Ø­Ø±Ø¬Ø©
    - Ø¥ØµÙ„Ø§Ø­Ø§Øª Ø³Ø±ÙŠØ¹Ø© Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªÙ†ÙÙŠØ° Ø§Ù„ÙÙˆØ±ÙŠ
    - Ù…Ø±Ø§Ø¬Ø¹Ø§Øª Ù‡ÙŠÙƒÙ„ÙŠØ© Ø´Ø§Ù…Ù„Ø©
    - Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª Ù„ØªØ·ÙˆÙŠØ± Ø§Ù„Ø´Ø®ØµÙŠØ§Øª
    - Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ù„ØªØ¹Ø²ÙŠØ² Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
    """
    
    def __init__(
        self, 
        network: ConflictNetwork,
        diagnostics_report: Optional[Dict[str, Any]] = None
    ):
        """
        ØªÙ‡ÙŠØ¦Ø© Ù…Ø­Ù„Ù„ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø§Ù„Ø¹Ù„Ø§Ø¬
        
        Args:
            network: Ø´Ø¨ÙƒØ© Ø§Ù„ØµØ±Ø§Ø¹
            diagnostics_report: ØªÙ‚Ø±ÙŠØ± Ø§Ù„ØªØ´Ø®ÙŠØµ (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)
        """
        self.network = network
        self.diagnostics_report = diagnostics_report or {}
        
        # Ù†ØªØ§Ø¦Ø¬ Ø§Ù„ØªØ­Ù„ÙŠÙ„
        self.prioritized_actions: List[Dict[str, Any]] = []
        self.quick_fixes: List[Dict[str, Any]] = []
        self.structural_revisions: List[Dict[str, Any]] = []
        self.character_suggestions: List[Dict[str, Any]] = []
        self.conflict_strategies: List[Dict[str, Any]] = []
        
        logger.info(f"TreatmentStrategies initialized for: {network.name}")
    
    def analyze_and_recommend_treatments(self) -> Dict[str, Any]:
        """
        ØªØ­Ù„ÙŠÙ„ Ø´Ø§Ù…Ù„ ÙˆØªÙˆÙ„ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªÙˆØµÙŠØ§Øª Ø§Ù„Ø¹Ù„Ø§Ø¬ÙŠØ©
        
        Returns:
            Ù…Ø¬Ù…ÙˆØ¹Ø© Ø´Ø§Ù…Ù„Ø© Ù…Ù† Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø§Ù„Ø¹Ù„Ø§Ø¬
        """
        logger.info("="*60)
        logger.info("Generating comprehensive treatment strategies...")
        logger.info("="*60)
        
        # 1. ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø°Ø§Øª Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ©
        self.prioritized_actions = self._generate_prioritized_actions()
        logger.info(f"âœ“ Prioritized actions generated: {len(self.prioritized_actions)}")
        
        # 2. Ø¥Ù†Ø´Ø§Ø¡ Ø¥ØµÙ„Ø§Ø­Ø§Øª Ø³Ø±ÙŠØ¹Ø©
        self.quick_fixes = self._generate_quick_fixes()
        logger.info(f"âœ“ Quick fixes identified: {len(self.quick_fixes)}")
        
        # 3. Ø§Ù‚ØªØ±Ø§Ø­ Ù…Ø±Ø§Ø¬Ø¹Ø§Øª Ù‡ÙŠÙƒÙ„ÙŠØ©
        self.structural_revisions = self._plan_structural_revisions()
        logger.info(f"âœ“ Structural revisions planned: {len(self.structural_revisions)}")
        
        # 4. Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª ØªØ·ÙˆÙŠØ± Ø§Ù„Ø´Ø®ØµÙŠØ§Øª
        self.character_suggestions = self._develop_character_suggestions()
        logger.info(f"âœ“ Character development suggestions: {len(self.character_suggestions)}")
        
        # 5. Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª ØªØ¹Ø²ÙŠØ² Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
        self.conflict_strategies = self._enhance_conflict_strategies()
        logger.info(f"âœ“ Conflict enhancement strategies: {len(self.conflict_strategies)}")
        
        # 6. Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ø®Øµ Ù…ÙˆØ­Ø¯
        consolidated_summary = self._create_consolidated_summary()
        
        logger.info("="*60)
        logger.info("Treatment strategies generation completed")
        logger.info("="*60)
        
        return {
            'prioritized_actions': self.prioritized_actions,
            'quick_fixes': self.quick_fixes,
            'structural_revisions': self.structural_revisions,
            'character_development_suggestions': self.character_suggestions,
            'conflict_enhancement_strategies': self.conflict_strategies,
            'consolidated_summary': consolidated_summary,
            'total_recommendations': (
                len(self.prioritized_actions) + 
                len(self.quick_fixes) + 
                len(self.structural_revisions) +
                len(self.character_suggestions) +
                len(self.conflict_strategies)
            ),
            'implementation_roadmap': self._create_implementation_roadmap()
        }
    
    def _generate_prioritized_actions(self) -> List[Dict[str, Any]]:
        """
        ØªÙˆÙ„ÙŠØ¯ Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ù…Ø±ØªØ¨Ø© Ø­Ø³Ø¨ Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ©
        
        Returns:
            Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø°Ø§Øª Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ©
        """
        actions = []
        
        # Ù…Ù† Ø§Ù„Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„Ù‡ÙŠÙƒÙ„ÙŠØ©
        structural_issues = self.diagnostics_report.get('structural_issues', [])
        for issue in structural_issues:
            priority = self._map_severity_to_priority(issue.get('severity', 'low'))
            
            actions.append({
                'priority': priority,
                'action_type': 'structural_fix',
                'target_entity': {
                    'type': 'network_structure',
                    'issue_type': issue.get('type'),
                    'description': issue.get('description')
                },
                'description': issue.get('recommendation', 'Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ø´ÙƒÙ„Ø© Ø§Ù„Ù‡ÙŠÙƒÙ„ÙŠØ©'),
                'expected_impact': issue.get('potential_impact', 'ØªØ­Ø³ÙŠÙ† Ø§Ù„ØªÙ…Ø§Ø³Ùƒ Ø§Ù„Ø³Ø±Ø¯ÙŠ'),
                'effort': self._estimate_effort(issue.get('type')),
                'estimated_time': self._estimate_time(issue.get('type')),
                'risk_level': 'low'
            })
        
        # Ù…Ù† Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ø¹Ø²ÙˆÙ„Ø©
        isolated_chars = self.diagnostics_report.get('isolated_characters', {}).get('characters', [])
        for char_issue in isolated_chars:
            if char_issue.get('isolation_type') == 'completely_isolated':
                actions.append({
                    'priority': 'high',
                    'action_type': 'integrate_character',
                    'target_entity': {
                        'type': 'character',
                        'id': char_issue.get('character_id'),
                        'name': char_issue.get('character_name')
                    },
                    'description': f"Ø¯Ù…Ø¬ Ø§Ù„Ø´Ø®ØµÙŠØ© Ø§Ù„Ù…Ø¹Ø²ÙˆÙ„Ø© '{char_issue.get('character_name')}' ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©",
                    'expected_impact': 'ØªØ¹Ø²ÙŠØ² Ø§Ù„ØªÙ…Ø§Ø³Ùƒ Ø§Ù„Ø³Ø±Ø¯ÙŠ ÙˆØ¥Ø«Ø±Ø§Ø¡ Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ§Øª',
                    'effort': 'medium',
                    'estimated_time': '2-4 Ø³Ø§Ø¹Ø§Øª',
                    'risk_level': 'low',
                    'specific_suggestions': char_issue.get('suggested_connections', [])
                })
        
        # Ù…Ù† Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„Ù…Ù‡Ù…Ù„Ø©
        abandoned_conflicts = self.diagnostics_report.get('abandoned_conflicts', {}).get('conflicts', [])
        for conf_issue in abandoned_conflicts:
            actions.append({
                'priority': 'high' if conf_issue.get('issue_type') == 'no_progression' else 'medium',
                'action_type': 'revive_conflict',
                'target_entity': {
                    'type': 'conflict',
                    'id': conf_issue.get('conflict_id'),
                    'name': conf_issue.get('conflict_name')
                },
                'description': f"Ø¥Ø­ÙŠØ§Ø¡ Ø§Ù„ØµØ±Ø§Ø¹ Ø§Ù„Ù…Ù‡Ù…Ù„ '{conf_issue.get('conflict_name')}'",
                'expected_impact': 'Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø²Ø®Ù… Ø§Ù„Ø³Ø±Ø¯ÙŠ ÙˆØªØ¬Ø¯ÙŠØ¯ Ø§Ù„Ø§Ù‡ØªÙ…Ø§Ù…',
                'effort': 'medium',
                'estimated_time': '3-6 Ø³Ø§Ø¹Ø§Øª',
                'risk_level': 'medium',
                'specific_suggestions': conf_issue.get('suggested_actions', [])
            })
        
        # Ù…Ù† Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ø­Ù…Ù„Ø©
        overloaded_chars = self.diagnostics_report.get('overloaded_characters', {}).get('characters', [])
        for char_issue in overloaded_chars:
            actions.append({
                'priority': 'medium',
                'action_type': 'redistribute_load',
                'target_entity': {
                    'type': 'character',
                    'id': char_issue.get('character_id'),
                    'name': char_issue.get('character_name')
                },
                'description': f"Ø¥Ø¹Ø§Ø¯Ø© ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø­Ù…Ù„ Ø¹Ù† '{char_issue.get('character_name')}'",
                'expected_impact': 'ØªØ­Ø³ÙŠÙ† Ø§Ù„ØªÙˆØ§Ø²Ù† Ø§Ù„Ø³Ø±Ø¯ÙŠ ÙˆØªØ·ÙˆÙŠØ± Ø´Ø®ØµÙŠØ§Øª Ø«Ø§Ù†ÙˆÙŠØ©',
                'effort': 'high',
                'estimated_time': '4-8 Ø³Ø§Ø¹Ø§Øª',
                'risk_level': 'medium',
                'specific_suggestions': char_issue.get('suggested_redistribution', [])
            })
        
        # ØªØ±ØªÙŠØ¨ Ø­Ø³Ø¨ Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ©
        priority_order = {'critical': 0, 'high': 1, 'medium': 2, 'low': 3}
        actions.sort(key=lambda x: priority_order.get(x['priority'], 99))
        
        return actions
    
    def _generate_quick_fixes(self) -> List[Dict[str, Any]]:
        """
        ØªÙˆÙ„ÙŠØ¯ Ø¥ØµÙ„Ø§Ø­Ø§Øª Ø³Ø±ÙŠØ¹Ø© Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªÙ†ÙÙŠØ° Ø§Ù„ÙÙˆØ±ÙŠ
        
        Returns:
            Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¥ØµÙ„Ø§Ø­Ø§Øª Ø§Ù„Ø³Ø±ÙŠØ¹Ø©
        """
        fixes = []
        
        # Ø¥ØµÙ„Ø§Ø­Ø§Øª Ù„Ù„Ø§ØªØµØ§Ù„Ø§Øª Ø§Ù„Ø¶Ø¹ÙŠÙØ©
        weak_connections = self.diagnostics_report.get('weak_connections', {}).get('connections', [])
        for weak in weak_connections:
            if weak.get('connection_type') == 'relationship':
                fixes.append({
                    'issue_id': weak.get('connection_id'),
                    'fix_type': 'strengthen_relationship',
                    'description': weak.get('suggested_strengthening'),
                    'implementation': (
                        f"1. ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø©: {weak.get('connection_id')}\n"
                        f"2. Ø²ÙŠØ§Ø¯Ø© Ù‚ÙŠÙ…Ø© strength Ù…Ù† {weak.get('strength_score')} Ø¥Ù„Ù‰ 6-7\n"
                        f"3. Ø¥Ø¶Ø§ÙØ© Ù…Ø´Ø§Ù‡Ø¯ ØªÙØ§Ø¹Ù„ÙŠØ© Ø¨ÙŠÙ† Ø§Ù„Ø´Ø®ØµÙŠØ§Øª\n"
                        f"4. ØªØ¹Ù…ÙŠÙ‚ Ø§Ù„Ø¯ÙˆØ§ÙØ¹ Ø§Ù„Ù…Ø´ØªØ±ÙƒØ©"
                    ),
                    'estimated_time': '30-60 Ø¯Ù‚ÙŠÙ‚Ø©',
                    'impact': 'Ù…ØªÙˆØ³Ø·',
                    'complexity': 'Ù…Ù†Ø®ÙØ¶'
                })
            
            elif weak.get('connection_type') == 'conflict':
                fixes.append({
                    'issue_id': weak.get('connection_id'),
                    'fix_type': 'intensify_conflict',
                    'description': f"ØªÙƒØ«ÙŠÙ Ø§Ù„ØµØ±Ø§Ø¹ Ø§Ù„Ø¶Ø¹ÙŠÙ ({weak.get('strength_score')}/10)",
                    'implementation': (
                        f"1. ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ØµØ±Ø§Ø¹: {weak.get('connection_id')}\n"
                        f"2. Ø±ÙØ¹ Ø¯Ø±Ø¬Ø© strength Ø¥Ù„Ù‰ 6-8\n"
                        f"3. Ø¥Ø¶Ø§ÙØ© Ù…Ø®Ø§Ø·Ø± Ø£Ùˆ Ø¹ÙˆØ§Ù‚Ø¨ Ø£ÙƒØ¨Ø±\n"
                        f"4. Ø²ÙŠØ§Ø¯Ø© Ø§Ù„ØªÙˆØªØ± Ø¨ÙŠÙ† Ø§Ù„Ø£Ø·Ø±Ø§Ù Ø§Ù„Ù…ØªØµØ§Ø±Ø¹Ø©"
                    ),
                    'estimated_time': '1-2 Ø³Ø§Ø¹Ø©',
                    'impact': 'Ø¹Ø§Ù„ÙŠ',
                    'complexity': 'Ù…ØªÙˆØ³Ø·'
                })
        
        # Ø¥ØµÙ„Ø§Ø­Ø§Øª Ù„Ù„ØªÙƒØ±Ø§Ø±Ø§Øª
        redundancies = self.diagnostics_report.get('redundancy_issues', {}).get('issues', [])
        for redundancy in redundancies:
            if redundancy.get('type') == 'duplicate_relationships':
                fixes.append({
                    'issue_id': f"redundancy_{redundancy.get('entity_ids', ['unknown'])[0]}",
                    'fix_type': 'merge_duplicates',
                    'description': redundancy.get('suggested_merge'),
                    'implementation': (
                        f"1. Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª Ø§Ù„Ù…ÙƒØ±Ø±Ø© Ø¨ÙŠÙ†: {', '.join(redundancy.get('entities', []))}\n"
                        f"2. Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø¹Ù„Ø§Ù‚Ø© Ø§Ù„Ø£Ù‚ÙˆÙ‰ ÙƒØ£Ø³Ø§Ø³\n"
                        f"3. Ø¯Ù…Ø¬ Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª Ø§Ù„Ø£Ø®Ø±Ù‰\n"
                        f"4. Ø­Ø°Ù Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª Ø§Ù„Ù…ÙƒØ±Ø±Ø©"
                    ),
                    'estimated_time': '15-30 Ø¯Ù‚ÙŠÙ‚Ø©',
                    'impact': 'Ù…Ù†Ø®ÙØ¶',
                    'complexity': 'Ù…Ù†Ø®ÙØ¶'
                })
        
        return fixes
    
    def _plan_structural_revisions(self) -> List[Dict[str, Any]]:
        """
        ØªØ®Ø·ÙŠØ· Ù…Ø±Ø§Ø¬Ø¹Ø§Øª Ù‡ÙŠÙƒÙ„ÙŠØ© Ø´Ø§Ù…Ù„Ø©
        
        Returns:
            Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø§Øª Ø§Ù„Ù‡ÙŠÙƒÙ„ÙŠØ©
        """
        revisions = []
        
        # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª Ø§Ù„Ù…Ù†ÙØµÙ„Ø©
        structural_issues = self.diagnostics_report.get('structural_issues', [])
        for issue in structural_issues:
            if issue.get('type') == 'disconnected_components':
                components = issue.get('affected_entities', {}).get('components', [])
                
                revisions.append({
                    'revision_type': 'bridge_disconnected_components',
                    'scope': 'network-wide',
                    'description': f'Ø±Ø¨Ø· {len(components)} Ù…ÙƒÙˆÙ†Ø§Øª Ù…Ù†ÙØµÙ„Ø© ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©',
                    'rationale': 'ØªØ­Ø³ÙŠÙ† Ø§Ù„ØªÙ…Ø§Ø³Ùƒ Ø§Ù„Ø³Ø±Ø¯ÙŠ ÙˆÙˆØ­Ø¯Ø© Ø§Ù„Ù‚ØµØ©',
                    'steps': [
                        f'ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª Ø§Ù„Ù…Ù†ÙØµÙ„Ø©: {len(components)} Ù…ÙƒÙˆÙ†Ø§Øª',
                        'ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø«ÙŠÙ…Ø§Øª ÙˆØ§Ù„Ù…ÙˆØ¶ÙˆØ¹Ø§Øª Ø§Ù„Ù…Ø´ØªØ±ÙƒØ© Ø¨ÙŠÙ† Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª',
                        'Ø¥Ù†Ø´Ø§Ø¡ Ø´Ø®ØµÙŠØ© Ø¬Ø³Ø± (Bridge Character) Ø£Ùˆ Ø­Ø¯Ø« Ù…Ø­ÙˆØ±ÙŠ',
                        'Ø±Ø¨Ø· Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª Ù…Ù† Ø®Ù„Ø§Ù„ Ø¹Ù„Ø§Ù‚Ø§Øª Ø£Ùˆ ØµØ±Ø§Ø¹Ø§Øª Ù…Ø´ØªØ±ÙƒØ©',
                        'Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªØ­Ø³Ù† Ø§Ù„ØªÙ…Ø§Ø³Ùƒ Ø§Ù„Ø´Ø¨ÙƒÙŠ'
                    ],
                    'affected_elements': [
                        comp[0] if isinstance(comp, list) and len(comp) > 0 else 'unknown'
                        for comp in components
                    ],
                    'expected_outcome': 'Ø´Ø¨ÙƒØ© Ù…ÙˆØ­Ø¯Ø© ÙˆÙ…ØªÙ…Ø§Ø³ÙƒØ© Ø¨Ø¯ÙˆÙ† Ù…ÙƒÙˆÙ†Ø§Øª Ù…Ø¹Ø²ÙˆÙ„Ø©',
                    'effort': 'high',
                    'estimated_duration': '1-2 Ø£Ø³Ø§Ø¨ÙŠØ¹',
                    'risk_assessment': {
                        'probability': 'medium',
                        'impact': 'high',
                        'mitigation': 'Ø¥Ù†Ø´Ø§Ø¡ Ù†Ù‚Ø§Ø· Ø±Ø¨Ø· Ø·Ø¨ÙŠØ¹ÙŠØ© ØªØªÙ…Ø§Ø´Ù‰ Ù…Ø¹ Ø§Ù„Ø«ÙŠÙ…Ø§Øª Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø©'
                    }
                })
            
            elif issue.get('type') == 'bottleneck_character':
                char_name = issue.get('affected_entities', {}).get('character_name')
                
                revisions.append({
                    'revision_type': 'redistribute_from_bottleneck',
                    'scope': 'character-centric',
                    'description': f'Ø¥Ø¹Ø§Ø¯Ø© ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø®ØµÙŠØ© Ø§Ù„Ù…Ø­ÙˆØ±ÙŠØ©: {char_name}',
                    'rationale': 'ØªÙ‚Ù„ÙŠÙ„ Ù†Ù‚Ø§Ø· Ø§Ù„Ø§Ø®ØªÙ†Ø§Ù‚ ÙˆØ²ÙŠØ§Ø¯Ø© Ù…Ø±ÙˆÙ†Ø© Ø§Ù„Ø´Ø¨ÙƒØ©',
                    'steps': [
                        f'ØªØ­Ø¯ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª Ø§Ù„ØªÙŠ ØªÙ…Ø± Ø¹Ø¨Ø± {char_name}',
                        'Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø±Ø§Øª Ø¨Ø¯ÙŠÙ„Ø© Ø¨ÙŠÙ† Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ø£Ø®Ø±Ù‰',
                        'ØªØ·ÙˆÙŠØ± Ø´Ø®ØµÙŠØ§Øª Ø«Ø§Ù†ÙˆÙŠØ© Ù„ØªØ­Ù…Ù„ Ø¨Ø¹Ø¶ Ø§Ù„Ø£Ø¯ÙˆØ§Ø±',
                        'Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø£Ù‡Ù…ÙŠØ© Ø§Ù„Ø´Ø®ØµÙŠØ© Ø¯ÙˆÙ† Ø¬Ø¹Ù„Ù‡Ø§ Ù†Ù‚Ø·Ø© Ø§Ø®ØªÙ†Ø§Ù‚'
                    ],
                    'affected_elements': [char_name] if char_name else [],
                    'expected_outcome': 'Ø´Ø¨ÙƒØ© Ø£ÙƒØ«Ø± Ù…Ø±ÙˆÙ†Ø© Ù…Ø¹ ØªÙˆØ²ÙŠØ¹ Ø£ÙØ¶Ù„ Ù„Ù„Ø£Ø¯ÙˆØ§Ø±',
                    'effort': 'medium',
                    'estimated_duration': '3-5 Ø£ÙŠØ§Ù…',
                    'risk_assessment': {
                        'probability': 'low',
                        'impact': 'medium',
                        'mitigation': 'Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø¯ÙˆØ± Ø§Ù„Ø´Ø®ØµÙŠØ© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ'
                    }
                })
        
        # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØªÙƒØ±Ø§Ø±Ø§Øª Ø§Ù„ÙƒØ¨ÙŠØ±Ø©
        redundancies = self.diagnostics_report.get('redundancy_issues', {}).get('issues', [])
        if len(redundancies) > 3:
            revisions.append({
                'revision_type': 'consolidate_redundancies',
                'scope': 'network-wide',
                'description': 'Ø¯Ù…Ø¬ ÙˆØªØ¨Ø³ÙŠØ· Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù…ÙƒØ±Ø±Ø© ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©',
                'rationale': 'ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„ØªØ¹Ù‚ÙŠØ¯ ØºÙŠØ± Ø§Ù„Ø¶Ø±ÙˆØ±ÙŠ ÙˆØªØ­Ø³ÙŠÙ† Ø§Ù„ÙˆØ¶ÙˆØ­',
                'steps': [
                    f'Ù…Ø±Ø§Ø¬Ø¹Ø© Ø¬Ù…ÙŠØ¹ {len(redundancies)} Ø­Ø§Ù„Ø© ØªÙƒØ±Ø§Ø±',
                    'ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ù„ÙƒÙ„ Ù…Ø¬Ù…ÙˆØ¹Ø© Ù…ÙƒØ±Ø±Ø©',
                    'Ø¯Ù…Ø¬ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù…ØªØ´Ø§Ø¨Ù‡Ø© ÙÙŠ ÙƒÙŠØ§Ù†Ø§Øª Ø£ÙƒØ«Ø± ØªØ¹Ù‚ÙŠØ¯Ø§Ù‹',
                    'Ø¥Ø¹Ø§Ø¯Ø© ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª ÙˆØ§Ù„Ø£Ø¯ÙˆØ§Ø±',
                    'Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‡Ù…ÙŠØ© Ø§Ù„Ø³Ø±Ø¯ÙŠØ©'
                ],
                'affected_elements': [
                    r.get('entities', ['unknown'])[0] for r in redundancies[:5]
                ],
                'expected_outcome': 'Ø¨Ù†ÙŠØ© Ø£Ø¨Ø³Ø· ÙˆØ£ÙƒØ«Ø± ÙˆØ¶ÙˆØ­Ø§Ù‹',
                'effort': 'medium',
                'estimated_duration': '4-7 Ø£ÙŠØ§Ù…',
                'risk_assessment': {
                    'probability': 'low',
                    'impact': 'medium',
                    'mitigation': 'Ø§Ù„Ø¯Ù…Ø¬ Ø§Ù„ØªØ¯Ø±ÙŠØ¬ÙŠ Ù…Ø¹ Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø£Ø«Ø±'
                }
            })
        
        return revisions
    
    def _develop_character_suggestions(self) -> List[Dict[str, Any]]:
        """
        ØªØ·ÙˆÙŠØ± Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø´Ø®ØµÙŠØ§Øª
        
        Returns:
            Ù‚Ø§Ø¦Ù…Ø© Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª ØªØ·ÙˆÙŠØ± Ø§Ù„Ø´Ø®ØµÙŠØ§Øª
        """
        suggestions = []
        
        # Ù„Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ø¹Ø²ÙˆÙ„Ø©
        isolated_chars = self.diagnostics_report.get('isolated_characters', {}).get('characters', [])
        for char_issue in isolated_chars:
            character = self.network.characters.get(char_issue.get('character_id'))
            
            if character:
                suggestions.append({
                    'character_id': char_issue.get('character_id'),
                    'character_name': char_issue.get('character_name'),
                    'issue': char_issue.get('isolation_type'),
                    'development_focus': 'Integration and Relationship Building',
                    'suggested_actions': [
                        'Ø¥Ù†Ø´Ø§Ø¡ Ø¹Ù„Ø§Ù‚Ø© Ù‚ÙˆÙŠØ© Ù…Ø¹ Ø´Ø®ØµÙŠØ© Ù…Ø­ÙˆØ±ÙŠØ© ÙˆØ§Ø­Ø¯Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„',
                        'Ø¥Ø¶Ø§ÙØ© Ø¯Ø§ÙØ¹ Ø´Ø®ØµÙŠ ÙŠØ±Ø¨Ø· Ø§Ù„Ø´Ø®ØµÙŠØ© Ø¨Ø§Ù„ØµØ±Ø§Ø¹ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ',
                        'ØªØ·ÙˆÙŠØ± Ù‚ÙˆØ³ ØªØ­ÙˆÙ„ ÙŠØ¨Ø±Ø± Ø¯Ù…Ø¬Ù‡Ø§ ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©',
                        'Ø¥Ø¶Ø§ÙØ© Ù…Ø´Ø§Ù‡Ø¯ ØªÙØ§Ø¹Ù„ÙŠØ© Ù…Ø¹ Ø´Ø®ØµÙŠØ§Øª Ø£Ø®Ø±Ù‰'
                    ],
                    'narrative_role_enhancement': 'ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø´Ø®ØµÙŠØ© Ù…Ù† Ø¹Ù†ØµØ± Ù…Ø¹Ø²ÙˆÙ„ Ø¥Ù„Ù‰ Ø¬Ø²Ø¡ ÙØ§Ø¹Ù„ ÙÙŠ Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©',
                    'priority': 'high',
                    'estimated_scenes_needed': 3
                })
        
        # Ù„Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ø­Ù…Ù„Ø©
        overloaded_chars = self.diagnostics_report.get('overloaded_characters', {}).get('characters', [])
        for char_issue in overloaded_chars:
            character = self.network.characters.get(char_issue.get('character_id'))
            
            if character:
                suggestions.append({
                    'character_id': char_issue.get('character_id'),
                    'character_name': char_issue.get('character_name'),
                    'issue': 'overload',
                    'development_focus': 'Load Distribution and Role Clarification',
                    'suggested_actions': [
                        'ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø£Ø¯ÙˆØ§Ø± Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ù„Ù„Ø´Ø®ØµÙŠØ© Ø¨ÙˆØ¶ÙˆØ­',
                        'Ù†Ù‚Ù„ Ø¨Ø¹Ø¶ Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠØ§Øª Ø§Ù„Ø³Ø±Ø¯ÙŠØ© Ù„Ø´Ø®ØµÙŠØ§Øª Ø¯Ø§Ø¹Ù…Ø©',
                        'ØªØ·ÙˆÙŠØ± Ø´Ø®ØµÙŠØ§Øª Ø«Ø§Ù†ÙˆÙŠØ© Ù„ØªØ­Ù…Ù„ Ø¨Ø¹Ø¶ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª ÙˆØ§Ù„ØµØ±Ø§Ø¹Ø§Øª',
                        'Ø§Ù„ØªØ±ÙƒÙŠØ² Ø¹Ù„Ù‰ Ù‚ÙˆØ³ Ø§Ù„ØªØ·ÙˆØ± Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ Ù„Ù„Ø´Ø®ØµÙŠØ©'
                    ],
                    'narrative_role_enhancement': 'ØªØ¨Ø³ÙŠØ· Ø¯ÙˆØ± Ø§Ù„Ø´Ø®ØµÙŠØ© Ù„ØªØ­Ù‚ÙŠÙ‚ Ø¹Ù…Ù‚ Ø£ÙƒØ¨Ø±',
                    'priority': 'medium',
                    'estimated_new_characters_needed': 1
                })
        
        # Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª Ø¹Ø§Ù…Ø© Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø´Ø®ØµÙŠØ§Øª
        all_characters = list(self.network.characters.values())
        for character in all_characters[:5]:  # Ø£ÙˆÙ„ 5 Ø´Ø®ØµÙŠØ§Øª
            # ÙØ­Øµ Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…Ø¹Ø²ÙˆÙ„Ø© Ø£Ùˆ Ù…Ø­Ù…Ù„Ø©
            if not any(c.get('character_id') == character.id for c in isolated_chars + overloaded_chars):
                suggestions.append({
                    'character_id': character.id,
                    'character_name': character.name,
                    'issue': 'enhancement',
                    'development_focus': 'Depth and Complexity',
                    'suggested_actions': [
                        'Ø¥Ø¶Ø§ÙØ© Ø·Ø¨Ù‚Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ© Ù„Ù„Ø´Ø®ØµÙŠØ© (Ù…Ø§Ø¶ÙŠØŒ Ø³Ø±ØŒ ØµØ±Ø§Ø¹ Ø¯Ø§Ø®Ù„ÙŠ)',
                        'ØªØ·ÙˆÙŠØ± Ø¹Ù„Ø§Ù‚Ø© Ù…Ø¹Ù‚Ø¯Ø© ÙˆØ§Ø­Ø¯Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„',
                        'Ø¥Ø¶Ø§ÙØ© Ù„Ø­Ø¸Ø§Øª Ø¶Ø¹Ù Ø£Ùˆ ØªÙ†Ø§Ù‚Ø¶ Ù„Ø¬Ø¹Ù„ Ø§Ù„Ø´Ø®ØµÙŠØ© Ø£ÙƒØ«Ø± Ø¥Ù†Ø³Ø§Ù†ÙŠØ©',
                        'Ø±Ø¨Ø· Ø¯ÙˆØ§ÙØ¹ Ø§Ù„Ø´Ø®ØµÙŠØ© Ø¨Ø§Ù„Ø«ÙŠÙ…Ø§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù„Ù„Ù‚ØµØ©'
                    ],
                    'narrative_role_enhancement': 'ØªØ¹Ù…ÙŠÙ‚ Ø§Ù„Ø´Ø®ØµÙŠØ© ÙˆØ¬Ø¹Ù„Ù‡Ø§ Ø£ÙƒØ«Ø± ØªØ°ÙƒØ±Ø§Ù‹',
                    'priority': 'low',
                    'estimated_scenes_needed': 2
                })
        
        return suggestions
    
    def _enhance_conflict_strategies(self) -> List[Dict[str, Any]]:
        """
        ØªØ·ÙˆÙŠØ± Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ù„ØªØ¹Ø²ÙŠØ² Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
        
        Returns:
            Ù‚Ø§Ø¦Ù…Ø© Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª ØªØ¹Ø²ÙŠØ² Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
        """
        strategies = []
        
        # Ù„Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„Ù…Ù‡Ù…Ù„Ø©
        abandoned_conflicts = self.diagnostics_report.get('abandoned_conflicts', {}).get('conflicts', [])
        for conf_issue in abandoned_conflicts:
            conflict = self.network.conflicts.get(conf_issue.get('conflict_id'))
            
            if conflict:
                strategies.append({
                    'conflict_id': conf_issue.get('conflict_id'),
                    'conflict_name': conf_issue.get('conflict_name'),
                    'current_status': conf_issue.get('issue_type'),
                    'enhancement_type': 'reactivation',
                    'proposed_actions': [
                        'Ø¥Ø¶Ø§ÙØ© Ù†Ù‚Ø·Ø© ØªØ­ÙˆÙ„ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹Ø©',
                        'Ø±ÙØ¹ Ø§Ù„Ù…Ø®Ø§Ø·Ø± ÙˆØ§Ù„Ø¹ÙˆØ§Ù‚Ø¨',
                        'Ø¥Ø¯Ø®Ø§Ù„ Ù…Ø¹Ù„ÙˆÙ…Ø© Ø¬Ø¯ÙŠØ¯Ø© ØªØºÙŠØ± Ø§Ù„ØªÙˆØ§Ø²Ù†',
                        f'Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ù…Ù† Ù…Ø±Ø­Ù„Ø© {conf_issue.get("current_phase")} Ø¥Ù„Ù‰ Ù…Ø±Ø­Ù„Ø© Ø£ÙƒØ«Ø± Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©'
                    ],
                    'target_phase': self._suggest_next_phase(conf_issue.get('current_phase')),
                    'target_strength': 7,
                    'priority': 'high',
                    'expected_dramatic_impact': 'Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø§Ù‡ØªÙ…Ø§Ù… ÙˆØªØµØ¹ÙŠØ¯ Ø§Ù„ØªÙˆØªØ±'
                })
        
        # Ù„Ù„ØµØ±Ø§Ø¹Ø§Øª Ø§Ù„Ø¶Ø¹ÙŠÙØ©
        weak_connections = self.diagnostics_report.get('weak_connections', {}).get('connections', [])
        for weak in weak_connections:
            if weak.get('connection_type') == 'conflict':
                conflict = self.network.conflicts.get(weak.get('connection_id'))
                
                if conflict:
                    strategies.append({
                        'conflict_id': weak.get('connection_id'),
                        'conflict_name': conflict.name,
                        'current_status': 'weak',
                        'enhancement_type': 'intensification',
                        'proposed_actions': [
                            f'Ø±ÙØ¹ Ù‚ÙˆØ© Ø§Ù„ØµØ±Ø§Ø¹ Ù…Ù† {weak.get("strength_score")} Ø¥Ù„Ù‰ 7-8',
                            'Ø²ÙŠØ§Ø¯Ø© Ø¹Ø¯Ø¯ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ©',
                            'Ø±Ø¨Ø· Ø§Ù„ØµØ±Ø§Ø¹ Ø¨Ø«ÙŠÙ…Ø© Ø±Ø¦ÙŠØ³ÙŠØ©',
                            'Ø¥Ø¶Ø§ÙØ© Ø¹ÙˆØ§Ù‚Ø¨ Ø´Ø®ØµÙŠØ© Ù„ÙƒÙ„ Ø·Ø±Ù Ù…ØªØµØ§Ø±Ø¹'
                        ],
                        'target_phase': 'ESCALATING',
                        'target_strength': 8,
                        'priority': 'medium',
                        'expected_dramatic_impact': 'ØªØ¹Ø²ÙŠØ² Ø§Ù„ØªÙˆØªØ± Ø§Ù„Ø¯Ø±Ø§Ù…ÙŠ'
                    })
        
        # Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø¹Ø§Ù…Ø© Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª
        all_conflicts = list(self.network.conflicts.values())
        for conflict in all_conflicts[:3]:  # Ø£ÙˆÙ„ 3 ØµØ±Ø§Ø¹Ø§Øª
            if conflict.phase not in [ConflictPhase.CLIMAX, ConflictPhase.RESOLUTION]:
                strategies.append({
                    'conflict_id': conflict.id,
                    'conflict_name': conflict.name,
                    'current_status': 'active',
                    'enhancement_type': 'deepening',
                    'proposed_actions': [
                        'Ø¥Ø¶Ø§ÙØ© Ø·Ø¨Ù‚Ø© Ø±Ù…Ø²ÙŠØ© Ø£Ùˆ Ø«ÙŠÙ…Ø© Ø£Ø¹Ù…Ù‚ Ù„Ù„ØµØ±Ø§Ø¹',
                        'Ø±Ø¨Ø· Ø§Ù„ØµØ±Ø§Ø¹ Ø¨ØµØ±Ø§Ø¹Ø§Øª Ø£Ø®Ø±Ù‰ Ù„Ø®Ù„Ù‚ ØªØ¹Ù‚ÙŠØ¯',
                        'ØªØ·ÙˆÙŠØ± ØµØ±Ø§Ø¹ Ø¯Ø§Ø®Ù„ÙŠ Ù„ÙƒÙ„ Ø´Ø®ØµÙŠØ© Ù…Ø´Ø§Ø±ÙƒØ©',
                        'Ø¥Ø¶Ø§ÙØ© Ù†Ù‚Ø§Ø· ØªØ­ÙˆÙ„ ØµØºÙŠØ±Ø© Ù„Ø¥Ø¨Ù‚Ø§Ø¡ Ø§Ù„ØµØ±Ø§Ø¹ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ§Ù‹'
                    ],
                    'target_phase': self._suggest_next_phase(conflict.phase.name if hasattr(conflict.phase, 'name') else str(conflict.phase)),
                    'target_strength': min(conflict.strength + 2, 10),
                    'priority': 'low',
                    'expected_dramatic_impact': 'ØªØ¹Ù…ÙŠÙ‚ Ø§Ù„ØµØ±Ø§Ø¹ ÙˆØ¬Ø¹Ù„Ù‡ Ø£ÙƒØ«Ø± ØªØ£Ø«ÙŠØ±Ø§Ù‹'
                })
        
        return strategies
    
    def _create_consolidated_summary(self) -> str:
        """
        Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ø®Øµ Ù…ÙˆØ­Ø¯ Ù„Ø¬Ù…ÙŠØ¹ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø§Ù„Ø¹Ù„Ø§Ø¬
        
        Returns:
            Ù†Øµ Ø§Ù„Ù…Ù„Ø®Øµ
        """
        total_recommendations = (
            len(self.prioritized_actions) +
            len(self.quick_fixes) +
            len(self.structural_revisions) +
            len(self.character_suggestions) +
            len(self.conflict_strategies)
        )
        
        summary_parts = [
            "=" * 60,
            "Ù…Ù„Ø®Øµ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø§Ù„Ø¹Ù„Ø§Ø¬ Ø§Ù„Ù…ÙˆØ­Ø¯",
            "=" * 60,
            f"\nØ¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØªÙˆØµÙŠØ§Øª: {total_recommendations}",
            f"\n### Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø°Ø§Øª Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ© ({len(self.prioritized_actions)}):",
        ]
        
        # Ù…Ù„Ø®Øµ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø§Ù„Ø­Ø±Ø¬Ø©
        critical_actions = [a for a in self.prioritized_actions if a['priority'] == 'critical']
        high_actions = [a for a in self.prioritized_actions if a['priority'] == 'high']
        
        if critical_actions:
            summary_parts.append(f"  â€¢ Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø­Ø±Ø¬Ø©: {len(critical_actions)}")
        if high_actions:
            summary_parts.append(f"  â€¢ Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø¹Ø§Ù„ÙŠØ© Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ©: {len(high_actions)}")
        
        if self.quick_fixes:
            summary_parts.extend([
                f"\n### Ø§Ù„Ø¥ØµÙ„Ø§Ø­Ø§Øª Ø§Ù„Ø³Ø±ÙŠØ¹Ø© ({len(self.quick_fixes)}):",
                "  â€¢ ÙŠÙ…ÙƒÙ† ØªÙ†ÙÙŠØ°Ù‡Ø§ ÙÙˆØ±Ø§Ù‹ Ù„ØªØ­Ø³ÙŠÙ† Ø³Ø±ÙŠØ¹"
            ])
        
        if self.structural_revisions:
            summary_parts.extend([
                f"\n### Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø§Øª Ø§Ù„Ù‡ÙŠÙƒÙ„ÙŠØ© ({len(self.structural_revisions)}):",
                "  â€¢ ØªØºÙŠÙŠØ±Ø§Øª Ø¬ÙˆÙ‡Ø±ÙŠØ© Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø¨Ù†ÙŠØ©"
            ])
        
        if self.character_suggestions:
            summary_parts.extend([
                f"\n### ØªØ·ÙˆÙŠØ± Ø§Ù„Ø´Ø®ØµÙŠØ§Øª ({len(self.character_suggestions)}):",
                "  â€¢ Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª Ù„ØªØ¹Ù…ÙŠÙ‚ ÙˆØªØ­Ø³ÙŠÙ† Ø§Ù„Ø´Ø®ØµÙŠØ§Øª"
            ])
        
        if self.conflict_strategies:
            summary_parts.extend([
                f"\n### ØªØ¹Ø²ÙŠØ² Ø§Ù„ØµØ±Ø§Ø¹Ø§Øª ({len(self.conflict_strategies)}):",
                "  â€¢ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ù„ØªÙ‚ÙˆÙŠØ© Ø§Ù„Ø®Ø·ÙˆØ· Ø§Ù„Ø¯Ø±Ø§Ù…ÙŠØ©"
            ])
        
        summary_parts.extend([
            "\n" + "=" * 60,
            "Ø§Ù„ØªÙˆØµÙŠØ© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:",
            self._get_primary_recommendation(),
            "=" * 60
        ])
        
        return '\n'.join(summary_parts)
    
    def _create_implementation_roadmap(self) -> Dict[str, Any]:
        """
        Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø§Ø±Ø·Ø© Ø·Ø±ÙŠÙ‚ Ù„Ù„ØªÙ†ÙÙŠØ°
        
        Returns:
            Ø®Ø§Ø±Ø·Ø© Ø·Ø±ÙŠÙ‚ Ù…Ù†Ø¸Ù…Ø©
        """
        roadmap = {
            'phase_1_immediate': {
                'title': 'Ø§Ù„Ù…Ø±Ø­Ù„Ø© 1: Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª ÙÙˆØ±ÙŠØ© (1-3 Ø£ÙŠØ§Ù…)',
                'actions': [],
                'focus': 'Ø§Ù„Ø¥ØµÙ„Ø§Ø­Ø§Øª Ø§Ù„Ø³Ø±ÙŠØ¹Ø© ÙˆØ§Ù„Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„Ø­Ø±Ø¬Ø©'
            },
            'phase_2_short_term': {
                'title': 'Ø§Ù„Ù…Ø±Ø­Ù„Ø© 2: Ù‚ØµÙŠØ±Ø© Ø§Ù„Ø£Ù…Ø¯ (1-2 Ø£Ø³Ø§Ø¨ÙŠØ¹)',
                'actions': [],
                'focus': 'Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ù‡ÙŠÙƒÙ„ÙŠØ© ÙˆØ§Ù„Ø´Ø®ØµÙŠØ§Øª'
            },
            'phase_3_long_term': {
                'title': 'Ø§Ù„Ù…Ø±Ø­Ù„Ø© 3: Ø·ÙˆÙŠÙ„Ø© Ø§Ù„Ø£Ù…Ø¯ (2-4 Ø£Ø³Ø§Ø¨ÙŠØ¹)',
                'actions': [],
                'focus': 'Ø§Ù„ØªØ¹Ù…ÙŠÙ‚ ÙˆØ§Ù„ØµÙ‚Ù„ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ'
            }
        }
        
        # ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø±Ø§Ø­Ù„
        for action in self.prioritized_actions:
            if action['priority'] in ['critical', 'high']:
                roadmap['phase_1_immediate']['actions'].append(action['description'])
        
        for fix in self.quick_fixes:
            roadmap['phase_1_immediate']['actions'].append(fix['description'])
        
        for revision in self.structural_revisions:
            roadmap['phase_2_short_term']['actions'].append(revision['description'])
        
        for suggestion in self.character_suggestions:
            if suggestion['priority'] == 'high':
                roadmap['phase_2_short_term']['actions'].append(
                    f"ØªØ·ÙˆÙŠØ±: {suggestion['character_name']}"
                )
            else:
                roadmap['phase_3_long_term']['actions'].append(
                    f"ØªØ¹Ù…ÙŠÙ‚: {suggestion['character_name']}"
                )
        
        for strategy in self.conflict_strategies:
            if strategy['priority'] == 'high':
                roadmap['phase_2_short_term']['actions'].append(
                    f"Ø¥Ø­ÙŠØ§Ø¡: {strategy['conflict_name']}"
                )
            else:
                roadmap['phase_3_long_term']['actions'].append(
                    f"ØªØ¹Ø²ÙŠØ²: {strategy['conflict_name']}"
                )
        
        return roadmap
    
    def _map_severity_to_priority(self, severity: str) -> str:
        """
        ØªØ­ÙˆÙŠÙ„ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø®Ø·ÙˆØ±Ø© Ø¥Ù„Ù‰ Ø£ÙˆÙ„ÙˆÙŠØ©
        
        Args:
            severity: Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø®Ø·ÙˆØ±Ø©
            
        Returns:
            Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ©
        """
        mapping = {
            'critical': 'critical',
            'high': 'high',
            'medium': 'medium',
            'low': 'low'
        }
        return mapping.get(severity, 'low')
    
    def _estimate_effort(self, issue_type: str) -> str:
        """
        ØªÙ‚Ø¯ÙŠØ± Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø¬Ù‡Ø¯ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨
        
        Args:
            issue_type: Ù†ÙˆØ¹ Ø§Ù„Ù…Ø´ÙƒÙ„Ø©
            
        Returns:
            ØªÙ‚Ø¯ÙŠØ± Ø§Ù„Ø¬Ù‡Ø¯
        """
        effort_map = {
            'disconnected_components': 'high',
            'bottleneck_character': 'medium',
            'dead_end_conflict': 'medium',
            'completely_isolated': 'medium',
            'weakly_connected': 'low',
            'overload': 'high'
        }
        return effort_map.get(issue_type, 'medium')
    
    def _estimate_time(self, issue_type: str) -> str:
        """
        ØªÙ‚Ø¯ÙŠØ± Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨
        
        Args:
            issue_type: Ù†ÙˆØ¹ Ø§Ù„Ù…Ø´ÙƒÙ„Ø©
            
        Returns:
            ØªÙ‚Ø¯ÙŠØ± Ø§Ù„ÙˆÙ‚Øª
        """
        time_map = {
            'disconnected_components': '1-2 Ø£Ø³Ø§Ø¨ÙŠØ¹',
            'bottleneck_character': '3-5 Ø£ÙŠØ§Ù…',
            'dead_end_conflict': '2-4 Ø£ÙŠØ§Ù…',
            'completely_isolated': '2-4 Ø³Ø§Ø¹Ø§Øª',
            'weakly_connected': '1-2 Ø³Ø§Ø¹Ø©',
            'overload': '4-8 Ø³Ø§Ø¹Ø§Øª'
        }
        return time_map.get(issue_type, '2-4 Ø³Ø§Ø¹Ø§Øª')
    
    def _suggest_next_phase(self, current_phase: str) -> str:
        """
        Ø§Ù‚ØªØ±Ø§Ø­ Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„ØªØ§Ù„ÙŠØ© Ù„Ù„ØµØ±Ø§Ø¹
        
        Args:
            current_phase: Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
            
        Returns:
            Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ù…Ù‚ØªØ±Ø­Ø©
        """
        phase_progression = {
            'LATENT': 'EMERGING',
            'EMERGING': 'ESCALATING',
            'ESCALATING': 'CLIMAX',
            'STALEMATE': 'ESCALATING',
            'CLIMAX': 'DEESCALATING',
            'DEESCALATING': 'RESOLUTION',
            'RESOLUTION': 'AFTERMATH'
        }
        return phase_progression.get(current_phase, 'ESCALATING')
    
    def _get_primary_recommendation(self) -> str:
        """
        Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ØªÙˆØµÙŠØ© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
        
        Returns:
            Ù†Øµ Ø§Ù„ØªÙˆØµÙŠØ©
        """
        health_score = self.diagnostics_report.get('overall_health_score', 50)
        criticality = self.diagnostics_report.get('criticality_level', 'moderate_issues')
        
        if criticality == 'critical':
            return "Ø§Ù„Ø´Ø¨ÙƒØ© ØªØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ Ù…Ø±Ø§Ø¬Ø¹Ø© Ø´Ø§Ù…Ù„Ø© ÙÙˆØ±ÙŠØ©. Ø§Ø¨Ø¯Ø£ Ø¨Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø§Ù„Ø­Ø±Ø¬Ø© Ø«Ù… Ø§Ù„Ø¥ØµÙ„Ø§Ø­Ø§Øª Ø§Ù„Ø³Ø±ÙŠØ¹Ø©."
        elif criticality == 'major_issues':
            return "Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ø£ÙˆÙ„Ø§Ù‹ØŒ Ø«Ù… Ø§Ù„ØªØ±ÙƒÙŠØ² Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø§Øª Ø§Ù„Ù‡ÙŠÙƒÙ„ÙŠØ©."
        elif criticality == 'moderate_issues':
            return "Ø§Ù„Ø´Ø¨ÙƒØ© ÙÙŠ Ø­Ø§Ù„Ø© Ø¬ÙŠØ¯Ø©. Ø±ÙƒØ² Ø¹Ù„Ù‰ Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„ØªØ¯Ø±ÙŠØ¬ÙŠØ© ÙˆØ§Ù„ØµÙ‚Ù„."
        else:
            return "Ø§Ù„Ø´Ø¨ÙƒØ© ÙÙŠ Ø­Ø§Ù„Ø© Ù…Ù…ØªØ§Ø²Ø©. Ø§Ø³ØªÙ…Ø± ÙÙŠ Ø§Ù„ØªØ·ÙˆÙŠØ± ÙˆØ§Ù„ØªØ¹Ù…ÙŠÙ‚."


# Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø³Ø±ÙŠØ¹
def generate_treatments(
    network: ConflictNetwork,
    diagnostics_report: Optional[Dict[str, Any]] = None
) -> Dict[str, Any]:
    """
    Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„ØªÙˆÙ„ÙŠØ¯ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø§Ù„Ø¹Ù„Ø§Ø¬
    
    Args:
        network: Ø´Ø¨ÙƒØ© Ø§Ù„ØµØ±Ø§Ø¹
        diagnostics_report: ØªÙ‚Ø±ÙŠØ± Ø§Ù„ØªØ´Ø®ÙŠØµ (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)
        
    Returns:
        Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø§Ù„Ø¹Ù„Ø§Ø¬ Ø§Ù„Ø´Ø§Ù…Ù„Ø©
    """
    treatment = TreatmentStrategies(network, diagnostics_report)
    return treatment.analyze_and_recommend_treatments()

    