

Edit2 / 2السياق الهندسي لبناء نظام تحليل النصوص الدرامية
📋 نظرة عامة على المشروع
الهدف الاستراتيجي
بناء نظام متكامل لتحليل النصوص السردية والدرامية باستخدام TypeScript، يتكون من 7 محطات متسلسلة، كل منها متخصصة في جانب محدد من التحليل، مع ضمان استخدام نماذج Gemini 2.5 حصريًا.

🏗️ البنية المعمارية الشاملة
النمط المعماري: Pipeline Architecture
typescriptinterface PipelineStage<TInput, TOutput> {
  stageName: string;
  process(input: TInput): Promise<TOutput>;
  validate(output: TOutput): boolean;
}

// تدفق البيانات الأساسي
Text → S1 → S2 → S3 → S4 → S5 → S6 → S7 → Final Output
المبادئ المعمارية الأساسية

Single Responsibility Principle: كل محطة مسؤولة عن مهمة تحليلية واحدة فقط
Open/Closed Principle: المحطات مفتوحة للتوسع، مغلقة للتعديل
Dependency Inversion: الاعتماد على واجهات مجردة وليس تطبيقات محددة
Interface Segregation: واجهات صغيرة ومتخصصة لكل وحدة


🎯 المكونات الأساسية للنظام
1. طبقة النماذج الأساسية (Core Models Layer)
typescript// core/models/base-entities.ts

/**
 * الكيانات الأساسية المشتركة عبر جميع المحطات
 */

// تمثيل الشخصية
interface Character {
  id: string;
  name: string;
  description: string;
  profile: {
    personalityTraits: string;
    motivationsGoals: string;
    potentialArc: string;
  };
  metadata: Record<string, any>;
}

// تمثيل العلاقة
enum RelationshipType {
  LOVE = 'LOVE',
  RIVALRY = 'RIVALRY',
  ALLIANCE = 'ALLIANCE',
  FAMILY = 'FAMILY',
  MENTORSHIP = 'MENTORSHIP',
  ENMITY = 'ENMITY',
  OTHER = 'OTHER'
}

enum RelationshipNature {
  POSITIVE = 'POSITIVE',
  NEGATIVE = 'NEGATIVE',
  NEUTRAL = 'NEUTRAL',
  AMBIVALENT = 'AMBIVALENT',
  OTHER = 'OTHER'
}

enum RelationshipDirection {
  DIRECTED = 'DIRECTED',
  BIDIRECTIONAL = 'BIDIRECTIONAL'
}

interface Relationship {
  id: string;
  source: string; // Character ID
  target: string; // Character ID
  type: RelationshipType;
  nature: RelationshipNature;
  direction: RelationshipDirection;
  strength: number; // 1-10
  description: string;
  triggers: string[];
  metadata: Record<string, any>;
}

// تمثيل الصراع
enum ConflictSubject {
  VALUE = 'VALUE',
  MATERIAL = 'MATERIAL',
  POWER = 'POWER',
  PSYCHOLOGICAL = 'PSYCHOLOGICAL',
  RELATIONSHIP = 'RELATIONSHIP',
  INFORMATIONAL = 'INFORMATIONAL',
  SURVIVAL = 'SURVIVAL',
  OTHER = 'OTHER'
}

enum ConflictScope {
  INTERNAL = 'INTERNAL',
  PERSONAL = 'PERSONAL',
  GROUP = 'GROUP',
  SOCIETAL = 'SOCIETAL',
  UNIVERSAL = 'UNIVERSAL'
}

enum ConflictPhase {
  LATENT = 'LATENT',
  EMERGING = 'EMERGING',
  ESCALATING = 'ESCALATING',
  STALEMATE = 'STALEMATE',
  CLIMAX = 'CLIMAX',
  DEESCALATING = 'DEESCALATING',
  RESOLUTION = 'RESOLUTION',
  AFTERMATH = 'AFTERMATH',
  OTHER = 'OTHER'
}

interface Conflict {
  id: string;
  name: string;
  description: string;
  involvedCharacters: string[]; // Character IDs
  subject: ConflictSubject;
  scope: ConflictScope;
  phase: ConflictPhase;
  strength: number; // 1-10
  relatedRelationships: string[]; // Relationship IDs
  pivotPoints: string[];
  timestamps: Date[];
  metadata: Record<string, any>;
}

// شبكة الصراع
interface ConflictNetwork {
  id: string;
  name: string;
  characters: Map<string, Character>;
  relationships: Map<string, Relationship>;
  conflicts: Map<string, Conflict>;
  snapshots: NetworkSnapshot[];
  metadata: Record<string, any>;
  
  // Methods
  addCharacter(character: Character): void;
  addRelationship(relationship: Relationship): void;
  addConflict(conflict: Conflict): void;
  createSnapshot(description: string): void;
}

interface NetworkSnapshot {
  timestamp: Date;
  description: string;
  networkState: Partial<ConflictNetwork>;
}

2. طبقة خدمات الذكاء الاصطناعي (AI Services Layer)
typescript// services/ai/gemini-service.ts

/**
 * خدمة موحدة للتفاعل مع نماذج Gemini 2.5
 * ✅ الالتزام الصارم باستخدام gemini-2.5-pro و gemini-2.5-flash فقط
 */

enum GeminiModel {
  PRO = 'gemini-2.5-pro',
  FLASH = 'gemini-2.5-flash'
}

interface GeminiConfig {
  apiKey: string;
  defaultModel: GeminiModel;
  maxRetries: number;
  timeout: number;
  fallbackModel?: GeminiModel;
}

interface GeminiRequest {
  prompt: string;
  model: GeminiModel;
  context?: string;
  systemInstruction?: string;
  temperature?: number;
  maxTokens?: number;
}

interface GeminiResponse<T = any> {
  model: GeminiModel;
  content: T;
  usage: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
  metadata: {
    timestamp: Date;
    latency: number;
  };
}

class GeminiService {
  private config: GeminiConfig;
  
  constructor(config: GeminiConfig) {
    this.config = config;
    this.validateModels();
  }
  
  /**
   * التحقق من استخدام النماذج المطلوبة فقط
   */
  private validateModels(): void {
    const allowedModels = [GeminiModel.PRO, GeminiModel.FLASH];
    if (!allowedModels.includes(this.config.defaultModel)) {
      throw new Error(
        `Invalid model: ${this.config.defaultModel}. ` +
        `Only ${allowedModels.join(', ')} are allowed.`
      );
    }
  }
  
  /**
   * إرسال طلب إلى Gemini مع إدارة الأخطاء
   */
  async generate<T>(request: GeminiRequest): Promise<GeminiResponse<T>> {
    this.validateModels(); // تأكيد إضافي
    
    try {
      const startTime = Date.now();
      
      // استدعاء API الفعلي
      const response = await this.callGeminiAPI(request);
      
      return {
        model: request.model,
        content: this.parseResponse<T>(response),
        usage: this.extractUsage(response),
        metadata: {
          timestamp: new Date(),
          latency: Date.now() - startTime
        }
      };
    } catch (error) {
      return this.handleError(error, request);
    }
  }
  
  /**
   * استدعاء متعدد للنماذج مع نظام الأولويات
   */
  async generateMultiModel<T>(
    request: GeminiRequest,
    models: GeminiModel[] = [GeminiModel.PRO, GeminiModel.FLASH]
  ): Promise<Map<GeminiModel, GeminiResponse<T>>> {
    const results = new Map<GeminiModel, GeminiResponse<T>>();
    
    for (const model of models) {
      try {
        const response = await this.generate<T>({
          ...request,
          model
        });
        results.set(model, response);
      } catch (error) {
        console.error(`Model ${model} failed:`, error);
      }
    }
    
    return results;
  }
  
  private async callGeminiAPI(request: GeminiRequest): Promise<any> {
    // التطبيق الفعلي لاستدعاء Google AI API
    // باستخدام @google/generative-ai
  }
  
  private parseResponse<T>(response: any): T {
    // استخراج وتحليل JSON من الاستجابة
  }
  
  private extractUsage(response: any) {
    // استخراج معلومات الاستخدام
  }
  
  private async handleError(
    error: any,
    request: GeminiRequest
  ): Promise<GeminiResponse<any>> {
    // منطق إعادة المحاولة والتراجع
  }
}

3. طبقة اختيار النتائج (Result Selection Layer)
typescript// services/ai/result-selector.ts

/**
 * نظام ذكي لاختيار أفضل النتائج من استدعاءات متعددة للنماذج
 */

interface SelectionCriteria {
  preferredModels: GeminiModel[];
  validationFunction?: (result: any) => boolean;
  scoreFunction?: (result: any) => number;
}

class AIResultSelector {
  /**
   * اختيار أفضل نتيجة بناءً على الأولويات والمعايير
   */
  selectBest<T>(
    results: Map<GeminiModel, GeminiResponse<T>>,
    criteria: SelectionCriteria
  ): GeminiResponse<T> | null {
    // 1. فلترة النتائج الصالحة
    const validResults = this.filterValid(results, criteria);
    
    if (validResults.size === 0) {
      return null;
    }
    
    // 2. اختيار من النماذج المفضلة أولاً
    for (const model of criteria.preferredModels) {
      if (validResults.has(model)) {
        return validResults.get(model)!;
      }
    }
    
    // 3. اختيار بناءً على التقييم
    if (criteria.scoreFunction) {
      return this.selectByScore(validResults, criteria.scoreFunction);
    }
    
    // 4. إرجاع أول نتيجة صالحة
    return Array.from(validResults.values())[0];
  }
  
  private filterValid<T>(
    results: Map<GeminiModel, GeminiResponse<T>>,
    criteria: SelectionCriteria
  ): Map<GeminiModel, GeminiResponse<T>> {
    const filtered = new Map<GeminiModel, GeminiResponse<T>>();
    
    for (const [model, response] of results) {
      if (!criteria.validationFunction || 
          criteria.validationFunction(response.content)) {
        filtered.set(model, response);
      }
    }
    
    return filtered;
  }
  
  private selectByScore<T>(
    results: Map<GeminiModel, GeminiResponse<T>>,
    scoreFunction: (result: any) => number
  ): GeminiResponse<T> {
    let bestScore = -Infinity;
    let bestResult: GeminiResponse<T> | null = null;
    
    for (const response of results.values()) {
      const score = scoreFunction(response.content);
      if (score > bestScore) {
        bestScore = score;
        bestResult = response;
      }
    }
    
    return bestResult!;
  }
}

🚂 تصميم المحطات السبع
البنية الأساسية للمحطة
typescript// core/pipeline/base-station.ts

/**
 * الفئة الأساسية المجردة لجميع المحطات
 */

interface StationConfig {
  stationNumber: number;
  stationName: string;
  inputValidation: (input: any) => boolean;
  outputValidation: (output: any) => boolean;
  cacheEnabled: boolean;
  performanceTracking: boolean;
}

interface StationMetadata {
  executionTime: number;
  timestamp: Date;
  modelUsed: GeminiModel;
  cacheHit: boolean;
  errorOccurred: boolean;
  errorDetails?: string;
}

abstract class BaseStation<TInput, TOutput> {
  protected config: StationConfig;
  protected geminiService: GeminiService;
  protected resultSelector: AIResultSelector;
  protected cache: Map<string, TOutput>;
  
  constructor(
    config: StationConfig,
    geminiService: GeminiService,
    resultSelector: AIResultSelector
  ) {
    this.config = config;
    this.geminiService = geminiService;
    this.resultSelector = resultSelector;
    this.cache = new Map();
  }
  
  /**
   * الدالة الرئيسية لتنفيذ المحطة
   */
  async execute(input: TInput): Promise<{
    output: TOutput;
    metadata: StationMetadata;
  }> {
    const startTime = Date.now();
    
    try {
      // 1. التحقق من صحة المدخلات
      this.validateInput(input);
      
      // 2. التحقق من الذاكرة المؤقتة
      const cachedResult = this.checkCache(input);
      if (cachedResult) {
        return {
          output: cachedResult,
          metadata: this.createMetadata(startTime, true)
        };
      }
      
      // 3. تنفيذ المعالجة الفعلية
      const output = await this.process(input);
      
      // 4. التحقق من صحة المخرجات
      this.validateOutput(output);
      
      // 5. حفظ في الذاكرة المؤقتة
      this.saveToCache(input, output);
      
      return {
        output,
        metadata: this.createMetadata(startTime, false)
      };
      
    } catch (error) {
      return this.handleError(error, startTime);
    }
  }
  
  /**
   * المعالجة الفعلية - يجب تنفيذها في كل محطة
   */
  protected abstract process(input: TInput): Promise<TOutput>;
  
  /**
   * استخراج البيانات المطلوبة من المحطات السابقة
   */
  protected abstract extractRequiredData(input: TInput): any;
  
  protected validateInput(input: TInput): void {
    if (!this.config.inputValidation(input)) {
      throw new Error(
        `Invalid input for ${this.config.stationName}`
      );
    }
  }
  
  protected validateOutput(output: TOutput): void {
    if (!this.config.outputValidation(output)) {
      throw new Error(
        `Invalid output from ${this.config.stationName}`
      );
    }
  }
  
  protected checkCache(input: TInput): TOutput | null {
    if (!this.config.cacheEnabled) return null;
    
    const cacheKey = this.generateCacheKey(input);
    return this.cache.get(cacheKey) || null;
  }
  
  protected saveToCache(input: TInput, output: TOutput): void {
    if (!this.config.cacheEnabled) return;
    
    const cacheKey = this.generateCacheKey(input);
    this.cache.set(cacheKey, output);
  }
  
  protected generateCacheKey(input: TInput): string {
    return JSON.stringify(input);
  }
  
  protected createMetadata(
    startTime: number,
    cacheHit: boolean
  ): StationMetadata {
    return {
      executionTime: Date.now() - startTime,
      timestamp: new Date(),
      modelUsed: GeminiModel.PRO, // سيتم تحديثه بناءً على النموذج المستخدم
      cacheHit,
      errorOccurred: false
    };
  }
  
  protected handleError(error: any, startTime: number): any {
    console.error(
      `Error in ${this.config.stationName}:`,
      error
    );
    
    return {
      output: this.getErrorFallback(),
      metadata: {
        ...this.createMetadata(startTime, false),
        errorOccurred: true,
        errorDetails: error.message
      }
    };
  }
  
  protected abstract getErrorFallback(): TOutput;
}

المحطة الأولى: تحليل النص الأساسي
typescript// stations/station1/station1-text-analysis.ts

interface Station1Input {
  fullText: string;
  projectName: string;
  proseFilePath: string;
}

interface Station1Output {
  majorCharacters: string[];
  characterAnalysis: Map<string, CharacterAnalysisResult>;
  relationshipAnalysis: RelationshipAnalysisResult;
  narrativeStyleAnalysis: NarrativeStyleResult;
  metadata: {
    analysisTimestamp: Date;
    status: 'Success' | 'Partial' | 'Failed';
  };
}

interface CharacterAnalysisResult {
  personalityTraits: string;
  motivationsGoals: string;
  keyRelationshipsBrief: string;
  narrativeFunction: string;
  potentialArcObservation: string;
}

interface RelationshipAnalysisResult {
  keyRelationships: Array<{
    characters: [string, string];
    dynamic: string;
    narrativeImportance: string;
  }>;
}

interface NarrativeStyleResult {
  overallTone: string;
  pacingAnalysis: string;
  languageStyle: string;
}

class Station1TextAnalysis extends BaseStation<Station1Input, Station1Output> {
  
  protected async process(input: Station1Input): Promise<Station1Output> {
    // تنفيذ متوازي لجميع التحليلات
    const [
      majorCharacters,
      relationshipAnalysis,
      narrativeStyle
    ] = await Promise.all([
      this.identifyMajorCharacters(input.fullText),
      this.analyzeRelationships(input.fullText),
      this.analyzeNarrativeStyle(input.fullText)
    ]);
    
    // تحليل معمق للشخصيات الرئيسية
    const characterAnalysis = await this.analyzeCharactersInDepth(
      input.fullText,
      majorCharacters
    );
    
    return {
      majorCharacters,
      characterAnalysis,
      relationshipAnalysis,
      narrativeStyleAnalysis: narrativeStyle,
      metadata: {
        analysisTimestamp: new Date(),
        status: 'Success'
      }
    };
  }
  
  /**
   * تحديد الشخصيات الرئيسية (3-7 شخصيات)
   */
  private async identifyMajorCharacters(
    fullText: string
  ): Promise<string[]> {
    const prompt = `
بناءً على النص السردي الكامل المرفق، قم بتحليل النص وتحديد الشخصيات التي تبدو **الأكثر مركزية وأهمية** للحبكة وتطور الأحداث. 
ركز على الشخصيات التي لها أدوار فاعلة، دوافع واضحة، وتظهر بشكل متكرر ومؤثر.
أعد قائمة تتضمن **ما بين 3 إلى 7 شخصيات** تعتبرها الأكثر أهمية.

أعد الإجابة **حصرياً** بتنسيق JSON صالح:
{
  "major_characters": ["اسم الشخصية 1", "اسم الشخصية 2", ...]
}
    `;
    
    const results = await this.geminiService.generateMultiModel<{
      major_characters: string[];
    }>({
      prompt,
      context: fullText.substring(0, 30000),
      model: GeminiModel.PRO
    }, [GeminiModel.PRO, GeminiModel.FLASH]);
    
    const selected = this.resultSelector.selectBest(results, {
      preferredModels: [GeminiModel.PRO, GeminiModel.FLASH],
      validationFunction: (result) => 
        Array.isArray(result.major_characters) && 
        result.major_characters.length >= 3 &&
        result.major_characters.length <= 7
    });
    
    return selected?.content.major_characters || [];
  }
  
  /**
   * تحليل معمق لكل شخصية رئيسية
   */
  private async analyzeCharactersInDepth(
    fullText: string,
    characterNames: string[]
  ): Promise<Map<string, CharacterAnalysisResult>> {
    const analyses = new Map<string, CharacterAnalysisResult>();
    
    // تحليل متوازي للشخصيات
    const analysisPromises = characterNames.map(name =>
      this.analyzeCharacter(fullText, name)
    );
    
    const results = await Promise.all(analysisPromises);
    
    characterNames.forEach((name, index) => {
      analyses.set(name, results[index]);
    });
    
    return analyses;
  }
  
  private async analyzeCharacter(
    fullText: string,
    characterName: string
  ): Promise<CharacterAnalysisResult> {
    const prompt = `
بناءً على النص السردي الكامل المرفق، قم بإجراء تحليل **شامل ومعمق** للشخصية المحددة التالية: **${characterName}**.

المطلوب تحليل الجوانب التالية لهذه الشخصية:
1. السمات الشخصية البارزة (إيجابية وسلبية)
2. الدوافع الأساسية والأهداف (الظاهرة والخفية)
3. وصف موجز لأهم علاقاتها مع شخصيات أخرى
4. الدور أو الوظيفة الرئيسية في القصة
5. ملاحظات أولية حول قوس التطور المحتمل

أعد الإجابة **حصرياً** بتنسيق JSON صالح:
{
  "personality_traits": "...",
  "motivations_goals": "...",
  "key_relationships_brief": "...",
  "narrative_function": "...",
  "potential_arc_observation": "..."
}
    `;
    
    const results = await this.geminiService.generateMultiModel({
      prompt,
      context: fullText.substring(0, 30000),
      model: GeminiModel.PRO
    });
    
    const selected = this.resultSelector.selectBest(results, {
      preferredModels: [GeminiModel.PRO, GeminiModel.FLASH],
      validationFunction: (result) => 
        result.personality_traits &&
        result.motivations_goals &&
        result.narrative_function
    });
    
    const content = selected?.content || {};
    
    return {
      personalityTraits: content.personality_traits || 'N/A',
      motivationsGoals: content.motivations_goals || 'N/A',
      keyRelationshipsBrief: content.key_relationships_brief || 'N/A',
      narrativeFunction: content.narrative_function || 'N/A',
      potentialArcObservation: content.potential_arc_observation || 'N/A'
    };
  }
  
  private async analyzeRelationships(
    fullText: string
  ): Promise<RelationshipAnalysisResult> {
    // تطبيق مشابه لتحليل العلاقات
    // ...
  }
  
  private async analyzeNarrativeStyle(
    fullText: string
  ): Promise<NarrativeStyleResult> {
    // تطبيق مشابه لتحليل الأسلوب السردي
    // ...
  }
  
  protected extractRequiredData(input: Station1Input): any {
    return { fullText: input.fullText };
  }
  
  protected getErrorFallback(): Station1Output {
    return {
      majorCharacters: [],
      characterAnalysis: new Map(),
      relationshipAnalysis: { keyRelationships: [] },
      narrativeStyleAnalysis: {
        overallTone: 'Error',
        pacingAnalysis: 'Error',
        languageStyle: 'Error'
      },
      metadata: {
        analysisTimestamp: new Date(),
        status: 'Failed'
      }
    };
  }
}

المحطة الثانية: التحليل المفاهيمي
typescript// stations/station2/station2-conceptual-analysis.ts

interface Station2Input {
  station1Output: Station1Output;
  fullText: string;
}

interface Station2Output {
  storyStatement: string;
  threeDMap: ThreeDMapResult;
  elevatorPitch: string;
  hybridGenre: string;
  genreContributionMatrix: GenreMatrixResult;
  dynamicTone: DynamicToneResult;
  artisticReferences: ArtisticReferencesResult;
  metadata: {
    analysisTimestamp: Date;
    status: 'Success' | 'Partial' | 'Failed';
  };
}

interface ThreeDMapResult {
  horizontalEventsAxis: Array<{
    event: string;
    sceneRef: string;
  }>;
  verticalMeaningAxis: Array<{
    eventRef: string;
    symbolicLayer: string;
  }>;
  temporalDevelopmentAxis: {
    pastInfluence: string;
    presentChoices: string;
    futureExpectations: string;
    heroArcConnection: string;
  };
}

interface GenreMatrixResult {
  [genreName: string]: {
    conflictContribution: string;
    pacingContribution: string;
    visualCompositionContribution: string;
    soundMusicContribution: string;
    charactersContribution: string;
  };
}

interface DynamicToneResult {
  [stageName: string]: {
    visualAtmosphereDescribed: string;
    writtenPacing: string;
    dialogueStructure: string;
    soundIndicationsDescribed: string;
  };
}

interface ArtisticReferencesResult {
  visualReferences: Array<{
    work: string;
    reason: string;
  }>;
  musicalMood: string;
}

class Station2ConceptualAnalysis extends BaseStation<Station2Input, Station2Output> {
  
  protected async process(input: Station2Input): Promise<Station2Output> {
    // بناء السياق من المحطة الأولى
    const context = this.buildContextFromStation1(input.station1Output);
    
    // 1. توليد بيانات القصة
    const storyStatements = await this.generateStoryStatements(
      context,
      input.fullText
    );
    const storyStatement = storyStatements[0]; // اختيار الأول
    
    // 2. بناء الخريطة ثلاثية الأبعاد
    const threeDMap = await this.generate3DMap(
      context,
      storyStatement,
      input.fullText
    );
    
    // 3. توليد العرض المختصر
    const elevatorPitch = await this.generateElevatorPitch(
      storyStatement
    );
    
    // 4. تحديد النوع الهجين
    const hybridGenreOptions = await this.generateHybridGenre(
      context,
      storyStatement,
      input.fullText
    );
    const hybridGenre = hybridGenreOptions[0];
    
    // 5. بناء مصفوفة مساهمة النوع
    const genreMatrix = await this.generateGenreMatrix(
      hybridGenre,
      context,
      input.fullText
    );
    
    // 6. تحديد النغمة الديناميكية
    const dynamicTone = await this.generateDynamicTone(
      hybridGenre,
      context,
      input.fullText
    );
    
    // 7. المراجع الفنية
    const artisticReferences = await this.generateArtisticReferences(
      hybridGenre,
      context,
      input.fullText
    );
    
    return {
      storyStatement,
      threeDMap,
      elevatorPitch,
      hybridGenre,
      genreContributionMatrix: genreMatrix,
      dynamicTone,
      artisticReferences,
      metadata: {
        analysisTimestamp: new Date(),
        status: 'Success'
      }
    };
  }
  
  private buildContextFromStation1(s1Output: Station1Output): any {
    return {
      majorCharacters: s1Output.majorCharacters,
      characterProfiles: Array.from(
        s1Output.characterAnalysis.entries()
      ).map(([name, analysis]) => ({
        name,
        traits: analysis.personalityTraits,
        motivations: analysis.motivationsGoals
      })),
      keyRelationships: s1Output.relationshipAnalysis.keyRelationships,
      narrativeStyle: s1Output.narrativeStyleAnalysis
    };
  }RetryAContinueEdittypescript  /**
   * توليد 3 بدائل لبيان القصة
   */
  private async generateStoryStatements(
    context: any,
    fullText: string
  ): Promise<string[]> {
    const prompt = `
بصفتك مساعد كتابة سيناريو خبير، ومستندًا إلى ملخص السيناريو الأولي والنص الكامل المرفقين، 
اقترح **ثلاثة (3)** بدائل متميزة لـ "بيان القصة" (Story Statement).

كل بيان يجب أن يتكون من **أربع جمل**، تغطي:
1. الحدث المحوري الجامع أو نقطة الانطلاق
2. الصراعات المتشابكة أو الدوافع المتقاطعة
3. العالم القصصي المميز والموحد
4. الثيمة أو السؤال الفلسفي الجامع

السياق: ${JSON.stringify(context, null, 2)}

أعد الإجابة **حصرياً** بتنسيق JSON:
{
  "story_statement_alternatives": [
    "بيان القصة الأول (4 جمل)...",
    "بيان القصة الثاني (4 جمل)...",
    "بيان القصة الثالث (4 جمل)..."
  ]
}
    `;
    
    const results = await this.geminiService.generateMultiModel<{
      story_statement_alternatives: string[];
    }>({
      prompt,
      context: fullText.substring(0, 25000),
      model: GeminiModel.PRO,
      temperature: 0.8
    });
    
    const selected = this.resultSelector.selectBest(results, {
      preferredModels: [GeminiModel.PRO, GeminiModel.FLASH],
      validationFunction: (result) => 
        Array.isArray(result.story_statement_alternatives) &&
        result.story_statement_alternatives.length === 3
    });
    
    return selected?.content.story_statement_alternatives || 
      ['فشل توليد بيان القصة'];
  }
  
  /**
   * بناء الخريطة ثلاثية الأبعاد
   */
  private async generate3DMap(
    context: any,
    storyStatement: string,
    fullText: string
  ): Promise<ThreeDMapResult> {
    const prompt = `
بناءً على بيان القصة المعتمد: "${storyStatement}"
والسياق: ${JSON.stringify(context, null, 2)}

قم بإنشاء **"خريطة ثلاثية الأبعاد" (3D Map)** للقصة:

أعد النتائج بتنسيق JSON:
{
  "horizontal_events_axis": [
    {"event": "حدث مختصر", "scene_ref": "رقم المشهد"},
    ...
  ],
  "vertical_meaning_axis": [
    {"event_ref": "وصف الحدث", "symbolic_layer": "الطبقة الرمزية"},
    ...
  ],
  "temporal_development_axis": {
    "past_influence": "تأثير الماضي...",
    "present_choices": "خيارات الحاضر...",
    "future_expectations": "توقعات المستقبل...",
    "hero_arc_connection": "ارتباط بقوس البطل..."
  }
}
    `;
    
    const results = await this.geminiService.generateMultiModel<ThreeDMapResult>({
      prompt,
      context: fullText.substring(0, 25000),
      model: GeminiModel.PRO,
      temperature: 0.7
    });
    
    const selected = this.resultSelector.selectBest(results, {
      preferredModels: [GeminiModel.PRO, GeminiModel.FLASH],
      validationFunction: (result) => 
        result.horizontal_events_axis &&
        result.vertical_meaning_axis &&
        result.temporal_development_axis
    });
    
    return selected?.content || this.getDefault3DMap();
  }
  
  private async generateElevatorPitch(
    storyStatement: string
  ): Promise<string> {
    const prompt = `
بناءً على بيان القصة: "${storyStatement}"

صغ "Elevator Pitch" جذاب وموجز (لا يتجاوز 40 كلمة).

أعد الإجابة بتنسيق JSON:
{
  "elevator_pitch": "النص هنا..."
}
    `;
    
    const results = await this.geminiService.generateMultiModel<{
      elevator_pitch: string;
    }>({
      prompt,
      model: GeminiModel.FLASH, // استخدام FLASH للمهام الأبسط
      temperature: 0.9
    });
    
    const selected = this.resultSelector.selectBest(results, {
      preferredModels: [GeminiModel.FLASH, GeminiModel.PRO],
      validationFunction: (result) => 
        result.elevator_pitch &&
        result.elevator_pitch.split(' ').length <= 45
    });
    
    return selected?.content.elevator_pitch || 
      'فشل توليد العرض المختصر';
  }
  
  private async generateHybridGenre(
    context: any,
    storyStatement: string,
    fullText: string
  ): Promise<string[]> {
    const prompt = `
بناءً على السياق والنص الكامل، اقترح **ما بين 3 إلى 5 بدائل** 
لتركيبة **"نوع هجين" (Hybrid Genre)** دقيقة ومناسبة.

السياق: ${JSON.stringify(context, null, 2)}
بيان القصة: ${storyStatement}

أعد الإجابة بتنسيق JSON:
{
  "hybrid_genre_alternatives": [
    "النوع الهجين الأول مع الشرح...",
    "النوع الهجين الثاني مع الشرح...",
    ...
  ]
}
    `;
    
    const results = await this.geminiService.generateMultiModel<{
      hybrid_genre_alternatives: string[];
    }>({
      prompt,
      context: fullText.substring(0, 20000),
      model: GeminiModel.PRO,
      temperature: 0.8
    });
    
    const selected = this.resultSelector.selectBest(results, {
      preferredModels: [GeminiModel.PRO, GeminiModel.FLASH],
      validationFunction: (result) => 
        Array.isArray(result.hybrid_genre_alternatives) &&
        result.hybrid_genre_alternatives.length >= 3 &&
        result.hybrid_genre_alternatives.length <= 5
    });
    
    return selected?.content.hybrid_genre_alternatives || 
      ['Drama-Thriller'];
  }
  
  private async generateGenreMatrix(
    hybridGenre: string,
    context: any,
    fullText: string
  ): Promise<GenreMatrixResult> {
    const prompt = `
بناءً على النوع الهجين المعتمد: "${hybridGenre}"

أنشئ **"مصفوفة مساهمة النوع"** توضح كيف يُثري كل نوع أساسي:

أعد النتائج بتنسيق JSON:
{
  "genre_contribution_matrix": {
    "النوع الأول": {
      "conflict_contribution": "...",
      "pacing_contribution": "...",
      "visual_composition_contribution": "...",
      "sound_music_contribution": "...",
      "characters_contribution": "..."
    },
    ...
  }
}
    `;
    
    const results = await this.geminiService.generateMultiModel<{
      genre_contribution_matrix: GenreMatrixResult;
    }>({
      prompt,
      context: fullText.substring(0, 15000),
      model: GeminiModel.PRO,
      temperature: 0.7
    });
    
    const selected = this.resultSelector.selectBest(results, {
      preferredModels: [GeminiModel.PRO, GeminiModel.FLASH],
      validationFunction: (result) => 
        result.genre_contribution_matrix &&
        Object.keys(result.genre_contribution_matrix).length > 0
    });
    
    return selected?.content.genre_contribution_matrix || {};
  }
  
  private async generateDynamicTone(
    hybridGenre: string,
    context: any,
    fullText: string
  ): Promise<DynamicToneResult> {
    // تطبيق مشابه
    // ...
  }
  
  private async generateArtisticReferences(
    hybridGenre: string,
    context: any,
    fullText: string
  ): Promise<ArtisticReferencesResult> {
    // تطبيق مشابه
    // ...
  }
  
  private getDefault3DMap(): ThreeDMapResult {
    return {
      horizontalEventsAxis: [],
      verticalMeaningAxis: [],
      temporalDevelopmentAxis: {
        pastInfluence: '',
        presentChoices: '',
        futureExpectations: '',
        heroArcConnection: ''
      }
    };
  }
  
  protected extractRequiredData(input: Station2Input): any {
    return {
      station1: input.station1Output,
      fullText: input.fullText
    };
  }
  
  protected getErrorFallback(): Station2Output {
    return {
      storyStatement: 'Error',
      threeDMap: this.getDefault3DMap(),
      elevatorPitch: 'Error',
      hybridGenre: 'Error',
      genreContributionMatrix: {},
      dynamicTone: {},
      artisticReferences: {
        visualReferences: [],
        musicalMood: ''
      },
      metadata: {
        analysisTimestamp: new Date(),
        status: 'Failed'
      }
    };
  }
}

المحطة الثالثة: بناء شبكة الصراع
typescript// stations/station3/station3-network-builder.ts

interface Station3Input {
  station1Output: Station1Output;
  station2Output: Station2Output;
  fullText: string;
}

interface Station3Output {
  conflictNetwork: ConflictNetwork;
  networkSummary: {
    charactersCount: number;
    relationshipsCount: number;
    conflictsCount: number;
    snapshotsCount: number;
  };
  metadata: {
    analysisTimestamp: Date;
    status: 'Success' | 'Partial' | 'Failed';
    buildTime: number;
  };
}

/**
 * محرك استدلال العلاقات
 */
class RelationshipInferenceEngine {
  constructor(
    private geminiService: GeminiService,
    private resultSelector: AIResultSelector
  ) {}
  
  async inferRelationships(
    characters: Character[],
    s1RelationshipsHints: any,
    s2Context: any,
    fullText: string
  ): Promise<Relationship[]> {
    const charactersList = characters.map(c => 
      `'${c.name}' (ID: ${c.id})`
    ).join(', ');
    
    const prompt = `
استنادًا إلى السياق المقدم، قم باستنتاج العلاقات الرئيسية بين الشخصيات.

الشخصيات المتاحة: ${charactersList}

لكل علاقة رئيسية:
1. حدد الشخصيتين (بالاسم أو ID)
2. اقترح نوع العلاقة (${Object.values(RelationshipType).join(', ')})
3. اقترح طبيعة العلاقة (${Object.values(RelationshipNature).join(', ')})
4. وصف موجز للعلاقة
5. قوة العلاقة (1-10)
6. اتجاه العلاقة (${Object.values(RelationshipDirection).join(', ')})
7. المحفزات المؤثرة

أعد الإجابة بتنسيق JSON:
{
  "inferred_relationships": [
    {
      "character1_name_or_id": "...",
      "character2_name_or_id": "...",
      "relationship_type": "...",
      "relationship_nature": "...",
      "description_rationale": "...",
      "strength": 7,
      "direction": "...",
      "triggers": ["محفز 1", "محفز 2"]
    },
    ...
  ]
}
    `;
    
    const results = await this.geminiService.generateMultiModel<{
      inferred_relationships: any[];
    }>({
      prompt,
      context: fullText.substring(0, 25000),
      model: GeminiModel.PRO,
      temperature: 0.7
    });
    
    const selected = this.resultSelector.selectBest(results, {
      preferredModels: [GeminiModel.PRO, GeminiModel.FLASH],
      validationFunction: (result) => 
        Array.isArray(result.inferred_relationships) &&
        result.inferred_relationships.length > 0
    });
    
    const inferredData = selected?.content.inferred_relationships || [];
    
    return this.convertToRelationships(inferredData, characters);
  }
  
  private convertToRelationships(
    inferredData: any[],
    characters: Character[]
  ): Relationship[] {
    const relationships: Relationship[] = [];
    const charNameToId = new Map(
      characters.map(c => [c.name, c.id])
    );
    
    for (const data of inferredData) {
      const sourceId = charNameToId.get(data.character1_name_or_id) || 
                      data.character1_name_or_id;
      const targetId = charNameToId.get(data.character2_name_or_id) || 
                      data.character2_name_or_id;
      
      if (!sourceId || !targetId || sourceId === targetId) {
        continue;
      }
      
      try {
        const relationship: Relationship = {
          id: `rel_${sourceId}_${targetId}_${Date.now()}`,
          source: sourceId,
          target: targetId,
          type: this.parseRelationshipType(data.relationship_type),
          nature: this.parseRelationshipNature(data.relationship_nature),
          direction: this.parseRelationshipDirection(data.direction),
          strength: parseInt(data.strength) || 5,
          description: data.description_rationale || '',
          triggers: data.triggers || [],
          metadata: {
            source: 'AI_Inference_Engine',
            inferenceTimestamp: new Date().toISOString()
          }
        };
        
        relationships.push(relationship);
      } catch (error) {
        console.error('Error parsing relationship:', error);
      }
    }
    
    return relationships;
  }
  
  private parseRelationshipType(typeStr: string): RelationshipType {
    const normalized = typeStr?.toUpperCase().replace(/[- ]/g, '_');
    return RelationshipType[normalized as keyof typeof RelationshipType] || 
           RelationshipType.OTHER;
  }
  
  private parseRelationshipNature(natureStr: string): RelationshipNature {
    const normalized = natureStr?.toUpperCase().replace(/[- ]/g, '_');
    return RelationshipNature[normalized as keyof typeof RelationshipNature] || 
           RelationshipNature.NEUTRAL;
  }
  
  private parseRelationshipDirection(dirStr: string): RelationshipDirection {
    const normalized = dirStr?.toUpperCase().replace(/[- ]/g, '_');
    return RelationshipDirection[normalized as keyof typeof RelationshipDirection] || 
           RelationshipDirection.BIDIRECTIONAL;
  }
}

/**
 * محرك استدلال الصراعات
 */
class ConflictInferenceEngine {
  constructor(
    private geminiService: GeminiService,
    private resultSelector: AIResultSelector
  ) {}
  
  async inferConflicts(
    characters: Character[],
    relationships: Relationship[],
    s2Context: any,
    fullText: string
  ): Promise<Conflict[]> {
    const charactersSummary = characters.map(c => ({
      id: c.id,
      name: c.name,
      description: c.description
    }));
    
    const relationshipsSummary = relationships.slice(0, 5).map(r => {
      const source = characters.find(c => c.id === r.source);
      const target = characters.find(c => c.id === r.target);
      return {
        characters: [source?.name, target?.name],
        type: r.type,
        nature: r.nature
      };
    });
    
    const prompt = `
استنادًا إلى السياق، قم باستنتاج الصراعات الرئيسية (3-5 صراعات).

الشخصيات: ${JSON.stringify(charactersSummary, null, 2)}
العلاقات: ${JSON.stringify(relationshipsSummary, null, 2)}

لكل صراع:
1. اسم الصراع
2. الشخصيات المشاركة (أسماء أو IDs)
3. موضوع الصراع (${Object.values(ConflictSubject).join(', ')})
4. نطاق الصراع (${Object.values(ConflictScope).join(', ')})
5. المرحلة الأولية (${Object.values(ConflictPhase).join(', ')})
6. وصف ودليل
7. قوة الصراع (1-10)
8. نقاط التحول المحورية

أعد الإجابة بتنسيق JSON:
{
  "inferred_conflicts": [
    {
      "conflict_name": "...",
      "involved_character_names_or_ids": ["...", "..."],
      "subject": "...",
      "scope": "...",
      "initial_phase": "...",
      "description_rationale": "...",
      "strength": 8,
      "related_relationships": [],
      "pivot_points": ["نقطة 1", "نقطة 2"]
    },
    ...
  ]
}
    `;
    
    const results = await this.geminiService.generateMultiModel<{
      inferred_conflicts: any[];
    }>({
      prompt,
      context: fullText.substring(0, 25000),
      model: GeminiModel.PRO,
      temperature: 0.7
    });
    
    const selected = this.resultSelector.selectBest(results, {
      preferredModels: [GeminiModel.PRO, GeminiModel.FLASH],
      validationFunction: (result) => 
        Array.isArray(result.inferred_conflicts) &&
        result.inferred_conflicts.length > 0 &&
        result.inferred_conflicts.length <= 5
    });
    
    const inferredData = selected?.content.inferred_conflicts || [];
    
    return this.convertToConflicts(inferredData, characters);
  }
  
  private convertToConflicts(
    inferredData: any[],
    characters: Character[]
  ): Conflict[] {
    const conflicts: Conflict[] = [];
    const charNameToId = new Map(
      characters.map(c => [c.name, c.id])
    );
    
    for (const data of inferredData) {
      const involvedIds = (data.involved_character_names_or_ids || [])
        .map((ref: string) => charNameToId.get(ref) || ref)
        .filter((id: string) => id);
      
      if (involvedIds.length === 0) {
        continue;
      }
      
      try {
        const conflict: Conflict = {
          id: `conflict_${Date.now()}_${Math.random()}`,
          name: data.conflict_name || 'Unnamed Conflict',
          description: data.description_rationale || '',
          involvedCharacters: involvedIds,
          subject: this.parseConflictSubject(data.subject),
          scope: this.parseConflictScope(data.scope),
          phase: this.parseConflictPhase(data.initial_phase),
          strength: parseInt(data.strength) || 5,
          relatedRelationships: data.related_relationships || [],
          pivotPoints: data.pivot_points || [],
          timestamps: [new Date()],
          metadata: {
            source: 'AI_Inference_Engine',
            inferenceTimestamp: new Date().toISOString()
          }
        };
        
        conflicts.push(conflict);
      } catch (error) {
        console.error('Error parsing conflict:', error);
      }
    }
    
    return conflicts;
  }
  
  private parseConflictSubject(subjectStr: string): ConflictSubject {
    const normalized = subjectStr?.toUpperCase().replace(/[- ]/g, '_');
    return ConflictSubject[normalized as keyof typeof ConflictSubject] || 
           ConflictSubject.OTHER;
  }
  
  private parseConflictScope(scopeStr: string): ConflictScope {
    const normalized = scopeStr?.toUpperCase().replace(/[- ]/g, '_');
    return ConflictScope[normalized as keyof typeof ConflictScope] || 
           ConflictScope.PERSONAL;
  }
  
  private parseConflictPhase(phaseStr: string): ConflictPhase {
    const normalized = phaseStr?.toUpperCase().replace(/[- ]/g, '_');
    return ConflictPhase[normalized as keyof typeof ConflictPhase] || 
           ConflictPhase.EMERGING;
  }
}

/**
 * المحطة الثالثة: بناء شبكة الصراع
 */
class Station3NetworkBuilder extends BaseStation<Station3Input, Station3Output> {
  private relationshipEngine: RelationshipInferenceEngine;
  private conflictEngine: ConflictInferenceEngine;
  
  constructor(
    config: StationConfig,
    geminiService: GeminiService,
    resultSelector: AIResultSelector
  ) {
    super(config, geminiService, resultSelector);
    this.relationshipEngine = new RelationshipInferenceEngine(
      geminiService,
      resultSelector
    );
    this.conflictEngine = new ConflictInferenceEngine(
      geminiService,
      resultSelector
    );
  }
  
  protected async process(input: Station3Input): Promise<Station3Output> {
    const startTime = Date.now();
    
    // 1. استخراج الشخصيات من المحطة الأولى
    const characters = this.extractCharacters(input.station1Output);
    
    // 2. بناء شبكة الصراع
    const network: ConflictNetwork = {
      id: `network_${Date.now()}`,
      name: `ConflictNetwork_${input.station2Output.storyStatement.substring(0, 30)}`,
      characters: new Map(characters.map(c => [c.id, c])),
      relationships: new Map(),
      conflicts: new Map(),
      snapshots: [],
      metadata: {
        buildTimestamp: new Date().toISOString(),
        station1Source: 'Included',
        station2Source: 'Included'
      },
      addCharacter: function(character: Character): void {
        this.characters.set(character.id, character);
      },
      addRelationship: function(relationship: Relationship): void {
        this.relationships.set(relationship.id, relationship);
      },
      addConflict: function(conflict: Conflict): void {
        this.conflicts.set(conflict.id, conflict);
      },
      createSnapshot: function(description: string): void {
        this.snapshots.push({
          timestamp: new Date(),
          description,
          networkState: {
            characters: new Map(this.characters),
            relationships: new Map(this.relationships),
            conflicts: new Map(this.conflicts)
          }
        });
      }
    };
    
    // 3. استدلال العلاقات
    const relationships = await this.relationshipEngine.inferRelationships(
      characters,
      input.station1Output.relationshipAnalysis,
      input.station2Output,
      input.fullText
    );
    
    relationships.forEach(rel => network.addRelationship(rel));
    
    // 4. استدلال الصراعات
    const conflicts = await this.conflictEngine.inferConflicts(
      characters,
      relationships,
      input.station2Output,
      input.fullText
    );
    
    conflicts.forEach(conf => network.addConflict(conf));
    
    // 5. إنشاء لقطة أولية
    network.createSnapshot('Initial network state after inference');
    
    const buildTime = Date.now() - startTime;
    
    return {
      conflictNetwork: network,
      networkSummary: {
        charactersCount: network.characters.size,
        relationshipsCount: network.relationships.size,
        conflictsCount: network.conflicts.size,
        snapshotsCount: network.snapshots.length
      },
      metadata: {
        analysisTimestamp: new Date(),
        status: 'Success',
        buildTime
      }
    };
  }
  
  private extractCharacters(s1Output: Station1Output): Character[] {
    const characters: Character[] = [];
    
    for (const [name, analysis] of s1Output.characterAnalysis) {
      const character: Character = {
        id: `char_${name.replace(/\s+/g, '_')}_${Date.now()}`,
        name,
        description: analysis.narrativeFunction,
        profile: {
          personalityTraits: analysis.personalityTraits,
          motivationsGoals: analysis.motivationsGoals,
          potentialArc: analysis.potentialArcObservation
        },
        metadata: {
          keyRelationshipsBrief: analysis.keyRelationshipsBrief,
          source: 'Station1_Analysis',
          extractionTimestamp: new Date().toISOString()
        }
      };
      
      characters.push(character);
    }
    
    return characters;
  }
  
  protected extractRequiredData(input: Station3Input): any {
    return {
      station1: input.station1Output,
      station2: input.station2Output,
      fullText: input.fullText
    };
  }
  
  protected getErrorFallback(): Station3Output {
    const emptyNetwork: ConflictNetwork = {
      id: 'error_network',
      name: 'ErrorNetwork',
      characters: new Map(),
      relationships: new Map(),
      conflicts: new Map(),
      snapshots: [],
      metadata: { error: 'Network building failed' },
      addCharacter: () => {},
      addRelationship: () => {},
      addConflict: () => {},
      createSnapshot: () => {}
    };
    
    return {
      conflictNetwork: emptyNetwork,
      networkSummary: {
        charactersCount: 0,
        relationshipsCount: 0,
        conflictsCount: 0,
        snapshotsCount: 0
      },
      metadata: {
        analysisTimestamp: new Date(),
        status: 'Failed',
        buildTime: 0
      }
    };
  }
}


---

## المحطة الرابعة: قياس الكفاءة والفعالية

```typescript
// stations/station4/station4-efficiency-metrics.ts

interface Station4Input {
  conflictNetwork: ConflictNetwork;
  station3Output: Station3Output;
}

interface Station4Output {
  overallEfficiencyScore: number;
  overallRating: 'Excellent' | 'Good' | 'Fair' | 'Poor' | 'Critical';
  conflictCohesion: number;
  dramaticBalance: DramaticBalanceMetrics;
  narrativeEfficiency: NarrativeEfficiencyMetrics;
  redundancy: RedundancyMetrics;
  narrativeDensity: DensityMetrics;
  issues: EfficiencyIssue[];
  recommendations: string[];
  metadata: {
    analysisTimestamp: Date;
    status: 'Success' | 'Partial' | 'Failed';
    analysisTime: number;
  };
}

interface DramaticBalanceMetrics {
  balanceScore: number;
  balanceRating: string;
  characterInvolvementGini: number;
  conflictDistributionScore: number;
  details: {
    characterInvolvementStats: Map<string, number>;
    conflictTypeDistribution: Map<ConflictSubject, number>;
  };
}

interface NarrativeEfficiencyMetrics {
  narrativeEfficiencyScore: number;
  efficiencyRating: string;
  characterEfficiency: number;
  relationshipEfficiency: number;
  conflictEfficiency: number;
  details: {
    activeCharactersRatio: number;
    meaningfulRelationshipsRatio: number;
    resolvedConflictsRatio: number;
  };
}

interface RedundancyMetrics {
  redundancyScore: number;
  redundancyLevel: 'Low' | 'Moderate' | 'High' | 'Critical';
  duplicateRelationships: number;
  overlappingConflicts: number;
  details: {
    redundantPairs: Array<{
      type: 'relationship' | 'conflict';
      ids: [string, string];
      similarityScore: number;
    }>;
  };
}

interface DensityMetrics {
  densityScores: {
    storyDensity: number;
    characterDensity: number;
    conflictDensity: number;
  };
  densityRating: string;
  details: {
    averageConnectionsPerCharacter: number;
    averageConflictsPerCharacter: number;
    networkCentralization: number;
  };
}

interface EfficiencyIssue {
  type: 'structural' | 'balance' | 'redundancy' | 'density' | 'other';
  severity: 'critical' | 'major' | 'minor';
  description: string;
  affectedEntities: string[];
  suggestion: string;
}

/**
 * وحدة قياس الكفاءة
 */
class EfficiencyMetricsAnalyzer {
  /**
   * حساب تماسك الصراعات
   */
  calculateConflictCohesion(network: ConflictNetwork): number {
    const conflicts = Array.from(network.conflicts.values());
    
    if (conflicts.length === 0) return 0;
    
    // حساب التداخل بين الصراعات
    let totalOverlap = 0;
    let comparisons = 0;
    
    for (let i = 0; i < conflicts.length; i++) {
      for (let j = i + 1; j < conflicts.length; j++) {
        const overlap = this.calculateConflictOverlap(
          conflicts[i],
          conflicts[j]
        );
        totalOverlap += overlap;
        comparisons++;
      }
    }
    
    return comparisons > 0 ? totalOverlap / comparisons : 0;
  }
  
  private calculateConflictOverlap(
    c1: Conflict,
    c2: Conflict
  ): number {
    const chars1 = new Set(c1.involvedCharacters);
    const chars2 = new Set(c2.involvedCharacters);
    
    const intersection = new Set(
      [...chars1].filter(x => chars2.has(x))
    );
    const union = new Set([...chars1, ...chars2]);
    
    return union.size > 0 ? intersection.size / union.size : 0;
  }
  
  /**
   * حساب التوازن الدرامي
   */
  calculateDramaticBalance(
    network: ConflictNetwork
  ): DramaticBalanceMetrics {
    const characters = Array.from(network.characters.values());
    const conflicts = Array.from(network.conflicts.values());
    
    // حساب مشاركة كل شخصية
    const involvementMap = new Map<string, number>();
    
    for (const char of characters) {
      let involvement = 0;
      
      // من الصراعات
      for (const conflict of conflicts) {
        if (conflict.involvedCharacters.includes(char.id)) {
          involvement += conflict.strength;
        }
      }
      
      // من العلاقات
      for (const rel of network.relationships.values()) {
        if (rel.source === char.id || rel.target === char.id) {
          involvement += rel.strength * 0.5;
        }
      }
      
      involvementMap.set(char.id, involvement);
    }
    
    // حساب معامل جيني للتوزيع
    const gini = this.calculateGiniCoefficient(
      Array.from(involvementMap.values())
    );
    
    // حساب توزيع أنواع الصراعات
    const conflictTypeDistribution = new Map<ConflictSubject, number>();
    for (const conflict of conflicts) {
      conflictTypeDistribution.set(
        conflict.subject,
        (conflictTypeDistribution.get(conflict.subject) || 0) + 1
      );
    }
    
    // درجة التوازن (كلما قل جيني، زاد التوازن)
    const balanceScore = Math.max(0, 1 - gini);
    
    return {
      balanceScore,
      balanceRating: this.getRating(balanceScore),
      characterInvolvementGini: gini,
      conflictDistributionScore: this.calculateDistributionScore(
        conflictTypeDistribution
      ),
      details: {
        characterInvolvementStats: involvementMap,
        conflictTypeDistribution
      }
    };
  }
  
  /**
   * حساب معامل جيني
   */
  private calculateGiniCoefficient(values: number[]): number {
    if (values.length === 0) return 0;
    
    const sorted = [...values].sort((a, b) => a - b);
    const n = sorted.length;
    const total = sorted.reduce((sum, val) => sum + val, 0);
    
    if (total === 0) return 0;
    
    let sum = 0;
    for (let i = 0; i < n; i++) {
      sum += (i + 1) * sorted[i];
    }
    
    return (2 * sum) / (n * total) - (n + 1) / n;
  }
  
  /**
   * حساب درجة التوزيع
   */
  private calculateDistributionScore(
    distribution: Map<any, number>
  ): number {
    const values = Array.from(distribution.values());
    const total = values.reduce((sum, val) => sum + val, 0);
    
    if (total === 0) return 0;
    
    // حساب الإنتروبيا (Shannon Entropy)
    let entropy = 0;
    for (const count of values) {
      if (count > 0) {
        const p = count / total;
        entropy -= p * Math.log2(p);
      }
    }
    
    // تطبيع الإنتروبيا
    const maxEntropy = Math.log2(distribution.size);
    return maxEntropy > 0 ? entropy / maxEntropy : 0;
  }
  
  /**
   * حساب كفاءة السرد
   */
  calculateNarrativeEfficiency(
    network: ConflictNetwork
  ): NarrativeEfficiencyMetrics {
    const characters = Array.from(network.characters.values());
    const relationships = Array.from(network.relationships.values());
    const conflicts = Array.from(network.conflicts.values());
    
    // الشخصيات النشطة (المشاركة في صراعات أو علاقات)
    const activeCharacters = new Set<string>();
    
    for (const conflict of conflicts) {
      conflict.involvedCharacters.forEach(id => 
        activeCharacters.add(id)
      );
    }
    
    for (const rel of relationships) {
      activeCharacters.add(rel.source);
      activeCharacters.add(rel.target);
    }
    
    const activeRatio = characters.length > 0 
      ? activeCharacters.size / characters.length 
      : 0;
    
    // العلاقات الذات معنى (قوة > 5)
    const meaningfulRels = relationships.filter(r => r.strength > 5);
    const meaningfulRelsRatio = relationships.length > 0
      ? meaningfulRels.length / relationships.length
      : 0;
    
    // الصراعات المتقدمة (ليست في مرحلة LATENT)
    const advancedConflicts = conflicts.filter(
      c => c.phase !== ConflictPhase.LATENT
    );
    const advancedConflictsRatio = conflicts.length > 0
      ? advancedConflicts.length / conflicts.length
      : 0;
    
    // الكفاءة الكلية
    const characterEfficiency = activeRatio;
    const relationshipEfficiency = meaningfulRelsRatio;
    const conflictEfficiency = advancedConflictsRatio;
    
    const narrativeEfficiencyScore = 
      (characterEfficiency + relationshipEfficiency + conflictEfficiency) / 3;
    
    return {
      narrativeEfficiencyScore,
      efficiencyRating: this.getRating(narrativeEfficiencyScore),
      characterEfficiency,
      relationshipEfficiency,
      conflictEfficiency,
      details: {
        activeCharactersRatio: activeRatio,
        meaningfulRelationshipsRatio: meaningfulRelsRatio,
        resolvedConflictsRatio: advancedConflictsRatio
      }
    };
  }
  
  /**
   * تحليل التكرار
   */
  analyzeRedundancy(network: ConflictNetwork): RedundancyMetrics {
    const relationships = Array.from(network.relationships.values());
    const conflicts = Array.from(network.conflicts.values());
    
    const redundantPairs: Array<{
      type: 'relationship' | 'conflict';
      ids: [string, string];
      similarityScore: number;
    }> = [];
    
    // فحص العلاقات المكررة
    for (let i = 0; i < relationships.length; i++) {
      for (let j = i + 1; j < relationships.length; j++) {
        const similarity = this.calculateRelationshipSimilarity(
          relationships[i],
          relationships[j]
        );
        
        if (similarity > 0.8) {
          redundantPairs.push({
            type: 'relationship',
            ids: [relationships[i].id, relationships[j].id],
            similarityScore: similarity
          });
        }
      }
    }
    
    // فحص الصراعات المتداخلة
    for (let i = 0; i < conflicts.length; i++) {
      for (let j = i + 1; j < conflicts.length; j++) {
        const similarity = this.calculateConflictSimilarity(
          conflicts[i],
          conflicts[j]
        );
        
        if (similarity > 0.7) {
          redundantPairs.push({
            type: 'conflict',
            ids: [conflicts[i].id, conflicts[j].id],
            similarityScore: similarity
          });
        }
      }
    }
    
    const duplicateRelationships = redundantPairs.filter(
      p => p.type === 'relationship'
    ).length;
    
    const overlappingConflicts = redundantPairs.filter(
      p => p.type === 'conflict'
    ).length;
    
    const totalEntities = relationships.length + conflicts.length;
    const redundancyScore = totalEntities > 0
      ? (duplicateRelationships + overlappingConflicts) / totalEntities
      : 0;
    
    return {
      redundancyScore,
      redundancyLevel: this.getRedundancyLevel(redundancyScore),
      duplicateRelationships,
      overlappingConflicts,
      details: { redundantPairs }
    };
  }
  
  private calculateRelationshipSimilarity(
    r1: Relationship,
    r2: Relationship
  ): number {
    // نفس الشخصيات؟
    const samePair = 
      (r1.source === r2.source && r1.target === r2.target) ||
      (r1.source === r2.target && r1.target === r2.source);
    
    if (!samePair) return 0;
    
    // نفس النوع والطبيعة؟
    const sameType = r1.type === r2.type ? 0.5 : 0;
    const sameNature = r1.nature === r2.nature ? 0.5 : 0;
    
    return 0.5 + sameType + sameNature; // أساس 0.5 لنفس الشخصيات
  }
  
  private calculateConflictSimilarity(
    c1: Conflict,
    c2: Conflict
  ): number {
    const chars1 = new Set(c1.involvedCharacters);
    const chars2 = new Set(c2.involvedCharacters);
    
    const intersection = new Set(
      [...chars1].filter(x => chars2.has(x))
    );
    
    const charOverlap = chars1.size > 0 && chars2.size > 0
      ? intersection.size / Math.min(chars1.size, chars2.size)
      : 0;
    
    const sameSubject = c1.subject === c2.subject ? 0.3 : 0;
    const sameScope = c1.scope === c2.scope ? 0.2 : 0;
    
    return charOverlap * 0.5 + sameSubject + sameScope;
  }
  
  /**
   * حساب الكثافة السردية
   */
  calculateNarrativeDensity(
    network: ConflictNetwork
  ): DensityMetrics {
    const numChars = network.characters.size;
    const numRels = network.relationships.size;
    const numConflicts = network.conflicts.size;
    
    if (numChars === 0) {
      return {
        densityScores: {
          storyDensity: 0,
          characterDensity: 0,
          conflictDensity: 0
        },
        densityRating: 'Empty',
        details: {
          averageConnectionsPerCharacter: 0,
          averageConflictsPerCharacter: 0,
          networkCentralization: 0
        }
      };
    }
    
    // الكثافة الكلية
    const maxPossibleConnections = numChars * (numChars - 1) / 2;
    const characterDensity = maxPossibleConnections > 0
      ? numRels / maxPossibleConnections
      : 0;
    
    const conflictDensity = numConflicts / numChars;
    
    const storyDensity = (characterDensity + Math.min(conflictDensity, 1)) / 2;
    
    // متوسط الاتصالات لكل شخصية
    const avgConnections = (numRels * 2) / numChars;
    
    // متوسط الصراعات لكل شخصية
    let totalInvolvement = 0;
    for (const conflict of network.conflicts.values()) {
      totalInvolvement += conflict.involvedCharacters.length;
    }
    const avgConflicts = totalInvolvement / numChars;
    
    // المركزية (Network Centralization)
    const centralization = this.calculateNetworkCentralization(network);
    
    return {
      densityScores: {
        storyDensity,
        characterDensity,
        conflictDensity
      },
      densityRating: this.getRating(storyDensity),
      details: {
        averageConnectionsPerCharacter: avgConnections,
        averageConflictsPerCharacter: avgConflicts,
        networkCentralization: centralization
      }
    };
  }
  
  private calculateNetworkCentralization(
    network: ConflictNetwork
  ): number {
    const degrees = new Map<string, number>();
    
    // حساب الدرجة لكل شخصية
    for (const char of network.characters.keys()) {
      degrees.set(char, 0);
    }
    
    for (const rel of network.relationships.values()) {
      degrees.set(rel.source, (degrees.get(rel.source) || 0) + 1);
      degrees.set(rel.target, (degrees.get(rel.target) || 0) + 1);
    }
    
    const degreeValues = Array.from(degrees.values());
    if (degreeValues.length === 0) return 0;
    
    const maxDegree = Math.max(...degreeValues);
    const n = degreeValues.length;
    
    let sum = 0;
    for (const degree of degreeValues) {
      sum += maxDegree - degree;
    }
    
    const maxCentralization = (n - 1) * (n - 2);
    return maxCentralization > 0 ? sum / maxCentralization : 0;
  }
  
  private getRating(score: number): string {
    if (score >= 0.8) return 'Excellent';
    if (score >= 0.6) return 'Good';
    if (score >= 0.4) return 'Fair';
    if (score >= 0.2) return 'Poor';
    return 'Critical';
  }
  
  private getRedundancyLevel(score: number): 'Low' | 'Moderate' | 'High' | 'Critical' {
    if (score < 0.1) return 'Low';
    if (score < 0.25) return 'Moderate';
    if (score < 0.5) return 'High';
    return 'Critical';
  }
}

/**
 * المحطة الرابعة: قياس الكفاءة
 */
class Station4EfficiencyMetrics extends BaseStation<Station4Input, Station4Output> {
  private analyzer: EfficiencyMetricsAnalyzer;
  
  constructor(
    config: StationConfig,
    geminiService: GeminiService,
    resultSelector: AIResultSelector
  ) {
    super(config, geminiService, resultSelector);
    this.analyzer = new EfficiencyMetricsAnalyzer();
  }
  
  protected async process(input: Station4Input): Promise<Station4Output> {
    const network = input.conflictNetwork;
    const startTime = Date.now();
    
    // حساب جميع المقاييس
    const conflictCohesion = this.analyzer.calculateConflictCohesion(network);
    const dramaticBalance = this.analyzer.calculateDramaticBalance(network);
    const narrativeEfficiency = this.analyzer.calculateNarrativeEfficiency(network);
    const redundancy = this.analyzer.analyzeRedundancy(network);
    const narrativeDensity = this.analyzer.calculateNarrativeDensity(network);
    
    // حساب الدرجة الكلية
    const overallEfficiencyScore = this.calculateOverallScore({
      conflictCohesion,
      dramaticBalance: dramaticBalance.balanceScore,
      narrativeEfficiency: narrativeEfficiency.narrativeEfficiencyScore,
      redundancy: 1 - redundancy.redundancyScore, // عكس التكرار
      narrativeDensity: narrativeDensity.densityScores.storyDensity
    });
    
    // تحديد المشاكل
    const issues = this.identifyIssues({
      conflictCohesion,
      dramaticBalance,
      narrativeEfficiency,
      redundancy,
      narrativeDensity
    });
    
    // تقديم التوصيات
    const recommendations = this.generateRecommendations(issues);
    
    const analysisTime = Date.now() - startTime;
    
    return {
      overallEfficiencyScore,
      overallRating: this.getOverallRating(overallEfficiencyScore),
      conflictCohesion,
      dramaticBalance,
      narrativeEfficiency,
      redundancy,
      narrativeDensity,
      issues,
      recommendations,
      metadata: {
        analysisTimestamp: new Date(),
        status: 'Success',
        analysisTime
      }
    };
  }
  
  private calculateOverallScore(metrics: {
    conflictCohesion: number;
    dramaticBalance: number;
    narrativeEfficiency: number;
    redundancy: number;
    narrativeDensity: number;
  }): number {
    // الأوزان النسبية
    const weights = {
      conflictCohesion: 0.25,
      dramaticBalance: 0.25,
      narrativeEfficiency: 0.25,
      redundancy: 0.15,
      narrativeDensity: 0.10
    };
    
    return (
      metrics.conflictCohesion * weights.conflictCohesion +
      metrics.dramaticBalance * weights.dramaticBalance +
      metrics.narrativeEfficiency * weights.narrativeEfficiency +
      metrics.redundancy * weights.redundancy +
      metrics.narrativeDensity * weights.narrativeDensity
    );
  }
  
  private getOverallRating(
    score: number
  ): 'Excellent' | 'Good' | 'Fair' | 'Poor' | 'Critical' {
    if (score >= 0.8) return 'Excellent';
    if (score >= 0.6) return 'Good';
    if (score >= 0.4) return 'Fair';
    if (score >= 0.2) return 'Poor';
    return 'Critical';
  }
  
  private identifyIssues(metrics: {
    conflictCohesion: number;
    dramaticBalance: DramaticBalanceMetrics;
    narrativeEfficiency: NarrativeEfficiencyMetrics;
    redundancy: RedundancyMetrics;
    narrativeDensity: DensityMetrics;
  }): EfficiencyIssue[] {
    const issues: EfficiencyIssue[] = [];
    
    // فحص تماسك الصراعات
    if (metrics.conflictCohesion < 0.3) {
      issues.push({
        type: 'structural',
        severity: 'major',
        description: 'Conflict cohesion is very low - conflicts appear disconnected',
        affectedEntities: ['conflicts'],
        suggestion: 'Consider adding shared characters or themes between conflicts'
      });
    }
    
    // فحص التوازن الدرامي
    if (metrics.dramaticBalance.characterInvolvementGini > 0.6) {
      issues.push({
        type: 'balance',
        severity: 'major',
        description: 'High imbalance in character involvement - some characters dominate',
        affectedEntities: ['characters'],
        suggestion: 'Distribute conflicts and relationships more evenly among characters'
      });
    }
    
    // فحص الكفاءة السردية
    if (metrics.narrativeEfficiency.characterEfficiency < 0.5) {
      issues.push({
        type: 'structural',
        severity: 'major',
        description: `Low character utilization - ${Math.round((1 - metrics.narrativeEfficiency.characterEfficiency) * 100)}% of characters are inactive`,
        affectedEntities: ['characters'],
        suggestion: 'Remove inactive characters or integrate them into conflicts'
      });
    }
    
    // فحص التكرار
    if (metrics.redundancy.redundancyLevel === 'High' || 
        metrics.redundancy.redundancyLevel === 'Critical') {
      issues.push({
        type: 'redundancy',
        severity: metrics.redundancy.redundancyLevel === 'Critical' ? 'critical' : 'major',
        description: `${metrics.redundancy.redundancyLevel} redundancy detected`,
        affectedEntities: ['relationships', 'conflicts'],
        suggestion: 'Review and consolidate similar relationships or conflicts'
      });
    }
    
    // فحص الكثافة
    if (metrics.narrativeDensity.densityScores.storyDensity < 0.2) {
      issues.push({
        type: 'density',
        severity: 'minor',
        description: 'Low story density - narrative may feel sparse',
        affectedEntities: ['overall'],
        suggestion: 'Consider adding more relationships or conflicts'
      });
    } else if (metrics.narrativeDensity.densityScores.storyDensity > 0.8) {
      issues.push({
        type: 'density',
        severity: 'minor',
        description: 'Very high story density - narrative may feel overwhelming',
        affectedEntities: ['overall'],
        suggestion: 'Consider simplifying some relationships or conflicts'
      });
    }
    
    return issues;
  }
  
  private generateRecommendations(issues: EfficiencyIssue[]): string[] {
    const recommendations = new Set<string>();
    
    for (const issue of issues) {
      if (issue.severity === 'critical' || issue.severity === 'major') {
        recommendations.add(issue.suggestion);
      }
    }
    
    // توصيات عامة
    if (issues.length === 0) {
      recommendations.add('Network structure is well-balanced - maintain current approach');
    } else if (issues.filter(i => i.severity === 'critical').length > 0) {
      recommendations.add('Critical issues detected - major revision recommended');
    }
    
    return Array.from(recommendations);
  }
  
  protected extractRequiredData(input: Station4Input): any {
    return {
      network: input.conflictNetwork,
      station3Output: input.station3Output
    };
  }
  
  protected getErrorFallback(): Station4Output {
    return {
      overallEfficiencyScore: 0,
      overallRating: 'Critical',
      conflictCohesion: 0,
      dramaticBalance: {
        balanceScore: 0,
        balanceRating: 'Critical',
        characterInvolvementGini: 1,
        conflictDistributionScore: 0,
        details: {
          characterInvolvementStats: new Map(),
          conflictTypeDistribution: new Map()
        }
      },
      narrativeEfficiency: {
        narrativeEfficiencyScore: 0,
        efficiencyRating: 'Critical',
        characterEfficiency: 0,
        relationshipEfficiency: 0,
        conflictEfficiency: 0,
        details: {
          activeCharactersRatio: 0,
          meaningfulRelationshipsRatio: 0,
          resolvedConflictsRatio: 0
        }
      },
      redundancy: {
        redundancyScore: 0,
        redundancyLevel: 'Low',
        duplicateRelationships: 0,
        overlappingConflicts: 0,
        details: { redundantPairs: [] }
      },
      narrativeDensity: {
        densityScores: {
          storyDensity: 0,
          characterDensity: 0,
          conflictDensity: 0
        },
        densityRating: 'Empty',
        details: {
          averageConnectionsPerCharacter: 0,
          averageConflictsPerCharacter: 0,
          networkCentralization: 0
        }
      },
      issues: [],
      recommendations: ['Analysis failed - unable to generate recommendations'],
      metadata: {
        analysisTimestamp: new Date(),
        status: 'Failed',
        analysisTime: 0
      }
    };
  }
}
```
المحطة الخامسة: التحليل الديناميكي والرمزي والأسلوبي
typescript// stations/station5/station5-dynamic-symbolic-stylistic.ts

interface Station5Input {
  conflictNetwork: ConflictNetwork;
  station4Output: Station4Output;
  fullText: string;
}

interface Station5Output {
  dynamicAnalysisResults: DynamicAnalysisResults;
  episodicIntegrationResults: EpisodicIntegrationResults;
  symbolicAnalysisResults: SymbolicAnalysisResults;
  stylisticAnalysisResults: StylisticAnalysisResults;
  metadata: {
    analysisTimestamp: Date;
    status: 'Success' | 'Partial' | 'Failed';
    analysisTime: number;
  };
}

interface DynamicAnalysisResults {
  eventTimeline: TimelineEvent[];
  networkEvolutionAnalysis: EvolutionAnalysis;
  characterDevelopmentTracking: Map<string, CharacterEvolution>;
  conflictProgressionTracking: Map<string, ConflictProgression>;
}

interface TimelineEvent {
  timestamp: Date;
  eventType: 'character_introduced' | 'relationship_formed' | 
              'conflict_emerged' | 'conflict_escalated' | 
              'conflict_resolved' | 'character_transformed' | 
              'network_snapshot' | 'other';
  description: string;
  involvedEntities: {
    characters?: string[];
    relationships?: string[];
    conflicts?: string[];
  };
  significance: number; // 1-10
  narrativePhase: 'setup' | 'rising_action' | 'climax' | 
                   'falling_action' | 'resolution';
}

interface EvolutionAnalysis {
  overallGrowthRate: number;
  complexityProgression: number[];
  densityProgression: number[];
  criticalTransitionPoints: Array<{
    timestamp: Date;
    description: string;
    impactScore: number;
  }>;
  stabilityMetrics: {
    structuralStability: number;
    characterStability: number;
    conflictStability: number;
  };
}

interface CharacterEvolution {
  characterId: string;
  characterName: string;
  developmentStages: Array<{
    timestamp: Date;
    stage: string;
    traits: string[];
    relationships: string[];
    conflicts: string[];
  }>;
  arcType: 'positive' | 'negative' | 'flat' | 'complex';
  transformationScore: number;
  keyMoments: Array<{
    timestamp: Date;
    event: string;
    impact: string;
  }>;
}

interface ConflictProgression {
  conflictId: string;
  conflictName: string;
  phaseTransitions: Array<{
    timestamp: Date;
    fromPhase: ConflictPhase;
    toPhase: ConflictPhase;
    catalyst: string;
  }>;
  intensityProgression: number[];
  resolutionProbability: number;
  stagnationRisk: number;
}

interface EpisodicIntegrationResults {
  seriesStructure: SeriesStructure;
  seasonBreakdown: Map<number, SeasonDetails>;
  episodeDistribution: Map<string, EpisodeAssignment>;
  balanceReport: EpisodicBalanceReport;
}

interface SeriesStructure {
  totalSeasons: number;
  episodesPerSeason: number;
  totalEpisodes: number;
  recommendedRuntime: number; // minutes per episode
}

interface SeasonDetails {
  seasonNumber: number;
  seasonTitle: string;
  episodes: Episode[];
  majorConflicts: string[];
  seasonArc: string;
  cliffhanger?: string;
}

interface Episode {
  episodeNumber: number;
  seasonNumber: number;
  title: string;
  assignedConflicts: string[];
  featuredCharacters: string[];
  estimatedIntensity: number;
  narrativeFunction: 'setup' | 'development' | 'climax' | 'resolution';
}

interface EpisodeAssignment {
  conflictId: string;
  episodes: number[];
  distributionQuality: number;
}

interface EpisodicBalanceReport {
  overallBalance: number;
  conflictDistributionScore: number;
  characterAppearanceBalance: number;
  intensityFlowScore: number;
  recommendations: string[];
}

interface SymbolicAnalysisResults {
  keySymbols: Array<{
    symbol: string;
    interpretation: string;
    frequency: number;
    contextualMeanings: string[];
  }>;
  recurringMotifs: Array<{
    motif: string;
    occurrences: number;
    narrativeFunction: string;
  }>;
  centralThemesHintedBySymbols: string[];
  symbolicNetworks: Array<{
    primarySymbol: string;
    relatedSymbols: string[];
    thematicConnection: string;
  }>;
  depthScore: number;
  consistencyScore: number;
}

interface StylisticAnalysisResults {
  overallToneAssessment: {
    primaryTone: string;
    secondaryTones: string[];
    toneConsistency: number;
    explanation: string;
  };
  languageComplexity: {
    level: 'simple' | 'moderate' | 'complex' | 'highly_complex';
    readabilityScore: number;
    vocabularyRichness: number;
  };
  pacingImpression: {
    overallPacing: 'very_slow' | 'slow' | 'balanced' | 'fast' | 'very_fast';
    pacingVariation: number;
    sceneLengthDistribution: number[];
  };
  dialogueStyle: {
    characterization: string;
    naturalness: number;
    effectiveness: number;
    distinctiveness: number;
  };
  descriptiveRichness: {
    visualDetailLevel: number;
    sensoryEngagement: number;
    atmosphericQuality: number;
  };
  stylisticConsistencyImpression: {
    consistencyScore: number;
    deviations: Array<{
      location: string;
      type: string;
      description: string;
    }>;
  };
  textBlobSentiment?: {
    polarity: number;
    subjectivity: number;
  };
}

/**
 * محرك التحليل الديناميكي
 */
class DynamicAnalysisEngine {
  /**
   * بناء الجدول الزمني للأحداث
   */
  constructEventTimeline(network: ConflictNetwork): TimelineEvent[] {
    const events: TimelineEvent[] = [];
    
    // استخراج الأحداث من لقطات الشبكة
    for (const snapshot of network.snapshots) {
      events.push({
        timestamp: snapshot.timestamp,
        eventType: 'network_snapshot',
        description: snapshot.description,
        involvedEntities: {},
        significance: 5,
        narrativePhase: this.inferNarrativePhase(
          snapshot.timestamp,
          network.snapshots
        )
      });
    }
    
    // استخراج الأحداث من الصراعات
    for (const conflict of network.conflicts.values()) {
      // حدث ظهور الصراع
      if (conflict.timestamps.length > 0) {
        events.push({
          timestamp: conflict.timestamps[0],
          eventType: 'conflict_emerged',
          description: `Conflict emerged: ${conflict.name}`,
          involvedEntities: {
            characters: conflict.involvedCharacters,
            conflicts: [conflict.id]
          },
          significance: conflict.strength,
          narrativePhase: this.inferNarrativePhase(
            conflict.timestamps[0],
            network.snapshots
          )
        });
      }
      
      // أحداث تطور الصراع
      for (let i = 1; i < conflict.timestamps.length; i++) {
        events.push({
          timestamp: conflict.timestamps[i],
          eventType: 'conflict_escalated',
          description: `Conflict escalated: ${conflict.name}`,
          involvedEntities: {
            characters: conflict.involvedCharacters,
            conflicts: [conflict.id]
          },
          significance: conflict.strength,
          narrativePhase: this.inferNarrativePhase(
            conflict.timestamps[i],
            network.snapshots
          )
        });
      }
    }
    
    // ترتيب الأحداث زمنياً
    events.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());
    
    return events;
  }
  
  private inferNarrativePhase(
    timestamp: Date,
    snapshots: NetworkSnapshot[]
  ): 'setup' | 'rising_action' | 'climax' | 'falling_action' | 'resolution' {
    if (snapshots.length === 0) return 'setup';
    
    const totalDuration = snapshots[snapshots.length - 1].timestamp.getTime() - 
                         snapshots[0].timestamp.getTime();
    
    if (totalDuration === 0) return 'setup';
    
    const position = (timestamp.getTime() - snapshots[0].timestamp.getTime()) / totalDuration;
    
    if (position < 0.2) return 'setup';
    if (position < 0.5) return 'rising_action';
    if (position < 0.7) return 'climax';
    if (position < 0.9) return 'falling_action';
    return 'resolution';
  }
  
  /**
   * تحليل تطور الشبكة
   */
  analyzeNetworkEvolution(
    network: ConflictNetwork,
    timeline: TimelineEvent[]
  ): EvolutionAnalysis {
    const complexityProgression: number[] = [];
    const densityProgression: number[] = [];
    const transitionPoints: Array<{
      timestamp: Date;
      description: string;
      impactScore: number;
    }> = [];
    
    // حساب التعقيد والكثافة عبر الزمن
    for (const snapshot of network.snapshots) {
      if (!snapshot.networkState.characters || 
          !snapshot.networkState.relationships || 
          !snapshot.networkState.conflicts) {
        continue;
      }
      
      const numChars = snapshot.networkState.characters.size;
      const numRels = snapshot.networkState.relationships.size;
      const numConflicts = snapshot.networkState.conflicts.size;
      
      // التعقيد = عدد الكيانات الكلي
      const complexity = numChars + numRels + numConflicts;
      complexityProgression.push(complexity);
      
      // الكثافة = العلاقات / الشخصيات الممكنة
      const maxPossibleRels = numChars * (numChars - 1) / 2;
      const density = maxPossibleRels > 0 ? numRels / maxPossibleRels : 0;
      densityProgression.push(density);
    }
    
    // تحديد نقاط التحول الحرجة
    for (let i = 1; i < complexityProgression.length; i++) {
      const change = Math.abs(
        complexityProgression[i] - complexityProgression[i - 1]
      );
      
      if (change > 5) { // عتبة التغيير المهم
        transitionPoints.push({
          timestamp: network.snapshots[i].timestamp,
          description: network.snapshots[i].description,
          impactScore: change
        });
      }
    }
    
    // حساب معدل النمو الكلي
    const overallGrowthRate = complexityProgression.length > 1
      ? (complexityProgression[complexityProgression.length - 1] - 
         complexityProgression[0]) / complexityProgression.length
      : 0;
    
    // حساب مقاييس الاستقرار
    const stabilityMetrics = this.calculateStabilityMetrics(
      complexityProgression,
      densityProgression
    );
    
    return {
      overallGrowthRate,
      complexityProgression,
      densityProgression,
      criticalTransitionPoints: transitionPoints,
      stabilityMetrics
    };
  }
  
  private calculateStabilityMetrics(
    complexityProgression: number[],
    densityProgression: number[]
  ): {
    structuralStability: number;
    characterStability: number;
    conflictStability: number;
  } {
    // حساب التباين في التعقيد
    const complexityVariance = this.calculateVariance(complexityProgression);
    const densityVariance = this.calculateVariance(densityProgression);
    
    // الاستقرار = 1 / (1 + التباين)
    const structuralStability = 1 / (1 + complexityVariance);
    
    return {
      structuralStability,
      characterStability: 1 / (1 + densityVariance),
      conflictStability: structuralStability // تقريب
    };
  }
  
  private calculateVariance(values: number[]): number {
    if (values.length === 0) return 0;
    
    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
    const squaredDiffs = values.map(val => Math.pow(val - mean, 2));
    return squaredDiffs.reduce((sum, val) => sum + val, 0) / values.length;
  }
  
  /**
   * تتبع تطور الشخصيات
   */
  trackCharacterDevelopment(
    network: ConflictNetwork,
    timeline: TimelineEvent[]
  ): Map<string, CharacterEvolution> {
    const evolutionMap = new Map<string, CharacterEvolution>();
    
    for (const [charId, character] of network.characters) {
      const developmentStages: CharacterEvolution['developmentStages'] = [];
      const keyMoments: CharacterEvolution['keyMoments'] = [];
      
      // استخراج المراحل من اللقطات
      for (const snapshot of network.snapshots) {
        if (!snapshot.networkState.characters?.has(charId)) continue;
        
        const charState = snapshot.networkState.characters.get(charId);
        if (!charState) continue;
        
        // جمع العلاقات والصراعات في هذه المرحلة
        const relationships: string[] = [];
        const conflicts: string[] = [];
        
        if (snapshot.networkState.relationships) {
          for (const [relId, rel] of snapshot.networkState.relationships) {
            if (rel.source === charId || rel.target === charId) {
              relationships.push(relId);
            }
          }
        }
        
        if (snapshot.networkState.conflicts) {
          for (const [confId, conf] of snapshot.networkState.conflicts) {
            if (conf.involvedCharacters.includes(charId)) {
              conflicts.push(confId);
            }
          }
        }
        
        developmentStages.push({
          timestamp: snapshot.timestamp,
          stage: snapshot.description,
          traits: [], // يمكن استخراجها من التحليل
          relationships,
          conflicts
        });
      }
      
      // استخراج اللحظات المفصلية من الجدول الزمني
      for (const event of timeline) {
        if (event.involvedEntities.characters?.includes(charId)) {
          keyMoments.push({
            timestamp: event.timestamp,
            event: event.description,
            impact: `Significance: ${event.significance}/10`
          });
        }
      }
      
      // تحديد نوع القوس
      const arcType = this.determineArcType(developmentStages);
      
      // حساب درجة التحول
      const transformationScore = this.calculateTransformationScore(
        developmentStages
      );
      
      evolutionMap.set(charId, {
        characterId: charId,
        characterName: character.name,
        developmentStages,
        arcType,
        transformationScore,
        keyMoments
      });
    }
    
    return evolutionMap;
  }
  
  private determineArcType(
    stages: CharacterEvolution['developmentStages']
  ): 'positive' | 'negative' | 'flat' | 'complex' {
    if (stages.length < 2) return 'flat';
    
    // تحليل بسيط بناءً على عدد الصراعات والعلاقات
    const firstStage = stages[0];
    const lastStage = stages[stages.length - 1];
    
    const conflictChange = 
      lastStage.conflicts.length - firstStage.conflicts.length;
    const relationshipChange = 
      lastStage.relationships.length - firstStage.relationships.length;
    
    const totalChange = conflictChange + relationshipChange;
    
    if (totalChange > 2) return 'positive';
    if (totalChange < -2) return 'negative';
    if (Math.abs(totalChange) > 4) return 'complex';
    return 'flat';
  }
  
  private calculateTransformationScore(
    stages: CharacterEvolution['developmentStages']
  ): number {
    if (stages.length < 2) return 0;
    
    let totalChange = 0;
    
    for (let i = 1; i < stages.length; i++) {
      const prev = stages[i - 1];
      const curr = stages[i];
      
      const conflictChange = Math.abs(
        curr.conflicts.length - prev.conflicts.length
      );
      const relationshipChange = Math.abs(
        curr.relationships.length - prev.relationships.length
      );
      
      totalChange += conflictChange + relationshipChange;
    }
    
    // تطبيع الدرجة (0-10)
    return Math.min(10, totalChange / stages.length);
  }
  
  /**
   * تتبع تقدم الصراعات
   */
  trackConflictProgression(
    network: ConflictNetwork,
    timeline: TimelineEvent[]
  ): Map<string, ConflictProgression> {
    const progressionMap = new Map<string, ConflictProgression>();
    
    for (const [confId, conflict] of network.conflicts) {
      const phaseTransitions: ConflictProgression['phaseTransitions'] = [];
      const intensityProgression: number[] = [];
      
      // تتبع تحولات المراحل من اللقطات
      let previousPhase: ConflictPhase | null = null;
      
      for (const snapshot of network.snapshots) {
        if (!snapshot.networkState.conflicts?.has(confId)) continue;
        
        const confState = snapshot.networkState.conflicts.get(confId);
        if (!confState) continue;
        
        intensityProgression.push(confState.strength);
        
        if (previousPhase !== null && confState.phase !== previousPhase) {
          // البحث عن المحفز من الجدول الزمني
          const catalyst = timeline.find(
            event => 
              event.timestamp.getTime() === snapshot.timestamp.getTime() &&
              event.involvedEntities.conflicts?.includes(confId)
          )?.description || 'Unknown catalyst';
          
          phaseTransitions.push({
            timestamp: snapshot.timestamp,
            fromPhase: previousPhase,
            toPhase: confState.phase,
            catalyst
          });
        }
        
        previousPhase = confState.phase;
      }
      
      // حساب احتمالية الحل
      const resolutionProbability = this.calculateResolutionProbability(
        conflict,
        phaseTransitions
      );
      
      // حساب خطر الركود
      const stagnationRisk = this.calculateStagnationRisk(
        intensityProgression,
        phaseTransitions
      );
      
      progressionMap.set(confId, {
        conflictId: confId,
        conflictName: conflict.name,
        phaseTransitions,
        intensityProgression,
        resolutionProbability,
        stagnationRisk
      });
    }
    
    return progressionMap;
  }
  
  private calculateResolutionProbability(
    conflict: Conflict,
    transitions: ConflictProgression['phaseTransitions']
  ): number {
    // عوامل تزيد من احتمالية الحل
    let probability = 0.5; // قاعدة
    
    // المرحلة الحالية
    if (conflict.phase === ConflictPhase.RESOLUTION) {
      probability = 0.95;
    } else if (conflict.phase === ConflictPhase.DEESCALATING) {
      probability = 0.75;
    } else if (conflict.phase === ConflictPhase.AFTERMATH) {
      probability = 1.0;
    } else if (conflict.phase === ConflictPhase.CLIMAX) {
      probability = 0.6;
    } else if (conflict.phase === ConflictPhase.LATENT) {
      probability = 0.2;
    }
    
    // عدد التحولات (المزيد من التطور يزيد الاحتمالية)
    const transitionBonus = Math.min(0.3, transitions.length * 0.05);
    probability += transitionBonus;
    
    return Math.max(0, Math.min(1, probability));
  }
  
  private calculateStagnationRisk(
    intensityProgression: number[],
    transitions: ConflictProgression['phaseTransitions']
  ): number {
    if (intensityProgression.length < 3) return 0.5;
    
    // حساب التباين في الشدة
    const variance = this.calculateVariance(intensityProgression);
    
    // قلة التحولات = خطر ركود أعلى
    const transitionFactor = transitions.length === 0 ? 0.8 : 
                            transitions.length < 2 ? 0.5 : 0.2;
    
    // تباين منخفض = ركود
    const varianceFactor = variance < 1 ? 0.7 : 
                          variance < 3 ? 0.4 : 0.1;
    
    const risk = (transitionFactor + varianceFactor) / 2;
    
    return Math.max(0, Math.min(1, risk));
  }
}

/**
 * محرك التكامل الحلقي
 */
class EpisodicIntegrationEngine {
  /**
   * إنشاء هيكل السلسلة
   */
  createSeriesStructure(
    network: ConflictNetwork,
    targetEpisodesPerSeason: number = 10
  ): SeriesStructure {
    const numConflicts = network.conflicts.size;
    
    // تقدير عدد الحلقات بناءً على الصراعات
    // افتراض: 2-3 صراعات لكل حلقة
    const estimatedEpisodes = Math.ceil(numConflicts / 2.5);
    
    const totalEpisodes = Math.max(
      targetEpisodesPerSeason,
      estimatedEpisodes
    );
    
    const totalSeasons = Math.ceil(totalEpisodes / targetEpisodesPerSeason);
    
    return {
      totalSeasons,
      episodesPerSeason: targetEpisodesPerSeason,
      totalEpisodes,
      recommendedRuntime: 45 // دقيقة افتراضية
    };
  }
  
  /**
   * توزيع الصراعات عبر الحلقات
   */
  distributeConflicts(
    network: ConflictNetwork,
    structure: SeriesStructure
  ): Map<string, EpisodeAssignment> {
    const assignments = new Map<string, EpisodeAssignment>();
    const conflicts = Array.from(network.conflicts.values());
    
    // ترتيب الصراعات حسب الأهمية (الشدة)
    conflicts.sort((a, b) => b.strength - a.strength);
    
    let currentEpisode = 1;
    
    for (const conflict of conflicts) {
      const episodes: number[] = [];
      
      // توزيع الصراع على 2-4 حلقات بناءً على شدته
      const episodeSpan = Math.ceil(conflict.strength / 3);
      
      for (let i = 0; i < episodeSpan; i++) {
        if (currentEpisode <= structure.totalEpisodes) {
          episodes.push(currentEpisode);
          currentEpisode++;
        }
      }
      
      // إذا وصلنا لنهاية السلسلة، نبدأ من جديد
      if (currentEpisode > structure.totalEpisodes) {
        currentEpisode = 1;
      }
      
      assignments.set(conflict.id, {
        conflictId: conflict.id,
        episodes,
        distributionQuality: this.evaluateDistributionQuality(episodes)
      });
    }
    
    return assignments;
  }
  
  private evaluateDistributionQuality(episodes: number[]): number {
    if (episodes.length === 0) return 0;
    if (episodes.length === 1) return 1;
    
    // التوزيع الجيد = فترات متساوية بين الحلقات
    const gaps: number[] = [];
    for (let i = 1; i < episodes.length; i++) {
      gaps.push(episodes[i] - episodes[i - 1]);
    }
    
    const avgGap = gaps.reduce((sum, gap) => sum + gap, 0) / gaps.length;
    const variance = this.calculateVariance(gaps);
    
    // قلة التباين = جودة أعلى
    const quality = 1 / (1 + variance);
    
    return Math.max(0, Math.min(1, quality));
  }
  
  private calculateVariance(values: number[]): number {
    if (values.length === 0) return 0;
    
    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
    const squaredDiffs = values.map(val => Math.pow(val - mean, 2));
    return squaredDiffs.reduce((sum, val) => sum + val, 0) / values.length;
  }
  
  /**
   * إنشاء تفاصيل المواسم
   */
  createSeasonBreakdown(
    network: ConflictNetwork,
    structure: SeriesStructure,
    assignments: Map<string, EpisodeAssignment>
  ): Map<number, SeasonDetails> {
    const seasonMap = new Map<number, SeasonDetails>();
    
    for (let s = 1; s <= structure.totalSeasons; s++) {
      const startEpisode = (s - 1) * structure.episodesPerSeason + 1;
      const endEpisode = Math.min(
        s * structure.episodesPerSeason,
        structure.totalEpisodes
      );
      
      // الحلقات في هذا الموسم
      const episodes: Episode[] = [];
      const seasonConflicts = new Set<string>();
      
      for (let e = startEpisode; e <= endEpisode; e++) {
        const episodeConflicts: string[] = [];
        const featuredCharacters = new Set<string>();
        
        // جمع الصراعات المخصصة لهذه الحلقة
        for (const [conflictId, assignment] of assignments) {
          if (assignment.episodes.includes(e)) {
            episodeConflicts.push(conflictId);
            seasonConflicts.add(conflictId);
            
            const conflict = network.conflicts.get(conflictId);
            if (conflict) {
              conflict.involvedCharacters.forEach(charId => 
                featuredCharacters.add(charId)
              );
            }
          }
        }
        
        // تحديد الشدة المقدرة
        let estimatedIntensity = 0;
        for (const confId of episodeConflicts) {
          const conflict = network.conflicts.get(confId);
          if (conflict) {
            estimatedIntensity += conflict.strength;
          }
        }
        estimatedIntensity = Math.min(10, estimatedIntensity / episodeConflicts.length);
        
        // تحديد الوظيفة السردية
        const relativePosition = (e - startEpisode) / (endEpisode - startEpisode);
        const narrativeFunction = 
          relativePosition < 0.3 ? 'setup' :
          relativePosition < 0.7 ? 'development' :
          relativePosition < 0.9 ? 'climax' : 'resolution';
        
        episodes.push({
          episodeNumber: e,
          seasonNumber: s,
          title: `Episode ${e}`,
          assignedConflicts: episodeConflicts,
          featuredCharacters: Array.from(featuredCharacters),
          estimatedIntensity,
          narrativeFunction
        });
      }
      
      seasonMap.set(s, {
        seasonNumber: s,
        seasonTitle: `Season ${s}`,
        episodes,
        majorConflicts: Array.from(seasonConflicts),
        seasonArc: `Season ${s} arc description`,
        cliffhanger: s < structure.totalSeasons 
          ? `Cliffhanger for Season ${s}` 
          : undefined
      });
    }
    
    return seasonMap;
  }
  
  /**
   * تقييم توازن التوزيع الحلقي
   */
  evaluateEpisodicBalance(
    network: ConflictNetwork,
    seasonBreakdown: Map<number, SeasonDetails>
  ): EpisodicBalanceReport {
    const allEpisodes: Episode[] = [];
    for (const season of seasonBreakdown.values()) {
      allEpisodes.push(...season.episodes);
    }
    
    // توزيع الصراعات
    const conflictsPerEpisode = allEpisodes.map(ep => 
      ep.assignedConflicts.length
    );
    const conflictDistributionScore = 1 - this.calculateVariance(
      conflictsPerEpisode
    ) / Math.max(...conflictsPerEpisode);
    
    // توازن ظهور الشخصيات
    const charAppearances = new Map<string, number>();
    for (const episode of allEpisodes) {
      for (const charId of episode.featuredCharacters) {RetryAContinueEdittypescript        charAppearances.set(
          charId,
          (charAppearances.get(charId) || 0) + 1
        );
      }
    }
    
    const appearanceCounts = Array.from(charAppearances.values());
    const characterAppearanceBalance = appearanceCounts.length > 0
      ? 1 - this.calculateVariance(appearanceCounts) / 
        Math.max(...appearanceCounts)
      : 0;
    
    // تدفق الشدة
    const intensities = allEpisodes.map(ep => ep.estimatedIntensity);
    const intensityFlowScore = this.evaluateIntensityFlow(intensities);
    
    // التوازن الكلي
    const overallBalance = (
      conflictDistributionScore * 0.4 +
      characterAppearanceBalance * 0.3 +
      intensityFlowScore * 0.3
    );
    
    // التوصيات
    const recommendations = this.generateBalanceRecommendations({
      conflictDistributionScore,
      characterAppearanceBalance,
      intensityFlowScore,
      overallBalance
    });
    
    return {
      overallBalance,
      conflictDistributionScore,
      characterAppearanceBalance,
      intensityFlowScore,
      recommendations
    };
  }
  
  private evaluateIntensityFlow(intensities: number[]): number {
    if (intensities.length < 2) return 1;
    
    // تدفق جيد = تصاعد تدريجي مع قمم وقيعان
    let score = 1.0;
    
    // التحقق من وجود تنوع
    const variance = this.calculateVariance(intensities);
    if (variance < 1) {
      score -= 0.3; // تدفق مسطح = سيء
    }
    
    // التحقق من التصاعد العام
    const firstHalf = intensities.slice(0, Math.floor(intensities.length / 2));
    const secondHalf = intensities.slice(Math.floor(intensities.length / 2));
    
    const firstHalfAvg = firstHalf.reduce((sum, val) => sum + val, 0) / firstHalf.length;
    const secondHalfAvg = secondHalf.reduce((sum, val) => sum + val, 0) / secondHalf.length;
    
    if (secondHalfAvg > firstHalfAvg) {
      score += 0.2; // تصاعد جيد
    }
    
    return Math.max(0, Math.min(1, score));
  }
  
  private generateBalanceRecommendations(metrics: {
    conflictDistributionScore: number;
    characterAppearanceBalance: number;
    intensityFlowScore: number;
    overallBalance: number;
  }): string[] {
    const recommendations: string[] = [];
    
    if (metrics.conflictDistributionScore < 0.6) {
      recommendations.push(
        'Consider redistributing conflicts more evenly across episodes'
      );
    }
    
    if (metrics.characterAppearanceBalance < 0.5) {
      recommendations.push(
        'Some characters appear too frequently or too rarely - balance character screen time'
      );
    }
    
    if (metrics.intensityFlowScore < 0.5) {
      recommendations.push(
        'Intensity flow needs improvement - add more variation and build-up'
      );
    }
    
    if (metrics.overallBalance >= 0.8) {
      recommendations.push(
        'Excellent episodic balance - maintain current structure'
      );
    }
    
    return recommendations;
  }
  
  private calculateVariance(values: number[]): number {
    if (values.length === 0) return 0;
    
    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
    const squaredDiffs = values.map(val => Math.pow(val - mean, 2));
    return squaredDiffs.reduce((sum, val) => sum + val, 0) / values.length;
  }
}

/**
 * المحطة الخامسة: التحليل الديناميكي والرمزي والأسلوبي
 */
class Station5DynamicSymbolicStylistic extends BaseStation<Station5Input, Station5Output> {
  private dynamicEngine: DynamicAnalysisEngine;
  private episodicEngine: EpisodicIntegrationEngine;
  
  constructor(
    config: StationConfig,
    geminiService: GeminiService,
    resultSelector: AIResultSelector
  ) {
    super(config, geminiService, resultSelector);
    this.dynamicEngine = new DynamicAnalysisEngine();
    this.episodicEngine = new EpisodicIntegrationEngine();
  }
  
  protected async process(input: Station5Input): Promise<Station5Output> {
    const startTime = Date.now();
    
    // 1. التحليل الديناميكي
    const dynamicAnalysisResults = await this.performDynamicAnalysis(
      input.conflictNetwork
    );
    
    // 2. التكامل الحلقي
    const episodicIntegrationResults = await this.performEpisodicIntegration(
      input.conflictNetwork
    );
    
    // 3. التحليل الرمزي (بالذكاء الاصطناعي)
    const symbolicAnalysisResults = await this.performSymbolicAnalysis(
      input.fullText
    );
    
    // 4. التحليل الأسلوبي (بالذكاء الاصطناعي)
    const stylisticAnalysisResults = await this.performStylisticAnalysis(
      input.fullText
    );
    
    const analysisTime = Date.now() - startTime;
    
    return {
      dynamicAnalysisResults,
      episodicIntegrationResults,
      symbolicAnalysisResults,
      stylisticAnalysisResults,
      metadata: {
        analysisTimestamp: new Date(),
        status: 'Success',
        analysisTime
      }
    };
  }
  
  private async performDynamicAnalysis(
    network: ConflictNetwork
  ): Promise<DynamicAnalysisResults> {
    // بناء الجدول الزمني
    const eventTimeline = this.dynamicEngine.constructEventTimeline(network);
    
    // تحليل التطور
    const networkEvolutionAnalysis = this.dynamicEngine.analyzeNetworkEvolution(
      network,
      eventTimeline
    );
    
    // تتبع تطور الشخصيات
    const characterDevelopmentTracking = 
      this.dynamicEngine.trackCharacterDevelopment(
        network,
        eventTimeline
      );
    
    // تتبع تقدم الصراعات
    const conflictProgressionTracking = 
      this.dynamicEngine.trackConflictProgression(
        network,
        eventTimeline
      );
    
    return {
      eventTimeline,
      networkEvolutionAnalysis,
      characterDevelopmentTracking,
      conflictProgressionTracking
    };
  }
  
  private async performEpisodicIntegration(
    network: ConflictNetwork
  ): Promise<EpisodicIntegrationResults> {
    // إنشاء هيكل السلسلة
    const seriesStructure = this.episodicEngine.createSeriesStructure(
      network,
      10 // 10 حلقات لكل موسم افتراضياً
    );
    
    // توزيع الصراعات
    const episodeDistribution = this.episodicEngine.distributeConflicts(
      network,
      seriesStructure
    );
    
    // إنشاء تفاصيل المواسم
    const seasonBreakdown = this.episodicEngine.createSeasonBreakdown(
      network,
      seriesStructure,
      episodeDistribution
    );
    
    // تقييم التوازن
    const balanceReport = this.episodicEngine.evaluateEpisodicBalance(
      network,
      seasonBreakdown
    );
    
    return {
      seriesStructure,
      seasonBreakdown,
      episodeDistribution,
      balanceReport
    };
  }
  
  private async performSymbolicAnalysis(
    fullText: string
  ): Promise<SymbolicAnalysisResults> {
    const prompt = `
بناءً على النص السردي المرفق، قم بتحليل وتحديد ما يلي:

1. **key_symbols**: قائمة بـ 3-5 رموز أو أشياء أو أماكن متكررة أو ذات أهمية رمزية واضحة في النص. 
   لكل رمز، قدم:
   - "symbol": اسم الرمز
   - "interpretation": تفسير موجز لمعناه المحتمل
   - "frequency": تقدير لعدد مرات الظهور (رقم)
   - "contextual_meanings": قائمة بالمعاني المختلفة في سياقات مختلفة

2. **recurring_motifs**: قائمة بـ 2-3 أفكار أو أنماط أو مواقف متكررة (motifs) تظهر في النص.
   لكل motif:
   - "motif": وصف الـ motif
   - "occurrences": عدد مرات الظهور
   - "narrative_function": وظيفته السردية

3. **central_themes_hinted_by_symbols**: استنتاج موجز حول الثيمات الرئيسية التي قد تشير إليها هذه الرموز والأنماط (قائمة نصوص).

4. **symbolic_networks**: شبكات رمزية (قائمة من القواميس)، كل قاموس يحتوي على:
   - "primary_symbol": الرمز الأساسي
   - "related_symbols": الرموز المرتبطة (قائمة)
   - "thematic_connection": الصلة الموضوعية

5. **depth_score**: درجة عمق الاستخدام الرمزي (0-10)

6. **consistency_score**: درجة اتساق الاستخدام الرمزي (0-10)

أعد الإجابة **حصرياً** بتنسيق JSON صالح يحتوي على المفاتيح المذكورة أعلاه.
    `;
    
    const results = await this.geminiService.generateMultiModel<SymbolicAnalysisResults>({
      prompt,
      context: fullText.substring(0, 30000),
      model: GeminiModel.PRO,
      temperature: 0.7
    });
    
    const selected = this.resultSelector.selectBest(results, {
      preferredModels: [GeminiModel.PRO, GeminiModel.FLASH],
      validationFunction: (result) => 
        result.keySymbols &&
        Array.isArray(result.keySymbols) &&
        result.recurringMotifs &&
        Array.isArray(result.recurringMotifs)
    });
    
    return selected?.content || this.getDefaultSymbolicResults();
  }
  
  private async performStylisticAnalysis(
    fullText: string
  ): Promise<StylisticAnalysisResults> {
    const prompt = `
بناءً على النص السردي المرفق، قم بتحليل وتقديم تقييم للعناصر الأسلوبية التالية:

1. **overall_tone_assessment**: تقييم للنبرة العامة للنص
   - "primary_tone": النبرة الأساسية
   - "secondary_tones": نبرات ثانوية (قائمة)
   - "tone_consistency": درجة اتساق النبرة (0-10)
   - "explanation": شرح موجز

2. **language_complexity**: تقييم لمدى تعقيد اللغة
   - "level": مستوى التعقيد ("simple", "moderate", "complex", "highly_complex")
   - "readability_score": درجة القراءة (0-10)
   - "vocabulary_richness": ثراء المفردات (0-10)

3. **pacing_impression**: انطباع عام حول إيقاع السرد
   - "overall_pacing": الإيقاع العام ("very_slow", "slow", "balanced", "fast", "very_fast")
   - "pacing_variation": درجة التنوع في الإيقاع (0-10)
   - "scene_length_distribution": توزيع أطوال المشاهد (قائمة أرقام تقريبية)

4. **dialogue_style**: ملاحظات حول أسلوب الحوار
   - "characterization": درجة تمييز الشخصيات من خلال الحوار (نص)
   - "naturalness": طبيعية الحوار (0-10)
   - "effectiveness": فعالية الحوار في تطوير القصة (0-10)
   - "distinctiveness": تميز أصوات الشخصيات (0-10)

5. **descriptive_richness**: مدى ثراء الوصف
   - "visual_detail_level": مستوى التفاصيل البصرية (0-10)
   - "sensory_engagement": درجة الانخراط الحسي (0-10)
   - "atmospheric_quality": جودة الأجواء (0-10)

6. **stylistic_consistency_impression**: انطباع عام حول مدى اتساق الأسلوب
   - "consistency_score": درجة الاتساق (0-10)
   - "deviations": قائمة من الانحرافات الملحوظة (إن وجدت)، كل انحراف قاموس بـ:
     * "location": الموقع التقريبي
     * "type": نوع الانحراف
     * "description": وصف الانحراف

أعد الإجابة **حصرياً** بتنسيق JSON صالح يحتوي على المفاتيح المذكورة أعلاه.
    `;
    
    const results = await this.geminiService.generateMultiModel<StylisticAnalysisResults>({
      prompt,
      context: fullText.substring(0, 30000),
      model: GeminiModel.PRO,
      temperature: 0.6
    });
    
    const selected = this.resultSelector.selectBest(results, {
      preferredModels: [GeminiModel.PRO, GeminiModel.FLASH],
      validationFunction: (result) => 
        result.overallToneAssessment &&
        result.languageComplexity &&
        result.pacingImpression
    });
    
    const stylisticResults = selected?.content || this.getDefaultStylisticResults();
    
    // إضافة تحليل TextBlob إن أمكن (اختياري)
    try {
      // هذا يتطلب مكتبة TextBlob أو مكتبة مشابهة
      // للتبسيط، نتركها كخيار إضافي
      // stylisticResults.textBlobSentiment = await this.analyzeWithTextBlob(fullText);
    } catch (error) {
      console.warn('TextBlob analysis skipped:', error);
    }
    
    return stylisticResults;
  }
  
  private getDefaultSymbolicResults(): SymbolicAnalysisResults {
    return {
      keySymbols: [],
      recurringMotifs: [],
      centralThemesHintedBySymbols: [],
      symbolicNetworks: [],
      depthScore: 0,
      consistencyScore: 0
    };
  }
  
  private getDefaultStylisticResults(): StylisticAnalysisResults {
    return {
      overallToneAssessment: {
        primaryTone: 'Unknown',
        secondaryTones: [],
        toneConsistency: 0,
        explanation: 'Analysis failed'
      },
      languageComplexity: {
        level: 'moderate',
        readabilityScore: 5,
        vocabularyRichness: 5
      },
      pacingImpression: {
        overallPacing: 'balanced',
        pacingVariation: 5,
        sceneLengthDistribution: []
      },
      dialogueStyle: {
        characterization: 'Unknown',
        naturalness: 5,
        effectiveness: 5,
        distinctiveness: 5
      },
      descriptiveRichness: {
        visualDetailLevel: 5,
        sensoryEngagement: 5,
        atmosphericQuality: 5
      },
      stylisticConsistencyImpression: {
        consistencyScore: 5,
        deviations: []
      }
    };
  }
  
  protected extractRequiredData(input: Station5Input): any {
    return {
      network: input.conflictNetwork,
      station4Output: input.station4Output,
      fullText: input.fullText
    };
  }
  
  protected getErrorFallback(): Station5Output {
    return {
      dynamicAnalysisResults: {
        eventTimeline: [],
        networkEvolutionAnalysis: {
          overallGrowthRate: 0,
          complexityProgression: [],
          densityProgression: [],
          criticalTransitionPoints: [],
          stabilityMetrics: {
            structuralStability: 0,
            characterStability: 0,
            conflictStability: 0
          }
        },
        characterDevelopmentTracking: new Map(),
        conflictProgressionTracking: new Map()
      },
      episodicIntegrationResults: {
        seriesStructure: {
          totalSeasons: 0,
          episodesPerSeason: 0,
          totalEpisodes: 0,
          recommendedRuntime: 0
        },
        seasonBreakdown: new Map(),
        episodeDistribution: new Map(),
        balanceReport: {
          overallBalance: 0,
          conflictDistributionScore: 0,
          characterAppearanceBalance: 0,
          intensityFlowScore: 0,
          recommendations: ['Analysis failed']
        }
      },
      symbolicAnalysisResults: this.getDefaultSymbolicResults(),
      stylisticAnalysisResults: this.getDefaultStylisticResults(),
      metadata: {
        analysisTimestamp: new Date(),
        status: 'Failed',
        analysisTime: 0
      }
    };
  }
}

المحطة السادسة: التشخيص والعلاج
typescript// stations/station6/station6-diagnostics-treatment.ts

interface Station6Input {
  conflictNetwork: ConflictNetwork;
  station5Output: Station5Output;
}

interface Station6Output {
  diagnosticsReport: NetworkDiagnosticsReport;
  treatmentRecommendations: TreatmentRecommendations;
  advancedEfficiencyMetrics: AdvancedEfficiencyMetrics;
  metadata: {
    analysisTimestamp: Date;
    status: 'Success' | 'Partial' | 'Failed';
    analysisTime: number;
  };
}

interface NetworkDiagnosticsReport {
  structuralIssues: StructuralIssue[];
  isolatedCharacters: IsolatedCharacterIssue[];
  abandonedConflicts: AbandonedConflictIssue[];
  overloadedCharacters: OverloadedCharacterIssue[];
  weakConnections: WeakConnectionIssue[];
  redundancyIssues: RedundancyIssue[];
  overallHealthScore: number;
  criticalityLevel: 'healthy' | 'minor_issues' | 'moderate_issues' | 
                     'major_issues' | 'critical';
}

interface StructuralIssue {
  type: 'disconnected_components' | 'bottleneck_character' | 
        'dead_end_conflict' | 'circular_dependency' | 'other';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  affectedEntities: {
    characters?: string[];
    relationships?: string[];
    conflicts?: string[];
  };
  potentialImpact: string;
}

interface IsolatedCharacterIssue {
  characterId: string;
  characterName: string;
  isolationType: 'completely_isolated' | 'weakly_connected' | 
                 'relationship_only' | 'conflict_only';
  connectionCount: number;
  suggestedConnections: string[];
}

interface AbandonedConflictIssue {
  conflictId: string;
  conflictName: string;
  issueType: 'no_progression' | 'stuck_in_phase' | 'insufficient_involvement';
  lastActivity: Date | null;
  durationInCurrentPhase: number; // days
  suggestedActions: string[];
}

interface OverloadedCharacterIssue {
  characterId: string;
  characterName: string;
  involvementScore: number;
  conflictCount: number;
  relationshipCount: number;
  suggestedRedistribution: string[];
}

interface WeakConnectionIssue {
  connectionType: 'relationship' | 'conflict_link';
  connectionId: string;
  entities: string[];
  strengthScore: number;
  reasonForWeakness: string;
  suggestedStrengthening: string;
}

interface RedundancyIssue {
  type: 'duplicate_relationship' | 'overlapping_conflict';
  entities: string[];
  similarityScore: number;
  suggestedMerge: string;
}

interface TreatmentRecommendations {
  prioritizedActions: PrioritizedAction[];
  quickFixes: QuickFix[];
  structuralRevisions: StructuralRevision[];
  characterDevelopmentSuggestions: CharacterDevelopmentSuggestion[];
  conflictEnhancementStrategies: ConflictEnhancementStrategy[];
  consolidatedSummary: string;
}

interface PrioritizedAction {
  priority: 'critical' | 'high' | 'medium' | 'low';
  actionType: 'add' | 'remove' | 'modify' | 'merge';
  targetEntity: {
    type: 'character' | 'relationship' | 'conflict';
    id: string;
    name: string;
  };
  description: string;
  expectedImpact: string;
  effort: 'low' | 'medium' | 'high';
}

interface QuickFix {
  issueId: string;
  fixDescription: string;
  implementation: string;
  estimatedTime: string;
}

interface StructuralRevision {
  revisionType: 'add_bridge_character' | 'merge_conflicts' | 
                'split_overloaded_character' | 'create_subplot' | 'other';
  rationale: string;
  steps: string[];
  affectedElements: string[];
  expectedOutcome: string;
}

interface CharacterDevelopmentSuggestion {
  characterId: string;
  characterName: string;
  currentState: string;
  suggestedArc: string;
  keyMilestones: string[];
  relationshipsToAdd: string[];
  conflictsToInvolve: string[];
}

interface ConflictEnhancementStrategy {
  conflictId: string;
  conflictName: string;
  currentWeakness: string;
  enhancementApproach: string;
  stakesEscalation: string;
  charactersToInvolve: string[];
  phaseProgression: string;
}

interface AdvancedEfficiencyMetrics {
  postDiagnosticScore: number;
  improvementPotential: number;
  treatmentFeasibility: number;
  expectedOutcome: {
    optimisticScore: number;
    realisticScore: number;
    pessimisticScore: number;
  };
  riskAssessment: {
    implementationRisks: string[];
    narrativeCoherenceRisk: number;
    characterConsistencyRisk: number;
  };
}

/**
 * وحدة تشخيص الشبكة
 */
class NetworkDiagnostics {
  /**
   * تشغيل جميع التشخيصات
   */
  runAllDiagnostics(network: ConflictNetwork): NetworkDiagnosticsReport {
    const structuralIssues = this.diagnoseStructuralIssues(network);
    const isolatedCharacters = this.findIsolatedCharacters(network);
    const abandonedConflicts = this.findAbandonedConflicts(network);
    const overloadedCharacters = this.findOverloadedCharacters(network);
    const weakConnections = this.findWeakConnections(network);
    const redundancyIssues = this.findRedundancyIssues(network);
    
    // حساب درجة الصحة الكلية
    const overallHealthScore = this.calculateHealthScore({
      structuralIssues,
      isolatedCharacters,
      abandonedConflicts,
      overloadedCharacters,
      weakConnections,
      redundancyIssues
    });
    
    const criticalityLevel = this.determineCriticalityLevel(overallHealthScore);
    
    return {
      structuralIssues,
      isolatedCharacters,
      abandonedConflicts,
      overloadedCharacters,
      weakConnections,
      redundancyIssues,
      overallHealthScore,
      criticalityLevel
    };
  }
  
  /**
   * تشخيص المشاكل الهيكلية
   */
  private diagnoseStructuralIssues(
    network: ConflictNetwork
  ): StructuralIssue[] {
    const issues: StructuralIssue[] = [];
    
    // فحص المكونات المنفصلة
    const components = this.findDisconnectedComponents(network);
    if (components.length > 1) {
      issues.push({
        type: 'disconnected_components',
        severity: 'high',
        description: `Network has ${components.length} disconnected components`,
        affectedEntities: {
          characters: components.flat()
        },
        potentialImpact: 'Story may feel fragmented with unrelated plot lines'
      });
    }
    
    // فحص الشخصيات العنق الزجاجي (Bottleneck)
    const bottlenecks = this.findBottleneckCharacters(network);
    for (const charId of bottlenecks) {
      const char = network.characters.get(charId);
      issues.push({
        type: 'bottleneck_character',
        severity: 'medium',
        description: `Character '${char?.name}' is a critical bottleneck`,
        affectedEntities: { characters: [charId] },
        potentialImpact: 'Removing this character would fragment the network'
      });
    }
    
    // فحص الصراعات المسدودة
    const deadEndConflicts = this.findDeadEndConflicts(network);
    for (const confId of deadEndConflicts) {
      const conf = network.conflicts.get(confId);
      issues.push({
        type: 'dead_end_conflict',
        severity: 'medium',
        description: `Conflict '${conf?.name}' has no clear progression path`,
        affectedEntities: { conflicts: [confId] },
        potentialImpact: 'Conflict may feel unresolved or purposeless'
      });
    }
    
    return issues;
  }
  
  private findDisconnectedComponents(
    network: ConflictNetwork
  ): string[][] {
    const visited = new Set<string>();
    const components: string[][] = [];
    
    const dfs = (charId: string, component: string[]) => {
      if (visited.has(charId)) return;
      visited.add(charId);
      component.push(charId);
      
      // زيارة الشخصيات المرتبطة
      for (const rel of network.relationships.values()) {
        if (rel.source === charId && !visited.has(rel.target)) {
          dfs(rel.target, component);
        } else if (rel.target === charId && !visited.has(rel.source)) {
          dfs(rel.source, component);
        }
      }
    };
    
    for (const charId of network.characters.keys()) {
      if (!visited.has(charId)) {
        const component: string[] = [];
        dfs(charId, component);
        components.push(component);
      }
    }
    
    return components;
  }
  
  private findBottleneckCharacters(network: ConflictNetwork): string[] {
    const bottlenecks: string[] = [];
    
    for (const charId of network.characters.keys()) {
      // حساب Articulation Point (نقطة المفصل)
      if (this.isArticulationPoint(network, charId)) {
        bottlenecks.push(charId);
      }
    }
    
    return bottlenecks;
  }
  
  private isArticulationPoint(
    network: ConflictNetwork,
    charId: string
  ): boolean {
    // خوارزمية بسيطة للتحقق من نقاط المفصل
    // في شبكة حقيقية، يجب استخدام خوارزمية Tarjan
    
    const componentsBefore = this.findDisconnectedComponents(network).length;
    
    // محاكاة إزالة الشخصية
    const tempNetwork = this.createNetworkWithoutCharacter(network, charId);
    const componentsAfter = this.findDisconnectedComponents(tempNetwork).length;
    
    return componentsAfter > componentsBefore;
  }
  
  private createNetworkWithoutCharacter(
    network: ConflictNetwork,
    charId: string
  ): ConflictNetwork {
    const tempNetwork: ConflictNetwork = {
      ...network,
      characters: new Map(network.characters),
      relationships: new Map(network.relationships),
      conflicts: new Map(network.conflicts),
      snapshots: [],
      metadata: {},
      addCharacter: () => {},
      addRelationship: () => {},
      addConflict: () => {},
      createSnapshot: () => {}
    };
    
    tempNetwork.characters.delete(charId);
    
    // إزالة العلاقات المرتبطة
    for (const [relId, rel] of network.relationships) {
      if (rel.source === charId || rel.target === charId) {
        tempNetwork.relationships.


tempNetwork.relationships.delete(relId);
      }
    }
    
    return tempNetwork;
  }
  
  private findDeadEndConflicts(network: ConflictNetwork): string[] {
    const deadEnds: string[] = [];
    
    for (const [confId, conflict] of network.conflicts) {
      // صراع مسدود إذا كان في مرحلة راكدة طويلة أو لا توجد له علاقات داعمة
      const isStagnant = conflict.phase === ConflictPhase.STALEMATE || 
                        conflict.phase === ConflictPhase.LATENT;
      
      const hasNoRelatedRelationships = !conflict.relatedRelationships || 
                                       conflict.relatedRelationships.length === 0;
      
      const hasMinimalCharacters = conflict.involvedCharacters.length < 2;
      
      if (isStagnant && (hasNoRelatedRelationships || hasMinimalCharacters)) {
        deadEnds.push(confId);
      }
    }
    
    return deadEnds;
  }
  
  /**
   * تحديد الشخصيات المعزولة
   */
  private findIsolatedCharacters(network: ConflictNetwork): IsolatedCharacterIssue[] {
    const issues: IsolatedCharacterIssue[] = [];
    
    for (const [charId, char] of network.characters) {
      // حساب عدد الاتصالات
      let relationshipCount = 0;
      let conflictCount = 0;
      
      // عد العلاقات
      for (const rel of network.relationships.values()) {
        if (rel.source === charId || rel.target === charId) {
          relationshipCount++;
        }
      }
      
      // عد الصراعات
      for (const conflict of network.conflicts.values()) {
        if (conflict.involvedCharacters.includes(charId)) {
          conflictCount++;
        }
      }
      
      const totalConnections = relationshipCount + conflictCount;
      
      // تحديد نوع العزلة
      let isolationType: IsolatedCharacterIssue['isolationType'] = 'completely_isolated';
      if (totalConnections === 0) {
        isolationType = 'completely_isolated';
      } else if (totalConnections <= 2) {
        isolationType = 'weakly_connected';
      } else if (conflictCount === 0) {
        isolationType = 'relationship_only';
      } else if (relationshipCount === 0) {
        isolationType = 'conflict_only';
      } else {
        continue; // ليست معزولة
      }
      
      // اقتراح اتصالات
      const suggestedConnections = this.suggestConnectionsForCharacter(
        network, charId, char
      );
      
      issues.push({
        characterId: charId,
        characterName: char.name,
        isolationType,
        connectionCount: totalConnections,
        suggestedConnections
      });
    }
    
    return issues;
  }
  
  private suggestConnectionsForCharacter(
    network: ConflictNetwork,
    charId: string,
    char: Character
  ): string[] {
    const suggestions: string[] = [];
    
    // اقتراح الاتصال بالشخصيات ذات السمات المشابهة
    const similarChars = this.findSimilarCharacters(network, char);
    if (similarChars.length > 0) {
      suggestions.push(`إضافة علاقة مع شخصيات مشابهة: ${similarChars.slice(0, 2).join(', ')}`);
    }
    
    // اقتراح المشاركة في صراعات موجودة
    const relevantConflicts = this.findRelevantConflicts(network, char);
    if (relevantConflicts.length > 0) {
      suggestions.push(`المشاركة في الصراعات: ${relevantConflicts.slice(0, 2).join(', ')}`);
    }
    
    return suggestions;
  }
  
  private findSimilarCharacters(
    network: ConflictNetwork,
    targetChar: Character
  ): string[] {
    const similar: string[] = [];
    
    for (const [charId, char] of network.characters) {
      if (charId === targetChar.id) continue;
      
      // مقارنة بسيطة بناءً على السمات
      const targetTraits = targetChar.profile?.personalityTraits?.toLowerCase() || '';
      const charTraits = char.profile?.personalityTraits?.toLowerCase() || '';
      
      if (this.calculateSimilarity(targetTraits, charTraits) > 0.3) {
        similar.push(char.name);
      }
    }
    
    return similar;
  }
  
  private calculateSimilarity(str1: string, str2: string): number {
    if (!str1 || !str2) return 0;
    
    const words1 = new Set(str1.split(/\s+/));
    const words2 = new Set(str2.split(/\s+/));
    
    const intersection = new Set([...words1].filter(x => words2.has(x)));
    const union = new Set([...words1, ...words2]);
    
    return union.size > 0 ? intersection.size / union.size : 0;
  }
  
  private findRelevantConflicts(
    network: ConflictNetwork,
    char: Character
  ): string[] {
    const relevant: string[] = [];
    
    // البحث عن صراعات تتعلق بأهداف الشخصية أو صفاتها
    const charGoals = char.profile?.motivationsGoals?.toLowerCase() || '';
    
    for (const [confId, conflict] of network.conflicts) {
      const confDesc = conflict.description.toLowerCase();
      
      if (this.calculateSimilarity(charGoals, confDesc) > 0.2) {
        relevant.push(conflict.name);
      }
    }
    
    return relevant;
  }
  
  /**
   * تحديد الصراعات المهجورة
   */
  private findAbandonedConflicts(
    network: ConflictNetwork
  ): AbandonedConflictIssue[] {
    const issues: AbandonedConflictIssue[] = [];
    const now = new Date();
    
    for (const [confId, conflict] of network.conflicts) {
      // تحديد ما إذا كان الصراع مهجوراً
      const lastActivity = conflict.timestamps && conflict.timestamps.length > 0
        ? conflict.timestamps[conflict.timestamps.length - 1]
        : null;
      
      const durationInPhase = lastActivity
        ? Math.floor((now.getTime() - lastActivity.getTime()) / (1000 * 60 * 60 * 24))
        : Number.MAX_SAFE_INTEGER;
      
      let issueType: AbandonedConflictIssue['issueType'] | null = null;
      
      // لا تقدم
      if (!conflict.timestamps || conflict.timestamps.length <= 1) {
        issueType = 'no_progression';
      }
      // عالق في مرحلة
      else if (durationInPhase > 30 && 
               (conflict.phase === ConflictPhase.STALEMATE || 
                conflict.phase === ConflictPhase.LATENT)) {
        issueType = 'stuck_in_phase';
      }
      // مشاركة غير كافية
      else if (conflict.involvedCharacters.length < 2) {
        issueType = 'insufficient_involvement';
      }
      
      if (issueType) {
        const suggestions = this.generateConflictRevivalSuggestions(
          network, conflict, issueType
        );
        
        issues.push({
          conflictId: confId,
          conflictName: conflict.name,
          issueType,
          lastActivity,
          durationInCurrentPhase: durationInPhase,
          suggestedActions: suggestions
        });
      }
    }
    
    return issues;
  }
  
  private generateConflictRevivalSuggestions(
    network: ConflictNetwork,
    conflict: Conflict,
    issueType: AbandonedConflictIssue['issueType']
  ): string[] {
    const suggestions: string[] = [];
    
    switch (issueType) {
      case 'no_progression':
        suggestions.push('إضافة نقاط تحول محورية لتحريك الصراع');
        suggestions.push('تصعيد المخاطر أو تغيير ديناميكية القوى');
        break;
        
      case 'stuck_in_phase':
        suggestions.push(`تحويل الصراع من مرحلة ${conflict.phase.name} إلى مرحلة أكثر ديناميكية`);
        suggestions.push('إدخال عنصر خارجي لكسر الجمود');
        break;
        
      case 'insufficient_involvement':
        suggestions.push('إضافة شخصيات إضافية للصراع');
        suggestions.push('ربط الصراع بعلاقات موجودة في الشبكة');
        break;
    }
    
    return suggestions;
  }
  
  /**
   * تحديد الشخصيات المحملة بشكل زائد
   */
  private findOverloadedCharacters(
    network: ConflictNetwork
  ): OverloadedCharacterIssue[] {
    const issues: OverloadedCharacterIssue[] = [];
    
    // حساب متوسط المشاركة
    const avgConflictsPerChar = network.conflicts.size / 
                               (network.characters.size || 1);
    const avgRelationsPerChar = network.relationships.size * 2 / 
                               (network.characters.size || 1);
    
    for (const [charId, char] of network.characters) {
      let conflictCount = 0;
      let relationshipCount = 0;
      
      // عد الصراعات
      for (const conflict of network.conflicts.values()) {
        if (conflict.involvedCharacters.includes(charId)) {
          conflictCount++;
        }
      }
      
      // عد العلاقات
      for (const rel of network.relationships.values()) {
        if (rel.source === charId || rel.target === charId) {
          relationshipCount++;
        }
      }
      
      // حساب درجة المشاركة
      const involvementScore = (conflictCount / (avgConflictsPerChar || 1)) +
                              (relationshipCount / (avgRelationsPerChar || 1));
      
      // إذا كانت المشاركة أعلى بكثير من المتوسط
      if (involvementScore > 2.5) {
        const suggestions = this.generateLoadReductionSuggestions(
          network, char, conflictCount, relationshipCount
        );
        
        issues.push({
          characterId: charId,
          characterName: char.name,
          involvementScore,
          conflictCount,
          relationshipCount,
          suggestedRedistribution: suggestions
        });
      }
    }
    
    return issues;
  }
  
  private generateLoadReductionSuggestions(
    network: ConflictNetwork,
    char: Character,
    conflictCount: number,
    relationshipCount: number
  ): string[] {
    const suggestions: string[] = [];
    
    if (conflictCount > 5) {
      suggestions.push('توزيع بعض الصراعات على شخصيات ثانوية');
      suggestions.push('دمج الصراعات المتشابهة لتقليل العبء');
    }
    
    if (relationshipCount > 8) {
      suggestions.push('إزالة العلاقات الضعيفة أو غير الأساسية');
      suggestions.push('تبسيط شبكة العلاقات حول هذه الشخصية');
    }
    
    suggestions.push('إنشاء شخصية داعمة لتخفيف بعض المسؤوليات السردية');
    
    return suggestions;
  }
  
  /**
   * تحديد الاتصالات الضعيفة
   */
  private findWeakConnections(
    network: ConflictNetwork
  ): WeakConnectionIssue[] {
    const issues: WeakConnectionIssue[] = [];
    
    // فحص العلاقات الضعيفة
    for (const [relId, rel] of network.relationships) {
      if (rel.strength < 3) {
        const source = network.characters.get(rel.source);
        const target = network.characters.get(rel.target);
        
        issues.push({
          connectionType: 'relationship',
          connectionId: relId,
          entities: [source?.name || rel.source, target?.name || rel.target],
          strengthScore: rel.strength,
          reasonForWeakness: 'علاقة ضعيفة الشدة (< 3)',
          suggestedStrengthening: 'تعميق العلاقة من خلال مشاهد مشتركة أو صراعات متقاطعة'
        });
      }
    }
    
    // فحص روابط الصراعات الضعيفة
    for (const [confId, conflict] of network.conflicts) {
      if (conflict.strength < 4) {
        issues.push({
          connectionType: 'conflict_link',
          connectionId: confId,
          entities: conflict.involvedCharacters.map(id => 
            network.characters.get(id)?.name || id
          ),
          strengthScore: conflict.strength,
          reasonForWeakness: 'صراع منخفض الشدة (< 4)',
          suggestedStrengthening: 'زيادة المخاطر وتصعيد التوتر في هذا الصراع'
        });
      }
    }
    
    return issues;
  }
  
  /**
   * تحديد قضايا التكرار
   */
  private findRedundancyIssues(
    network: ConflictNetwork
  ): RedundancyIssue[] {
    const issues: RedundancyIssue[] = [];
    
    // فحص العلاقات المكررة
    const relationships = Array.from(network.relationships.values());
    for (let i = 0; i < relationships.length; i++) {
      for (let j = i + 1; j < relationships.length; j++) {
        const r1 = relationships[i];
        const r2 = relationships[j];
        
        // نفس الشخصيات ونوع مشابه
        const samePair = (r1.source === r2.source && r1.target === r2.target) ||
                        (r1.source === r2.target && r1.target === r2.source);
        
        if (samePair && r1.type === r2.type) {
          issues.push({
            type: 'duplicate_relationship',
            entities: [r1.id, r2.id],
            similarityScore: 0.9,
            suggestedMerge: `دمج العلاقتين في علاقة واحدة أقوى`
          });
        }
      }
    }
    
    // فحص الصراعات المتداخلة
    const conflicts = Array.from(network.conflicts.values());
    for (let i = 0; i < conflicts.length; i++) {
      for (let j = i + 1; j < conflicts.length; j++) {
        const c1 = conflicts[i];
        const c2 = conflicts[j];
        
        const charOverlap = new Set(c1.involvedCharacters.filter(
          id => c2.involvedCharacters.includes(id)
        ));
        
        const overlapRatio = charOverlap.size / 
          Math.min(c1.involvedCharacters.length, c2.involvedCharacters.length);
        
        if (overlapRatio > 0.7 && c1.subject === c2.subject) {
          issues.push({
            type: 'overlapping_conflict',
            entities: [c1.id, c2.id],
            similarityScore: overlapRatio,
            suggestedMerge: `دمج الصراعين في صراع واحد أكثر تعقيداً`
          });
        }
      }
    }
    
    return issues;
  }
  
  /**
   * حساب درجة الصحة الكلية
   */
  private calculateHealthScore(diagnostics: {
    structuralIssues: StructuralIssue[];
    isolatedCharacters: IsolatedCharacterIssue[];
    abandonedConflicts: AbandonedConflictIssue[];
    overloadedCharacters: OverloadedCharacterIssue[];
    weakConnections: WeakConnectionIssue[];
    redundancyIssues: RedundancyIssue[];
  }): number {
    let score = 100;
    
    // خصم النقاط بناءً على نوع وشدة المشاكل
    for (const issue of diagnostics.structuralIssues) {
      switch (issue.severity) {
        case 'critical': score -= 15; break;
        case 'high': score -= 10; break;
        case 'medium': score -= 5; break;
        case 'low': score -= 2; break;
      }
    }
    
    score -= diagnostics.isolatedCharacters.length * 5;
    score -= diagnostics.abandonedConflicts.length * 7;
    score -= diagnostics.overloadedCharacters.length * 4;
    score -= diagnostics.weakConnections.length * 2;
    score -= diagnostics.redundancyIssues.length * 3;
    
    return Math.max(0, score);
  }
  
  /**
   * تحديد مستوى الخطورة
   */
  private determineCriticalityLevel(
    healthScore: number
  ): NetworkDiagnosticsReport['criticalityLevel'] {
    if (healthScore >= 85) return 'healthy';
    if (healthScore >= 70) return 'minor_issues';
    if (healthScore >= 50) return 'moderate_issues';
    if (healthScore >= 30) return 'major_issues';
    return 'critical';
  }
}

/**
 * محرك استراتيجيات العلاج
 */
class TreatmentStrategies {
  constructor(
    private network: ConflictNetwork,
    private diagnostics: NetworkDiagnosticsReport
  ) {}
  
  /**
   * تحليل وتوصية باستراتيجيات العلاج
   */
  analyzeAndRecommendTreatments(): TreatmentRecommendations {
    // جمع جميع الإجراءات من الأنواع المختلفة
    const prioritizedActions = this.generatePrioritizedActions();
    const quickFixes = this.identifyQuickFixes();
    const structuralRevisions = this.planStructuralRevisions();
    const characterSuggestions = this.developCharacterSuggestions();
    const conflictStrategies = this.enhanceConflictStrategies();
    
    // إنشاء ملخص موحد
    const consolidatedSummary = this.createConsolidatedSummary({
      prioritizedActions,
      quickFixes,
      structuralRevisions,
      characterSuggestions,
      conflictStrategies
    });
    
    return {
      prioritizedActions,
      quickFixes,
      structuralRevisions,
      characterDevelopmentSuggestions: characterSuggestions,
      conflictEnhancementStrategies: conflictStrategies,
      consolidatedSummary
    };
  }
  
  private generatePrioritizedActions(): PrioritizedAction[] {
    const actions: PrioritizedAction[] = [];
    
    // من المشاكل الهيكلية الحرجة
    for (const issue of this.diagnostics.structuralIssues) {
      if (issue.severity === 'critical' || issue.severity === 'high') {
        actions.push({
          priority: issue.severity === 'critical' ? 'critical' : 'high',
          actionType: 'modify',
          targetEntity: {
            type: 'conflict',
            id: issue.affectedEntities.conflicts?.[0] || 'unknown',
            name: 'Structural Issue'
          },
          description: issue.description,
          expectedImpact: issue.potentialImpact,
          effort: 'high'
        });
      }
    }
    
    // من الشخصيات المعزولة
    for (const isolated of this.diagnostics.isolatedCharacters) {
      if (isolated.isolationType === 'completely_isolated') {
        actions.push({
          priority: 'high',
          actionType: 'add',
          targetEntity: {
            type: 'character',
            id: isolated.characterId,
            name: isolated.characterName
          },
          description: `دمج الشخصية المعزولة '${isolated.characterName}' في الشبكة`,
          expectedImpact: 'تحسين التماسك السردي وإثراء الديناميكيات',
          effort: 'medium'
        });
      }
    }
    
    // من التكرارات
    for (const redundancy of this.diagnostics.redundancyIssues) {
      actions.push({
        priority: 'medium',
        actionType: 'merge',
        targetEntity: {
          type: redundancy.type === 'duplicate_relationship' ? 'relationship' : 'conflict',
          id: redundancy.entities[0],
          name: 'Redundant Entity'
        },
        description: redundancy.suggestedMerge,
        expectedImpact: 'تبسيط البنية وتقليل التعقيد غير الضروري',
        effort: 'low'
      });
    }
    
    // ترتيب حسب الأولوية
    const priorityOrder = { critical: 0, high: 1, medium: 2, low: 3 };
    actions.sort((a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]);
    
    return actions;
  }
  
  private identifyQuickFixes(): QuickFix[] {
    const fixes: QuickFix[] = [];
    
    // إصلاحات سريعة للاتصالات الضعيفة
    for (const weak of this.diagnostics.weakConnections) {
      fixes.push({
        issueId: weak.connectionId,
        fixDescription: weak.suggestedStrengthening,
        implementation: weak.connectionType === 'relationship'
          ? 'زيادة قيمة strength في كائن العلاقة'
          : 'تصعيد مرحلة الصراع وزيادة المخاطر',
        estimatedTime: '15-30 دقيقة'
      });
    }
    
    return fixes;
  }
  
  private planStructuralRevisions(): StructuralRevision[] {
    const revisions: StructuralRevision[] = [];
    
    // مراجعات للمكونات المنفصلة
    const disconnectedIssues = this.diagnostics.structuralIssues.filter(
      i => i.type === 'disconnected_components'
    );
    
    for (const issue of disconnectedIssues) {
      revisions.push({
        revisionType: 'add_bridge_character',
        rationale: 'ربط المكونات المنفصلة لتحسين تماسك الشبكة',
        steps: [
          'تحديد المكونات المنفصلة',
          'إنشاء شخصية جسر جديدة أو استخدام شخصية موجودة',
          'إضافة علاقات بين المكونات',
          'التحقق من تحسن التماسك'
        ],
        affectedElements: issue.affectedEntities.characters || [],
        expectedOutcome: 'شبكة موحدة بدون مكونات منفصلة'
      });
    }
    
    // مراجعات للتكرارات
    if (this.diagnostics.redundancyIssues.length > 3) {
      revisions.push({
        revisionType: 'merge_conflicts',
        rationale: 'تقليل التكرار وتبسيط البنية السردية',
        steps: [
          'مراجعة جميع الصراعات المتداخلة',
          'تحديد العناصر الأساسية لكل صراع',
          'دمج الصراعات المتشابهة',
          'إعادة توزيع الشخصيات المشاركة'
        ],
        affectedElements: this.diagnostics.redundancyIssues.flatMap(r => r.entities),
        expectedOutcome: 'بنية صراع أكثر وضوحاً وتركيزاً'
      });
    }
    
    // مراجعات للشخصيات المحملة بشكل زائد
    if (this.diagnostics.overloadedCharacters.length > 0) {
      revisions.push({
        revisionType: 'split_overloaded_character',
        rationale: 'توزيع المسؤوليات السردية بشكل أكثر توازناً',
        steps: [
          'تحليل الأدوار المتعددة للشخصية المحملة',
          'إنشاء شخصيات داعمة جديدة',
          'توزيع الصراعات والعلاقات',
          'الحفاظ على التماسك السردي'
        ],
        affectedElements: this.diagnostics.overloadedCharacters.map(o => o.characterId),
        expectedOutcome: 'توزيع أكثر توازناً للمشاركة عبر الشخصيات'
      });
    }
    
    return revisions;
  }
  
  private developCharacterSuggestions(): CharacterDevelopmentSuggestion[] {
    const suggestions: CharacterDevelopmentSuggestion[] = [];
    
    // اقتراحات للشخصيات المعزولة
    for (const isolated of this.diagnostics.isolatedCharacters) {
      const char = this.network.characters.get(isolated.characterId);
      if (!char) continue;
      
      suggestions.push({
        characterId: isolated.characterId,
        characterName: isolated.characterName,
        currentState: `شخصية معزولة (${isolated.isolationType})`,
        suggestedArc: 'قوس تطوري يربط الشخصية تدريجياً بالشبكة الرئيسية',
        keyMilestones: [
          'لقاء أول مع شخصية رئيسية',
          'الانخراط في صراع ثانوي',
          'تطوير علاقة قوية',
          'المشاركة في صراع مركزي'
        ],
        relationshipsToAdd: isolated.suggestedConnections,
        conflictsToInvolve: this.findSuitableConflictsForCharacter(char)
      });
    }
    
    return suggestions;
  }
  
  private findSuitableConflictsForCharacter(char: Character): string[] {
    const suitable: string[] = [];
    
    for (const [confId, conflict] of this.network.conflicts) {
      // صراعات تحتاج مزيداً من المشاركين
      if (conflict.involvedCharacters.length < 3) {
        suitable.push(conflict.name);
      }
    }
    
    return suitable.slice(0, 3);
  }
  
  private enhanceConflictStrategies(): ConflictEnhancementStrategy[] {
    const strategies: ConflictEnhancementStrategy[] = [];
    
    // استراتيجيات للصراعات المهجورة
    for (const abandoned of this.diagnostics.abandonedConflicts) {
      const conflict = this.network.conflicts.get(abandoned.conflictId);
      if (!conflict) continue;
      
      strategies.push({
        conflictId: abandoned.conflictId,
        conflictName: abandoned.conflictName,
        currentWeakness: `صراع مهجور (${abandoned.issueType})`,
        enhancementApproach: this.generateEnhancementApproach(abandoned.issueType),
        stakesEscalation: 'زيادة المخاطر الشخصية والعواقب المحتملة',
        charactersToInvolve: this.findCharactersToInvolveInConflict(conflict),
        phaseProgression: this.suggestPhaseProgression(conflict)
      });
    }
    
    // استراتيجيات للصراعات الضعيفة
    for (const weak of this.diagnostics.weakConnections) {
      if (weak.connectionType === 'conflict_link') {
        const conflict = this.network.conflicts.get(weak.connectionId);
        if (!conflict) continue;
        
        strategies.push({
          conflictId: weak.connectionId,
          conflictName: conflict.name,
          currentWeakness: weak.reasonForWeakness,
          enhancementApproach: weak.suggestedStrengthening,
          stakesEscalation: 'تصعيد التوتر وزيادة التعقيد',
          charactersToInvolve: [],
          phaseProgression: 'الانتقال إلى مرحلة أكثر حدة'
        });
      }
    }
    
    return strategies;
  }
  
  private generateEnhancementApproach(
    issueType: AbandonedConflictIssue['issueType']
  ): string {
    switch (issueType) {
      case 'no_progression':
        return 'إضافة أحداث محورية متتالية لدفع الصراع قدماً';
      case 'stuck_in_phase':
        return 'إدخال عنصر خارجي أو كشف معلومة جديدة لكسر الجمود';
      case '
      insufficient_involvement':
        return 'توسيع دائرة الشخصيات المشاركة وربط الصراع بخطوط قصصية أخرى';
      default:
        return 'مراجعة شاملة لديناميكية الصراع وإعادة هيكلته';
    }
  }
  
  private findCharactersToInvolveInConflict(conflict: Conflict): string[] {
    const candidates: string[] = [];
    
    // البحث عن شخصيات لها علاقات بالمشاركين الحاليين
    for (const [charId, char] of this.network.characters) {
      if (conflict.involvedCharacters.includes(charId)) continue;
      
      // التحقق من وجود علاقات مع المشاركين
      let hasConnection = false;
      for (const rel of this.network.relationships.values()) {
        if ((rel.source === charId && conflict.involvedCharacters.includes(rel.target)) ||
            (rel.target === charId && conflict.involvedCharacters.includes(rel.source))) {
          hasConnection = true;
          break;
        }
      }
      
      if (hasConnection) {
        candidates.push(char.name);
      }
    }
    
    return candidates.slice(0, 3);
  }
  
  private suggestPhaseProgression(conflict: Conflict): string {
    const phaseOrder = [
      ConflictPhase.LATENT,
      ConflictPhase.EMERGING,
      ConflictPhase.ESCALATING,
      ConflictPhase.CLIMAX,
      ConflictPhase.DEESCALATING,
      ConflictPhase.RESOLUTION,
      ConflictPhase.AFTERMATH
    ];
    
    const currentIndex = phaseOrder.indexOf(conflict.phase);
    if (currentIndex === -1 || currentIndex >= phaseOrder.length - 1) {
      return 'الصراع في مرحلة نهائية أو غير محددة';
    }
    
    const nextPhase = phaseOrder[currentIndex + 1];
    return `الانتقال من ${conflict.phase.name} إلى ${nextPhase.name}`;
  }
  
  private createConsolidatedSummary(components: {
    prioritizedActions: PrioritizedAction[];
    quickFixes: QuickFix[];
    structuralRevisions: StructuralRevision[];
    characterSuggestions: CharacterDevelopmentSuggestion[];
    conflictStrategies: ConflictEnhancementStrategy[];
  }): string {
    const parts: string[] = [];
    
    parts.push(`## ملخص استراتيجيات العلاج الموحد`);
    parts.push(`\n### نظرة عامة على صحة الشبكة:`);
    parts.push(`- الدرجة الكلية: ${this.diagnostics.overallHealthScore}/100`);
    parts.push(`- مستوى الخطورة: ${this.diagnostics.criticalityLevel}`);
    
    if (components.prioritizedActions.length > 0) {
      parts.push(`\n### الإجراءات ذات الأولوية العليا (${components.prioritizedActions.length}):`);
      const criticalCount = components.prioritizedActions.filter(a => a.priority === 'critical').length;
      const highCount = components.prioritizedActions.filter(a => a.priority === 'high').length;
      parts.push(`- حرجة: ${criticalCount}`);
      parts.push(`- عالية: ${highCount}`);
      parts.push(`- متوسطة/منخفضة: ${components.prioritizedActions.length - criticalCount - highCount}`);
    }
    
    if (components.quickFixes.length > 0) {
      parts.push(`\n### الإصلاحات السريعة المتاحة: ${components.quickFixes.length}`);
      parts.push(`يمكن تنفيذ هذه الإصلاحات بسرعة لتحسين فوري في جودة الشبكة.`);
    }
    
    if (components.structuralRevisions.length > 0) {
      parts.push(`\n### المراجعات الهيكلية المطلوبة: ${components.structuralRevisions.length}`);
      const revisionTypes = components.structuralRevisions.map(r => r.revisionType).join(', ');
      parts.push(`الأنواع: ${revisionTypes}`);
    }
    
    if (components.characterSuggestions.length > 0) {
      parts.push(`\n### تطوير الشخصيات: ${components.characterSuggestions.length} شخصية تحتاج تحسين`);
    }
    
    if (components.conflictStrategies.length > 0) {
      parts.push(`\n### تعزيز الصراعات: ${components.conflictStrategies.length} صراع يحتاج تقوية`);
    }
    
    parts.push(`\n### التوصية الرئيسية:`);
    if (this.diagnostics.criticalityLevel === 'critical') {
      parts.push(`الشبكة في حالة حرجة وتحتاج إلى مراجعة شاملة فورية.`);
    } else if (this.diagnostics.criticalityLevel === 'major_issues') {
      parts.push(`توجد مشاكل كبيرة تتطلب معالجة منهجية قبل المتابعة.`);
    } else if (this.diagnostics.criticalityLevel === 'moderate_issues') {
      parts.push(`الشبكة في حالة جيدة مع بعض المجالات التي تحتاج تحسين.`);
    } else {
      parts.push(`الشبكة في حالة صحية جيدة. التركيز على الصقل والتحسينات الدقيقة.`);
    }
    
    return parts.join('\n');
  }
}

/**
 * مقاييس الكفاءة المتقدمة
 */
class AdvancedEfficiencyMetrics {
  constructor(private network: ConflictNetwork) {}
  
  /**
   * حساب مقاييس ما بعد التشخيص
   */
  calculatePostDiagnosticMetrics(
    diagnostics: NetworkDiagnosticsReport
  ): AdvancedEfficiencyMetrics {
    const baseEfficiency = this.calculateBaseEfficiency();
    const improvementPotential = this.calculateImprovementPotential(diagnostics);
    const treatmentFeasibility = this.assessTreatmentFeasibility(diagnostics);
    const expectedOutcome = this.projectExpectedOutcomes(
      baseEfficiency,
      improvementPotential,
      treatmentFeasibility
    );
    const riskAssessment = this.assessImplementationRisks(diagnostics);
    
    return {
      postDiagnosticScore: baseEfficiency,
      improvementPotential,
      treatmentFeasibility,
      expectedOutcome,
      riskAssessment
    };
  }
  
  private calculateBaseEfficiency(): number {
    // استخدام نفس منطق المحطة الرابعة
    const analyzer = new EfficiencyMetricsAnalyzer();
    
    const conflictCohesion = analyzer.calculateConflictCohesion(this.network);
    const dramaticBalance = analyzer.calculateDramaticBalance(this.network);
    const narrativeEfficiency = analyzer.calculateNarrativeEfficiency(this.network);
    const redundancy = analyzer.analyzeRedundancy(this.network);
    const narrativeDensity = analyzer.calculateNarrativeDensity(this.network);
    
    // حساب المتوسط الموزون
    return (
      conflictCohesion * 0.25 +
      dramaticBalance.balanceScore * 0.25 +
      narrativeEfficiency.narrativeEfficiencyScore * 0.25 +
      (1 - redundancy.redundancyScore) * 0.15 +
      narrativeDensity.densityScores.storyDensity * 0.10
    );
  }
  
  private calculateImprovementPotential(
    diagnostics: NetworkDiagnosticsReport
  ): number {
    // الإمكانية العالية إذا كانت المشاكل قابلة للحل بسهولة
    let potential = 0;
    
    // المشاكل الهيكلية البسيطة = إمكانية عالية
    const simpleStructuralIssues = diagnostics.structuralIssues.filter(
      i => i.severity === 'low' || i.severity === 'medium'
    ).length;
    potential += simpleStructuralIssues * 5;
    
    // الشخصيات المعزولة = إمكانية متوسطة
    potential += diagnostics.isolatedCharacters.length * 3;
    
    // التكرارات = إمكانية عالية (سهلة الإصلاح)
    potential += diagnostics.redundancyIssues.length * 4;
    
    // الاتصالات الضعيفة = إمكانية عالية
    potential += diagnostics.weakConnections.length * 4;
    
    // تطبيع إلى 0-1
    return Math.min(1, potential / 100);
  }
  
  private assessTreatmentFeasibility(
    diagnostics: NetworkDiagnosticsReport
  ): number {
    let feasibility = 1.0;
    
    // المشاكل الحرجة تقلل الجدوى
    const criticalIssues = diagnostics.structuralIssues.filter(
      i => i.severity === 'critical'
    ).length;
    feasibility -= criticalIssues * 0.15;
    
    // العدد الكبير من المشاكل يقلل الجدوى
    const totalIssues = 
      diagnostics.structuralIssues.length +
      diagnostics.isolatedCharacters.length +
      diagnostics.abandonedConflicts.length +
      diagnostics.overloadedCharacters.length;
    
    if (totalIssues > 20) feasibility -= 0.2;
    else if (totalIssues > 10) feasibility -= 0.1;
    
    return Math.max(0, feasibility);
  }
  
  private projectExpectedOutcomes(
    baseEfficiency: number,
    improvementPotential: number,
    feasibility: number
  ): AdvancedEfficiencyMetrics['expectedOutcome'] {
    // السيناريو المتفائل: تحقيق كامل الإمكانات
    const optimisticScore = Math.min(1, baseEfficiency + (improvementPotential * feasibility));
    
    // السيناريو الواقعي: تحقيق 60% من الإمكانات
    const realisticScore = Math.min(1, baseEfficiency + (improvementPotential * feasibility * 0.6));
    
    // السيناريو المتشائم: تحقيق 30% من الإمكانات
    const pessimisticScore = Math.min(1, baseEfficiency + (improvementPotential * feasibility * 0.3));
    
    return {
      optimisticScore,
      realisticScore,
      pessimisticScore
    };
  }
  
  private assessImplementationRisks(
    diagnostics: NetworkDiagnosticsReport
  ): AdvancedEfficiencyMetrics['riskAssessment'] {
    const risks: string[] = [];
    
    // مخاطر من المشاكل الهيكلية
    if (diagnostics.structuralIssues.some(i => i.type === 'disconnected_components')) {
      risks.push('خطر فقدان التماسك السردي عند ربط المكونات المنفصلة');
    }
    
    if (diagnostics.structuralIssues.some(i => i.type === 'bottleneck_character')) {
      risks.push('خطر إضعاف الشخصية المركزية عند إعادة التوزيع');
    }
    
    // مخاطر من الشخصيات المحملة
    if (diagnostics.overloadedCharacters.length > 0) {
      risks.push('خطر تفتيت دور الشخصية الرئيسية عند تخفيف الحمل');
    }
    
    // مخاطر من التكرارات
    if (diagnostics.redundancyIssues.length > 5) {
      risks.push('خطر فقدان تنوع السرد عند دمج العناصر المكررة');
    }
    
    // حساب مخاطر الاتساق
    const narrativeCoherenceRisk = this.calculateCoherenceRisk(diagnostics);
    const characterConsistencyRisk = this.calculateConsistencyRisk(diagnostics);
    
    return {
      implementationRisks: risks,
      narrativeCoherenceRisk,
      characterConsistencyRisk
    };
  }
  
  private calculateCoherenceRisk(diagnostics: NetworkDiagnosticsReport): number {
    // خطر أعلى مع المزيد من التغييرات الهيكلية
    let risk = 0;
    
    risk += diagnostics.structuralIssues.filter(i => 
      i.type === 'disconnected_components' || i.type === 'circular_dependency'
    ).length * 0.15;
    
    risk += diagnostics.abandonedConflicts.length * 0.05;
    
    return Math.min(1, risk);
  }
  
  private calculateConsistencyRisk(diagnostics: NetworkDiagnosticsReport): number {
    // خطر أعلى مع تغييرات كبيرة في الشخصيات
    let risk = 0;
    
    risk += diagnostics.isolatedCharacters.length * 0.08;
    risk += diagnostics.overloadedCharacters.length * 0.12;
    
    return Math.min(1, risk);
  }
}

/**
 * المحطة السادسة: التشخيص والعلاج
 */
class Station6DiagnosticsAndTreatment extends BaseStation<Station6Input, Station6Output> {
  protected async process(input: Station6Input): Promise<Station6Output> {
    const startTime = Date.now();
    const network = input.conflictNetwork;
    
    logger.info("S6: Starting diagnostics...");
    
    // 1. تشغيل التشخيصات
    const diagnosticsEngine = new NetworkDiagnostics();
    const diagnosticsReport = diagnosticsEngine.runAllDiagnostics(network);
    
    logger.info(`S6: Diagnostics complete. Health Score: ${diagnosticsReport.overallHealthScore}`);
    
    // 2. تطوير استراتيجيات العلاج
    const treatmentEngine = new TreatmentStrategies(network, diagnosticsReport);
    const treatmentRecommendations = treatmentEngine.analyzeAndRecommendTreatments();
    
    logger.info(`S6: Generated ${treatmentRecommendations.prioritizedActions.length} prioritized actions`);
    
    // 3. حساب مقاييس الكفاءة المتقدمة
    const advancedMetrics = new AdvancedEfficiencyMetrics(network);
    const advancedEfficiencyMetrics = advancedMetrics.calculatePostDiagnosticMetrics(
      diagnosticsReport
    );
    
    logger.info(`S6: Advanced metrics calculated. Improvement potential: ${(advancedEfficiencyMetrics.improvementPotential * 100).toFixed(1)}%`);
    
    const analysisTime = Date.now() - startTime;
    
    return {
      diagnosticsReport,
      treatmentRecommendations,
      advancedEfficiencyMetrics,
      metadata: {
        analysisTimestamp: new Date(),
        status: 'Success',
        analysisTime
      }
    };
  }
  
  protected extractRequiredData(input: Station6Input): any {
    return {
      network: input.conflictNetwork,
      station5Output: input.station5Output
    };
  }
  
  protected getErrorFallback(): Station6Output {
    return {
      diagnosticsReport: {
        structuralIssues: [],
        isolatedCharacters: [],
        abandonedConflicts: [],
        overloadedCharacters: [],
        weakConnections: [],
        redundancyIssues: [],
        overallHealthScore: 0,
        criticalityLevel: 'critical'
      },
      treatmentRecommendations: {
        prioritizedActions: [],
        quickFixes: [],
        structuralRevisions: [],
        characterDevelopmentSuggestions: [],
        conflictEnhancementStrategies: [],
        consolidatedSummary: 'Analysis failed - unable to generate recommendations'
      },
      advancedEfficiencyMetrics: {
        postDiagnosticScore: 0,
        improvementPotential: 0,
        treatmentFeasibility: 0,
        expectedOutcome: {
          optimisticScore: 0,
          realisticScore: 0,
          pessimisticScore: 0
        },
        riskAssessment: {
          implementationRisks: ['Analysis failed'],
          narrativeCoherenceRisk: 1,
          characterConsistencyRisk: 1
        }
      },
      metadata: {
        analysisTimestamp: new Date(),
        status: 'Failed',
        analysisTime: 0
      }
    };
  }
}

المحطة السابعة: الإنهاء والتصور
// stations/station7/station7-finalization.ts

interface Station7Input {
  conflictNetwork: ConflictNetwork;
  station6Output: Station6Output;
  allPreviousStationsData: Map<number, any>; // للوصول إلى بيانات جميع المحطات السابقة
}

interface Station7Output {
  visualizationResults: VisualizationResults;
  platformAdaptationSuggestions: PlatformAdaptationResults;
  finalReport: FinalAnalysisReport;
  exportPackage: ExportPackage;
  metadata: {
    analysisTimestamp: Date;
    status: 'Success' | 'Partial' | 'Failed';
    processingTime: number;
  };
}

interface VisualizationResults {
  networkGraphs: Map<string, VisualizationArtifact>;
  timelineVisualizations: Map<string, VisualizationArtifact>;
  statisticalCharts: Map<string, VisualizationArtifact>;
  interactiveElements: InteractiveVisualization[];
}

interface VisualizationArtifact {
  id: string;
  type: 'static_image' | 'interactive_html' | 'vector_graphic' | 'd3_visualization';
  format: 'png' | 'svg' | 'html' | 'json';
  path: string;
  metadata: {
    title: string;
    description: string;
    dimensions: { width: number; height: number };
    generatedAt: Date;
  };
}

interface InteractiveVisualization {
  id: string;
  type: 'network_explorer' | 'timeline_navigator' | 'conflict_analyzer';
  htmlPath: string;
  dependencies: string[];
  features: string[];
}

interface PlatformAdaptationResults {
  episodicBreakdown: EpisodicAdaptation;
  cinematicSuggestions: CinematicAdaptation;
  serializedNovelStructure: SerializedAdaptation;
  comparativeAnalysis: string;
}

interface EpisodicAdaptation {
  series: {
    totalSeasons: number;
    episodesPerSeason: number;
    recommendedRuntime: number; // minutes
  };
  seasonBreakdown: Map<number, SeasonPlan>;
  cliffhangerSuggestions: Map<number, string[]>; // season -> cliffhangers
  characterArcMapping: Map<string, string[]>; // characterId -> episode numbers
}

interface SeasonPlan {
  seasonNumber: number;
  mainConflicts: string[];
  characterFocus: string[];
  thematicProgression: string;
  keyMilestones: string[];
}

interface CinematicAdaptation {
  recommendedRuntime: number; // minutes
  actBreakdown: {
    act1: { duration: number; keyScenes: string[]; };
    act2: { duration: number; keyScenes: string[]; };
    act3: { duration: number; keyScenes: string[]; };
  };
  visualStyle: string;
  pacingSuggestions: string;
  condensationStrategy: string;
}

interface SerializedAdaptation {
  recommendedChapterCount: number;
  volumeStructure: Map<number, VolumeDetails>;
  cliffhangerPlacement: number[];
  narrativePacing: string;
}

interface VolumeDetails {
  volumeNumber: number;
  chapterRange: [number, number];
  mainConflicts: string[];
  thematicFocus: string;
}

interface FinalAnalysisReport {
  executiveSummary: string;
  strengthsAnalysis: string[];
  weaknessesIdentified: string[];
  opportunitiesForImprovement: string[];
  threatsToCohesion: string[];
  overallAssessment: {
    narrativeQualityScore: number;
    structuralIntegrityScore: number;
    characterDevelopmentScore: number;
    conflictEffectivenessScore: number;
    overallScore: number;
    rating: 'Excellent' | 'Good' | 'Fair' | 'Needs Improvement' | 'Critical';
  };
  detailedFindings: Map<string, any>; // من كل محطة
}

interface ExportPackage {
  formats: Map<string, ExportFormat>;
  deliverables: string[];
  packagePath: string;
}

interface ExportFormat {
  formatType: 'json' | 'pdf' | 'html' | 'markdown' | 'excel';
  filePath: string;
  contentSummary: string;
}

/**
 * محرك التصور البصري
 */
class VisualizationEngine {
  constructor(
    private network: ConflictNetwork,
    private outputDir: string
  ) {
    // إنشاء المجلدات الفرعية للتصورات
    fs.mkdirSync(path.join(outputDir, 'graphs'), { recursive: true });
    fs.mkdirSync(path.join(outputDir, 'charts'), { recursive: true });
    fs.mkdirSync(path.join(outputDir, 'interactive'), { recursive: true });
  }
  
  /**
   * إنشاء جميع التصورات
   */
  async generateAllVisualizations(): Promise<VisualizationResults> {
    const networkGraphs = await this.generateNetworkGraphs();
    const timelineViz = await this.generateTimelineVisualizations();
    const statisticalCharts = await this.generateStatisticalCharts();
    const interactiveElements = await this.generateInteractiveVisualizations();
    
    return {
      networkGraphs,
      timelineVisualizations: timelineViz,
      statisticalCharts,
      interactiveElements
    };
  }
  
  /**
   * إنشاء رسوم الشبكة
   */
  private async generateNetworkGraphs(): Promise<Map<string, VisualizationArtifact>> {
    const graphs = new Map<string, VisualizationArtifact>();
    
    // 1. رسم شبكة الشخصيات
    const characterGraph = await this.createCharacterNetworkGraph();
    graphs.set('character_network', characterGraph);
    
    // 2. رسم شبكة الصراعات
    const conflictGraph = await this.createConflictNetworkGraph();
    graphs.set('conflict_network', conflictGraph);
    
    // 3. رسم الشبكة الكاملة (Bipartite)
    const fullGraph = await this.createFullBipartiteGraph();
    graphs.set('full_network', fullGraph);
    
    // 4. رسم الشبكة حسب الأهمية (Weighted)
    const weightedGraph = await this.createWeightedImportanceGraph();
    graphs.set('weighted_importance', weightedGraph);
    
    return graphs;
  }
  
  private async createCharacterNetworkGraph(): Promise<VisualizationArtifact> {
    // استخدام D3.js أو مكتبة رسم أخرى لإنشاء رسم تفاعلي
    const graphData = this.prepareCharacterGraphData();
    
    // إنشاء ملف HTML تفاعلي باستخدام D3.js
    const htmlContent = this.generateD3CharacterGraph(graphData);
    const outputPath = path.join(this.outputDir, 'graphs', 'character_network.html');
    
    fs.writeFileSync(outputPath, htmlContent, 'utf-8');
    
    // إنشاء أيضاً نسخة PNG ثابتة
    const pngPath = await this.renderGraphToPNG(htmlContent, 'character_network.png');
    
    return {
      id: 'character_network',
      type: 'interactive_html',
      format: 'html',
      path: outputPath,
      metadata: {
        title: 'شبكة العلاقات بين الشخصيات',
        description: 'تصور تفاعلي لجميع العلاقات بين الشخصيات الرئيسية',
        dimensions: { width: 1200, height: 800 },
        generatedAt: new Date()
      }
    };
  }
  
  private prepareCharacterGraphData(): any {
    const nodes: any[] = [];
    const links: any[] = [];
    
    // إضافة العقد (الشخصيات)
    for (const [charId, char] of this.network.characters) {
      nodes.push({
        id: charId,
        name: char.name,
        description: char.description,
        group: this.determineCharacterGroup(char),
        metadata: char.metadata
      });
    }
    
    // إضافة الروابط (العلاقات)
    for (const rel of this.network.relationships.values()) {
      links.push({
        source: rel.source,
        target: rel.target,
        strength: rel.strength,
        type: rel.type.name,
        nature: rel.nature.name,
        description: rel.description
      });
    }
    
    return { nodes, links };
  }
  
  private determineCharacterGroup(char: Character): number {
    // تجميع الشخصيات حسب معايير مختلفة
    // مثلاً: حسب عدد الصراعات المشاركة فيها
    let conflictCount = 0;
    for (const conflict of this.network.conflicts.values()) {
      if (conflict.involvedCharacters.includes(char.id)) {
        conflictCount++;
      }
    }
    
    if (conflictCount >= 3) return 1; // شخصيات رئيسية
    if (conflictCount >= 1) return 2; // شخصيات ثانوية
    return 3; // شخصيات هامشية
  }
  
  private generateD3CharacterGraph(graphData: any): string {
    // توليد كود HTML/JavaScript باستخدام D3.js
    return `
<!DOCTYPE html>
<html dir="rtl" lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>شبكة الشخصيات</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Arial, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
        #graph { width: 100%; height: 800px; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .node { cursor: pointer; }
        .node:hover { stroke: #000; stroke-width: 2px; }
        .link { stroke: #999; stroke-opacity: 0.6; }
        .tooltip { position: absolute; padding: 10px; background: rgba(0,0,0,0.8); color: white; border-radius: 4px; pointer-events: none; display: none; }
    </style>
</head>
<body>
    <h1>شبكة العلاقات بين الشخصيات</h1>
    <div id="graph"></div>
    <div class="tooltip" id="tooltip"></div>
    
    <script>
        const data = ${JSON.stringify(graphData, null, 2)};
        
        const width = document.getElementById('graph').clientWidth;
        const height = 800;
        
        const svg = d3.select('#graph')
            .append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const simulation = d3.forceSimulation(data.nodes)
            .force('link', d3.forceLink(data.links).id(d => d.id).distance(100))
            .force('charge', d3.forceManyBody().strength(-300))
            .force('center', d3.forceCenter(width / 2, height / 2))
            .force('collision', d3.forceCollide().radius(30));
        
        const link = svg.append('g')
            .selectAll('line')
            .data(data.links)
            .enter().append('line')
            .attr('class', 'link')
            .style('stroke-width', d => Math.sqrt(d.strength));
        
        const node = svg.append('g')
            .selectAll('circle')
            .data(data.nodes)
            .enter().append('circle')
            .attr('class', 'node')
            .attr('r', 10)
            .attr('fill', d => d.group === 1 ? '#ff6b6b' : d.group === 2 ? '#4ecdc4' :
            '#95e1d3')
            .call(d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended))
            .on('mouseover', showTooltip)
            .on('mouseout', hideTooltip);
        
        const label = svg.append('g')
            .selectAll('text')
            .data(data.nodes)
            .enter().append('text')
            .attr('text-anchor', 'middle')
            .attr('dy', -15)
            .style('font-size', '12px')
            .style('font-weight', 'bold')
            .text(d => d.name);
        
        simulation.on('tick', () => {
            link
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);
            
            node
                .attr('cx', d => d.x)
                .attr('cy', d => d.y);
            
            label
                .attr('x', d => d.x)
                .attr('y', d => d.y);
        });
        
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }
        
        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }
        
        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
        
        function showTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');
            tooltip.style.display = 'block';
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY + 10) + 'px';
            tooltip.innerHTML = \`
                <strong>\${d.name}</strong><br>
                \${d.description || 'لا يوجد وصف'}
            \`;
        }
        
        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }
    </script>
</body>
</html>
    `;
  }
  
  private async renderGraphToPNG(htmlContent: string, filename: string): Promise<string> {
    // استخدام مكتبة مثل puppeteer لتحويل HTML إلى PNG
    // هذا مثال توضيحي - يحتاج إلى تطبيق فعلي
    const outputPath = path.join(this.outputDir, 'graphs', filename);
    // await puppeteer.render(htmlContent, outputPath);
    return outputPath;
  }
  
  private async createConflictNetworkGraph(): Promise<VisualizationArtifact> {
    // مشابه لـ createCharacterNetworkGraph لكن للصراعات
    const graphData = this.prepareConflictGraphData();
    const htmlContent = this.generateD3ConflictGraph(graphData);
    const outputPath = path.join(this.outputDir, 'graphs', 'conflict_network.html');
    
    fs.writeFileSync(outputPath, htmlContent, 'utf-8');
    
    return {
      id: 'conflict_network',
      type: 'interactive_html',
      format: 'html',
      path: outputPath,
      metadata: {
        title: 'شبكة الصراعات',
        description: 'تصور للصراعات وارتباطاتها بالشخصيات',
        dimensions: { width: 1200, height: 800 },
        generatedAt: new Date()
      }
    };
  }
  
  private prepareConflictGraphData(): any {
    const nodes: any[] = [];
    const links: any[] = [];
    
    // إضافة عقد الشخصيات
    for (const [charId, char] of this.network.characters) {
      nodes.push({
        id: charId,
        name: char.name,
        type: 'character',
        group: 0
      });
    }
    
    // إضافة عقد الصراعات
    for (const [confId, conflict] of this.network.conflicts) {
      nodes.push({
        id: confId,
        name: conflict.name,
        type: 'conflict',
        group: 1,
        subject: conflict.subject.name,
        strength: conflict.strength
      });
      
      // ربط الصراع بالشخصيات المشاركة
      for (const charId of conflict.involvedCharacters) {
        links.push({
          source: charId,
          target: confId,
          type: 'involvement'
        });
      }
    }
    
    return { nodes, links };
  }
  
  private generateD3ConflictGraph(graphData: any): string {
    // مشابه لـ generateD3CharacterGraph مع تخصيصات للصراعات
    return `<!DOCTYPE html>
<html dir="rtl" lang="ar">
<head>
    <meta charset="UTF-8">
    <title>شبكة الصراعات</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Arial, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
        #graph { width: 100%; height: 800px; background: white; border-radius: 8px; }
        .character-node { fill: #4ecdc4; }
        .conflict-node { fill: #ff6b6b; }
    </style>
</head>
<body>
    <h1>شبكة الصراعات والشخصيات</h1>
    <div id="graph"></div>
    <script>
        const data = ${JSON.stringify(graphData, null, 2)};
        // ... كود D3.js مماثل مع تمييز بين أنواع العقد
    </script>
</body>
</html>`;
  }
  
  private async createFullBipartiteGraph(): Promise<VisualizationArtifact> {
    // رسم ثنائي التقسيم يوضح الشخصيات والصراعات معاً
    const outputPath = path.join(this.outputDir, 'graphs', 'full_bipartite.svg');
    
    // استخدام مكتبة رسم SVG
    const svgContent = this.generateBipartiteSVG();
    fs.writeFileSync(outputPath, svgContent, 'utf-8');
    
    return {
      id: 'full_bipartite',
      type: 'vector_graphic',
      format: 'svg',
      path: outputPath,
      metadata: {
        title: 'الشبكة الكاملة (ثنائية التقسيم)',
        description: 'تصور شامل للشخصيات والصراعات في شبكة واحدة',
        dimensions: { width: 1600, height: 1000 },
        generatedAt: new Date()
      }
    };
  }
  
  private generateBipartiteSVG(): string {
    // توليد SVG للرسم الثنائي
    const characters = Array.from(this.network.characters.values());
    const conflicts = Array.from(this.network.conflicts.values());
    
    const width = 1600;
    const height = 1000;
    const leftX = 200;
    const rightX = 1400;
    
    let svg = `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">`;
    svg += `<style>
        .char-circle { fill: #4ecdc4; stroke: #333; stroke-width: 2; }
        .conf-rect { fill: #ff6b6b; stroke: #333; stroke-width: 2; }
        .link { stroke: #999; stroke-width: 1; opacity: 0.6; }
        text { font-family: Arial, sans-serif; font-size: 12px; text-anchor: middle; }
    </style>`;
    
    // رسم الروابط أولاً (في الخلفية)
    for (const conflict of conflicts) {
      const confY = conflicts.indexOf(conflict) * (height / (conflicts.length + 1)) + 50;
      
      for (const charId of conflict.involvedCharacters) {
        const charIndex = characters.findIndex(c => c.id === charId);
        if (charIndex !== -1) {
          const charY = charIndex * (height / (characters.length + 1)) + 50;
          svg += `<line class="link" x1="${leftX}" y1="${charY}" x2="${rightX}" y2="${confY}" />`;
        }
      }
    }
    
    // رسم الشخصيات (يسار)
    characters.forEach((char, i) => {
      const y = i * (height / (characters.length + 1)) + 50;
      svg += `<circle class="char-circle" cx="${leftX}" cy="${y}" r="20" />`;
      svg += `<text x="${leftX}" y="${y + 5}">${char.name}</text>`;
    });
    
    // رسم الصراعات (يمين)
    conflicts.forEach((conf, i) => {
      const y = i * (height / (conflicts.length + 1)) + 50;
      svg += `<rect class="conf-rect" x="${rightX - 30}" y="${y - 15}" width="60" height="30" rx="5" />`;
      svg += `<text x="${rightX}" y="${y + 5}">${conf.name.substring(0, 15)}...</text>`;
    });
    
    svg += `</svg>`;
    return svg;
  }
  
  private async createWeightedImportanceGraph(): Promise<VisualizationArtifact> {
    // رسم يوضح أهمية كل شخصية حسب مشاركتها في الصراعات
    const outputPath = path.join(this.outputDir, 'graphs', 'weighted_importance.html');
    
    const importanceData = this.calculateCharacterImportance();
    const htmlContent = this.generateWeightedImportanceHTML(importanceData);
    
    fs.writeFileSync(outputPath, htmlContent, 'utf-8');
    
    return {
      id: 'weighted_importance',
      type: 'interactive_html',
      format: 'html',
      path: outputPath,
      metadata: {
        title: 'شبكة الأهمية الموزونة',
        description: 'تصور يوضح أهمية كل شخصية بناءً على مشاركتها',
        dimensions: { width: 1200, height: 800 },
        generatedAt: new Date()
      }
    };
  }
  
  private calculateCharacterImportance(): Map<string, number> {
    const importance = new Map<string, number>();
    
    for (const [charId, char] of this.network.characters) {
      let score = 0;
      
      // النقاط من المشاركة في الصراعات
      for (const conflict of this.network.conflicts.values()) {
        if (conflict.involvedCharacters.includes(charId)) {
          score += conflict.strength;
        }
      }
      
      // النقاط من العلاقات
      for (const rel of this.network.relationships.values()) {
        if (rel.source === charId || rel.target === charId) {
          score += rel.strength * 0.5;
        }
      }
      
      importance.set(charId, score);
    }
    
    return importance;
  }
  
  private generateWeightedImportanceHTML(importanceData: Map<string, number>): string {
    const data = Array.from(importanceData.entries()).map(([charId, score]) => ({
      id: charId,
      name: this.network.characters.get(charId)?.name || charId,
      score
    })).sort((a, b) => b.score - a.score);
    
    return `<!DOCTYPE html>
<html dir="rtl" lang="ar">
<head>
    <meta charset="UTF-8">
    <title>أهمية الشخصيات</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        #chart { background: white; padding: 20px; border-radius: 8px; }
        .bar { fill: #4ecdc4; }
        .bar:hover { fill: #ff6b6b; }
    </style>
</head>
<body>
    <h1>تصنيف الشخصيات حسب الأهمية</h1>
    <div id="chart"></div>
    <script>
        const data = ${JSON.stringify(data, null, 2)};
        
        const margin = {top: 20, right: 30, bottom: 60, left: 150};
        const width = 800 - margin.left - margin.right;
        const height = 600 - margin.top - margin.bottom;
        
        const svg = d3.select('#chart')
            .append('svg')
            .attr('width', width + margin.left + margin.right)
            .attr('height', height + margin.top + margin.bottom)
            .append('g')
            .attr('transform', \`translate(\${margin.left},\${margin.top})\`);
        
        const x = d3.scaleLinear()
            .domain([0, d3.max(data, d => d.score)])
            .range([0, width]);
        
        const y = d3.scaleBand()
            .domain(data.map(d => d.name))
            .range([0, height])
            .padding(0.1);
        
        svg.selectAll('.bar')
            .data(data)
            .enter().append('rect')
            .attr('class', 'bar')
            .attr('y', d => y(d.name))
            .attr('height', y.bandwidth())
            .attr('x', 0)
            .attr('width', d => x(d.score));
        
        svg.append('g')
            .attr('transform', \`translate(0,\${height})\`)
            .call(d3.axisBottom(x));
        
        svg.append('g')
            .call(d3.axisLeft(y));
        
        svg.selectAll('.label')
            .data(data)
            .enter().append('text')
            .attr('class', 'label')
            .attr('x', d => x(d.score) + 5)
            .attr('y', d => y(d.name) + y.bandwidth() / 2)
            .attr('dy', '.35em')
            .text(d => d.score.toFixed(1));
    </script>
</body>
</html>`;
  }
  
  /**
   * إنشاء تصورات الجدول الزمني
   */
  private async generateTimelineVisualizations(): Promise<Map<string, VisualizationArtifact>> {
    const timelines = new Map<string, VisualizationArtifact>();
    
    // 1. جدول زمني لتطور الصراعات
    const conflictTimeline = await this.createConflictEvolutionTimeline();
    timelines.set('conflict_evolution', conflictTimeline);
    
    // 2. جدول زمني لتطور الشخصيات
    const characterTimeline = await this.createCharacterDevelopmentTimeline();
    timelines.set('character_development', characterTimeline);
    
    // 3. جدول زمني للأحداث الرئيسية
    const eventsTimeline = await this.createKeyEventsTimeline();
    timelines.set('key_events', eventsTimeline);
    
    return timelines;
  }
  
  private async createConflictEvolutionTimeline(): Promise<VisualizationArtifact> {
    const outputPath = path.join(this.outputDir, 'charts', 'conflict_evolution_timeline.html');
    
    const timelineData = this.prepareConflictTimelineData();
    const htmlContent = this.generateTimelineHTML(timelineData, 'تطور الصراعات عبر الزمن');
    
    fs.writeFileSync(outputPath, htmlContent, 'utf-8');
    
    return {
      id: 'conflict_evolution_timeline',
      type: 'interactive_html',
      format: 'html',
      path: outputPath,
      metadata: {
        title: 'جدول زمني لتطور الصراعات',
        description: 'تصور زمني يوضح تطور مراحل الصراعات المختلفة',
        dimensions: { width: 1400, height: 600 },
        generatedAt: new Date()
      }
    };
  }
  
  private prepareConflictTimelineData(): any[] {
    const timeline: any[] = [];
    
    for (const conflict of this.network.conflicts.values()) {
      if (conflict.timestamps && conflict.timestamps.length > 0) {
        conflict.timestamps.forEach((timestamp, index) => {
          timeline.push({
            conflict: conflict.name,
            timestamp,
            phase: conflict.phase.name, // المرحلة في هذا الوقت
            strength: conflict.strength,
            eventType: index === 0 ? 'start' : 'progression'
          });
        });
      }
    }
    
    // ترتيب حسب الزمن
    timeline.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());
    
    return timeline;
  }
  
  private generateTimelineHTML(timelineData: any[], title: string): string {
    return `<!DOCTYPE html>
<html dir="rtl" lang="ar">
<head>
    <meta charset="UTF-8">
    <title>${title}</title>
    <script src="https://cdn.jsdelivr.net/npm/vis-timeline@7.7.0/standalone/umd/vis-timeline-graph2d.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/vis-timeline@7.7.0/styles/vis-timeline-graph2d.min.css" rel="stylesheet" />
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        #timeline { height: 600px; background: white; border-radius: 8px; padding: 20px; }
    </style>
</head>
<body>
    <h1>${title}</h1>
    <div id="timeline"></div>
    <script>
        const items = ${JSON.stringify(timelineData.map((item, i) => ({
          id: i,
          content: item.conflict,
          start: item.timestamp,
          type: 'point',
          className: item.eventType
        })), null, 2)};
        
        const container = document.getElementById('timeline');
        const options = {
            orientation: 'top',
            stack: true,
            showCurrentTime: false
        };
        
        new vis.Timeline(container, items, options);
    </script>
</body>
</html>`;
  }
  
  private async createCharacterDevelopmentTimeline(): Promise<VisualizationArtifact> {
    // مشابه لـ createConflictEvolutionTimeline لكن للشخصيات
    const outputPath = path.join(this.outputDir, 'charts', 'character_development_timeline.html');
    
    // منطق التطبيق...
    
    return {
      id: 'character_development_timeline',
      type: 'interactive_html',
      format: 'html',
      path: outputPath,
      metadata: {
        title: 'جدول زمني لتطور الشخصيات',
        description: 'تصور لتطور قوس كل شخصية عبر الزمن',
        dimensions: { width: 1400, height: 600 },
        generatedAt: new Date()
      }
    };
  }
  
  private async createKeyEventsTimeline(): Promise<VisualizationArtifact> {
    const outputPath = path.join(this.outputDir, 'charts', 'key_events_timeline.html');
    
    // منطق التطبيق...
    
    return {
      id: 'key_events_timeline',
      type: 'interactive_html',
      format: 'html',
      path: outputPath,
      metadata: {
        title: 'الأحداث الرئيسية',
        description: 'جدول زمني للأحداث المحورية في القصة',
        dimensions: { width: 1400, height: 400 },
        generatedAt: new Date()
      }
    };
  }
  
  /**
   * إنشاء الرسوم البيانية الإحصائية
   */
  private async generateStatisticalCharts(): Promise<Map<string, VisualizationArtifact>> {
    const charts = new Map<string, VisualizationArtifact>();
    
    // 1. رسم توزيع أنواع الصراعات
    const conflictDistribution = await this.createConflictTypeDistributionChart();
    charts.set('conflict_type_distribution', conflictDistribution);
    
    // 2. رسم توزيع طبائع العلاقات
    const relationshipNature = await this.createRelationshipNatureChart();
    charts.set('relationship_nature', relationshipNature);
    
    // 3. رسم مشاركة الشخصيات
    const characterParticipation = await this.createCharacterParticipationChart();
    charts.set('character_participation', characterParticipation);
    
    // 4. رسم توزيع مراحل الصراعات
    const phaseDistribution = await this.createConflictPhaseDistributionChart();
    charts.set('conflict_phase_distribution', phaseDistribution);
    
    return charts;
  }
  
  private async createConflictTypeDistributionChart(): Promise<VisualizationArtifact> {
    const outputPath = path.join(this.outputDir, 'charts', 'conflict_type_distribution.html');
    
    const distribution = new Map<ConflictSubject, number>();
    for (const conflict of this.network.conflicts.values()) {
      distribution.set(
        conflict.subject,
        (distribution.get(conflict.subject) || 0) + 1
      );
    }
    
    const chartData = Array.from(distribution.entries()).map(([subject, count]) => ({
      type: subject.name,
      count
    }));
    
    const htmlContent = this.generatePieChartHTML(chartData, 'توزيع أنواع الصراعات');
    fs.writeFileSync(outputPath, htmlContent, 'utf-8');
    
    return {
      id: 'conflict_type_distribution',
      type: 'interactive_html',
      format: 'html',
      path: outputPath,
      metadata: {
        title: 'توزيع أنواع الصراعات',
        description: 'رسم دائري يوضح نسبة كل نوع من الصراعات',
        dimensions: { width: 600, height: 600 },
        generatedAt: new Date()
      }
    };
  }
  
  private generatePieChartHTML(data: any[], title: string): string {
    return `<!DOCTYPE html>
<html dir="rtl" lang="ar">
<head>
    <meta charset="UTF-8">
    <title>${title}</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; text-align: center; }
        #chartContainer { background: white; padding: 20px; border-radius: 8px; display: inline-block; }
    </style>
</head>
<body>
    <h1>${title}</h1>
    <div id="chartContainer">
        <canvas id="myChart" width="500" height="500"></canvas>
    </div>
    <script>
        const ctx = document.getElementById('myChart').getContext('2d');
        const data = ${JSON.stringify(data, null, 2)};
        
        new Chart(ctx, {
            type: 'pie',
            data: {
                labels: data.map(d => d.type),
                datasets: [{
                    data: data.map(d => d.count),
                    backgroundColor: [
                        '#ff6b6b', '#4ecdc4', '#95e1d3', '#f38181',
                        '#aa96da', '#fcbad3', '#ffffd2'
                    ]
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        position: 'bottom'
                    },
                    title: {
                        display: true,
                        text: '${title}'
                    }
                }
            }
        });
    </script>
</body>
</html>`;
  }
  
  private async createRelationshipNatureChart(): Promise<VisualizationArtifact> {
    // مشابه لـ createConflictTypeDistributionChart
    const outputPath = path.join(this.outputDir, 'charts', 'relationship_nature.html');
    
    // منطق التطبيق...
    
    return {
      id: 'relationship_nature',
      type: 'interactive_html',
      format: 'html',
      path: outputPath,
      metadata: {
        title: 'توزيع طبائع العلاقات',
        description: 'رسم يوضح نسبة العلاقات الإيجابية والسلبية والمحايدة',
        dimensions: { width: 600, height: 600 },
        generatedAt: new Date()
      }
    };
  }
  
  private async createCharacterParticipationChart(): Promise<VisualizationArtifact> {
    const outputPath = path.join(this.outputDir, 'charts', 'character_participation.html');
    
    // منطق التطبيق...
    
    return {
      id: 'character_participation',
      type: 'interactive_html',
      format: 'html',
      path: outputPath,
      metadata: {
        title: 'مشاركة الشخصيات في الصراعات',
        description: 'رسم عمودي يوضح عدد الصراعات لكل شخصية',
        dimensions: { width: 800, height: 600 },
        generatedAt: new Date()
      }
    };
  }
  
  private async createConflictPhaseDistributionChart(): Promise<VisualizationArtifact> {
    const outputPath = path.join(this.outputDir, 'charts', 'conflict_phase_distribution.html');
    
    // منطق التطبيق...
    
    return {
      id: 'conflict_phase_distribution',
      type: 'interactive_html',
      format: 'html',
      path: outputPath,
      metadata: {
        title: 'توزيع مراحل الصراعات',
        description: 'رسم يوضح عدد الصراعات في كل مرحلة',
        dimensions: { width: 800, height: 600 },
        generatedAt: new Date()
      }
    };
  }
  
  /**
   * إنشاء التصورات التفاعلية المتقدمة
   */
  private async generateInteractiveVisualizations(): Promise<InteractiveVisualization[]> {
    const interactive: InteractiveVisualization[] = [];
    
    // 1. مستكشف الشبكة التفاعلي
    const networkExplorer = await this.createNetworkExplorer();
    interactive.push(networkExplorer);
    
    // 2. متصفح الجدول الزمني
    const timelineNavigator = await this.createTimelineNavigator();
    interactive.push(timelineNavigator);
    
    // 3. محلل الصراعات التفاعلي
    const conflictAnalyzer = await this.createConflictAnalyzer();
    interactive.push(conflictAnalyzer);
    
    return interactive;
  }
  
  private async createNetworkExplorer(): Promise<InteractiveVisualization> {
    const htmlPath = path.join(this.outputDir, 'interactive', 'network_explorer.html');
    
    // إنشاء تطبيق تفاعلي كامل للاستكشاف
    const htmlContent = this.generateNetworkExplorerApp();
    fs.writeFileSync(htmlPath, htmlContent, 'utf-8');
    
    return {
      id: 'network_explorer',
      type: 'network_explorer',
      htmlPath,
      dependencies: ['d3.js', 'vis.js'],
      features: [
        'استكشاف تفاعلي للشبكة',
        'تصفية حسب نوع العلاقة أو الصراع',
        'عرض تفاصيل الشخصيات والصراعات',
        'تكبير/تصغير وسحب العقد',
        'بحث عن شخصيات أو صراعات محددة'
      ]
    };
  }
  
  private generateNetworkExplorerApp(): string {
    // توليد تطبيق ويب كامل مع واجهة تفاعلية
    return `<!DOCTYPE html>
<html dir="rtl" lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>مستكشف الشبكة التفاعلي</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Arial, sans-serif; background: #f5f
        private generateNetworkExplorerApp(): string {
    // توليد تطبيق ويب كامل مع واجهة تفاعلية
    return `<!DOCTYPE html>
<html dir="rtl" lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>مستكشف الشبكة التفاعلي</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Arial, sans-serif; background: #f5f5f5; }
        
        #app-container {
            display: grid;
            grid-template-columns: 300px 1fr;
            grid-template-rows: 60px 1fr;
            height: 100vh;
        }
        
        header {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 0 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        header h1 {
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        #sidebar {
            background: white;
            border-left: 1px solid #e0e0e0;
            padding: 1.5rem;
            overflow-y: auto;
        }
        
        #main-canvas {
            background: white;
            position: relative;
            overflow: hidden;
        }
        
        .filter-section {
            margin-bottom: 2rem;
        }
        
        .filter-section h3 {
            font-size: 0.9rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 0.8rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #667eea;
        }
        
        .filter-group {
            margin-bottom: 1rem;
        }
        
        .filter-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
            color: #555;
        }
        
        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .checkbox-group label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }
        
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        input[type="text"], select {
            width: 100%;
            padding: 0.6rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.85rem;
        }
        
        button {
            width: 100%;
            padding: 0.7rem;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #5568d3;
        }
        
        #tooltip {
            position: absolute;
            padding: 1rem;
            background: rgba(0,0,0,0.9);
            color: white;
            border-radius: 6px;
            pointer-events: none;
            display: none;
            max-width: 300px;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        #tooltip h4 {
            margin-bottom: 0.5rem;
            color: #667eea;
        }
        
        .node { cursor: pointer; transition: all 0.3s; }
        .node:hover { stroke: #667eea; stroke-width: 3px; }
        .link { stroke: #999; stroke-opacity: 0.6; }
        
        #controls {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background: white;
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .control-btn {
            width: auto;
            padding: 0.5rem 1rem;
            margin: 0.25rem;
            font-size: 0.8rem;
        }
    </style>
</head>
<body>
    <div id="app-container">
        <header>
            <h1>🕸️ مستكشف شبكة الصراعات التفاعلي</h1>
            <div id="stats"></div>
        </header>
        
        <aside id="sidebar">
            <div class="filter-section">
                <h3>🔍 البحث والتصفية</h3>
                <div class="filter-group">
                    <label>البحث عن شخصية أو صراع:</label>
                    <input type="text" id="search-input" placeholder="اكتب للبحث...">
                </div>
            </div>
            
            <div class="filter-section">
                <h3>🎭 تصفية الشخصيات</h3>
                <div class="checkbox-group" id="character-filters">
                    <!-- سيتم ملؤها ديناميكياً -->
                </div>
            </div>
            
            <div class="filter-section">
                <h3>⚔️ تصفية أنواع الصراعات</h3>
                <div class="checkbox-group" id="conflict-type-filters">
                    <!-- سيتم ملؤها ديناميكياً -->
                </div>
            </div>
            
            <div class="filter-section">
                <h3>🔗 تصفية العلاقات</h3>
                <div class="filter-group">
                    <label>نوع العلاقة:</label>
                    <select id="relationship-type-filter">
                        <option value="all">جميع الأنواع</option>
                        <option value="LOVE">حب</option>
                        <option value="RIVALRY">تنافس</option>
                        <option value="ALLIANCE">تحالف</option>
                        <option value="FAMILY">عائلة</option>
                        <option value="ENMITY">عداء</option>
                    </select>
                </div>
            </div>
            
            <button id="reset-filters">إعادة تعيين الفلاتر</button>
        </aside>
        
        <main id="main-canvas">
            <div id="controls">
                <button class="control-btn" id="zoom-in">➕ تكبير</button>
                <button class="control-btn" id="zoom-out">➖ تصغير</button>
                <button class="control-btn" id="reset-view">🔄 إعادة الضبط</button>
            </div>
            <svg id="network-svg"></svg>
            <div id="tooltip"></div>
        </main>
    </div>
    
    <script>
        // تحميل بيانات الشبكة
        const networkData = ${JSON.stringify({
          nodes: this.prepareNodesForExplorer(),
          links: this.prepareLinksForExplorer()
        })};
        
        // إعداد الأبعاد
        const width = document.getElementById('main-canvas').clientWidth;
        const height = document.getElementById('main-canvas').clientHeight;
        
        // إنشاء SVG مع Zoom
        const svg = d3.select('#network-svg')
            .attr('width', width)
            .attr('height', height);
        
        const g = svg.append('g');
        
        const zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on('zoom', (event) => {
                g.attr('transform', event.transform);
            });
        
        svg.call(zoom);
        
        // إنشاء المحاكاة
        const simulation = d3.forceSimulation(networkData.nodes)
            .force('link', d3.forceLink(networkData.links).id(d => d.id).distance(150))
            .force('charge', d3.forceManyBody().strength(-400))
            .force('center', d3.forceCenter(width / 2, height / 2))
            .force('collision', d3.forceCollide().radius(50));
        
        // رسم الروابط
        const link = g.append('g')
            .selectAll('line')
            .data(networkData.links)
            .enter().append('line')
            .attr('class', 'link')
            .style('stroke-width', d => Math.sqrt(d.strength) * 2);
        
        // رسم العقد
        const node = g.append('g')
            .selectAll('circle')
            .data(networkData.nodes)
            .enter().append('circle')
            .attr('class', 'node')
            .attr('r', d => d.type === 'character' ? 20 : 15)
            .attr('fill', d => d.type === 'character' ? '#4ecdc4' : '#ff6b6b')
            .call(d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended))
            .on('mouseover', showTooltip)
            .on('mouseout', hideTooltip)
            .on('click', highlightConnections);
        
        // النصوص
        const labels = g.append('g')
            .selectAll('text')
            .data(networkData.nodes)
            .enter().append('text')
            .attr('text-anchor', 'middle')
            .attr('dy', -25)
            .style('font-size', '12px')
            .style('font-weight', 'bold')
            .style('fill', '#333')
            .text(d => d.name);
        
        // تحديث المحاكاة
        simulation.on('tick', () => {
            link
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);
            
            node
                .attr('cx', d => d.x)
                .attr('cy', d => d.y);
            
            labels
                .attr('x', d => d.x)
                .attr('y', d => d.y);
        });
        
        // وظائف السحب
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }
        
        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }
        
        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
        
        // Tooltip
        function showTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');
            tooltip.style.display = 'block';
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY + 10) + 'px';
            
            let content = \`<h4>\${d.name}</h4>\`;
            content += \`<p><strong>النوع:</strong> \${d.type === 'character' ? 'شخصية' : 'صراع'}</p>\`;
            if (d.description) content += \`<p>\${d.description}</p>\`;
            
            tooltip.innerHTML = content;
        }
        
        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }
        
        // إبراز الاتصالات
        function highlightConnections(event, d) {
            const connected = new Set();
            connected.add(d.id);
            
            networkData.links.forEach(l => {
                if (l.source.id === d.id) connected.add(l.target.id);
                if (l.target.id === d.id) connected.add(l.source.id);
            });
            
            node.style('opacity', n => connected.has(n.id) ? 1 : 0.2);
            link.style('opacity', l => 
                (l.source.id === d.id || l.target.id === d.id) ? 1 : 0.1
            );
            labels.style('opacity', n => connected.has(n.id) ? 1 : 0.2);
        }
        
        // أزرار التحكم
        document.getElementById('zoom-in').onclick = () => {
            svg.transition().call(zoom.scaleBy, 1.3);
        };
        
        document.getElementById('zoom-out').onclick = () => {
            svg.transition().call(zoom.scaleBy, 0.7);
        };
        
        document.getElementById('reset-view').onclick = () => {
            svg.transition().call(zoom.transform, d3.zoomIdentity);
            node.style('opacity', 1);
            link.style('opacity', 1);
            labels.style('opacity', 1);
        };
        
        // البحث
        document.getElementById('search-input').addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase();
            node.style('opacity', d => 
                d.name.toLowerCase().includes(query) ? 1 : 0.2
            );
            labels.style('opacity', d => 
                d.name.toLowerCase().includes(query) ? 1 : 0.2
            );
        });
        
        // ملء الفلاتر
        populateFilters();
        
        function populateFilters() {
            const characterFilters = document.getElementById('character-filters');
            const conflictFilters = document.getElementById('conflict-type-filters');
            
            const characters = networkData.nodes.filter(n => n.type === 'character');
            characters.forEach(char => {
                const label = document.createElement('label');
                label.innerHTML = \`
                    <input type="checkbox" checked value="\${char.id}">
                    <span>\${char.name}</span>
                \`;
                characterFilters.appendChild(label);
            });
            
            const conflictTypes = [...new Set(
                networkData.nodes
                    .filter(n => n.type === 'conflict')
                    .map(n => n.subject)
            )];
            
            conflictTypes.forEach(type => {
                const label = document.createElement('label');
                label.innerHTML = \`
                    <input type="checkbox" checked value="\${type}">
                    <span>\${type}</span>
                \`;
                conflictFilters.appendChild(label);
            });
        }
        
        // إحصائيات
        updateStats();
        
        function updateStats() {
            const stats = document.getElementById('stats');
            const charCount = networkData.nodes.filter(n => n.type === 'character').length;
            const confCount = networkData.nodes.filter(n => n.type === 'conflict').length;
            stats.innerHTML = \`
                <span style="margin-left: 1rem;">شخصيات: \${charCount}</span>
                <span>صراعات: \${confCount}</span>
            \`;
        }
    </script>
</body>
</html>`;
  }
  
  private prepareNodesForExplorer(): any[] {
    const nodes: any[] = [];
    
    // إضافة الشخصيات
    for (const [charId, char] of this.network.characters) {
      nodes.push({
        id: charId,
        name: char.name,
        type: 'character',
        description: char.description,
        metadata: char.metadata
      });
    }
    
    // إضافة الصراعات
    for (const [confId, conflict] of this.network.conflicts) {
      nodes.push({
        id: confId,
        name: conflict.name,
        type: 'conflict',
        subject: conflict.subject.name,
        description: conflict.description,
        strength: conflict.strength
      });
    }
    
    return nodes;
  }
  
  private prepareLinksForExplorer(): any[] {
    const links: any[] = [];
    
    // إضافة روابط العلاقات
    for (const rel of this.network.relationships.values()) {
      links.push({
        source: rel.source,
        target: rel.target,
        type: 'relationship',
        strength: rel.strength,
        nature: rel.nature.name
      });
    }
    
    // إضافة روابط الصراعات
    for (const conflict of this.network.conflicts.values()) {
      for (const charId of conflict.involvedCharacters) {
        links.push({
          source: charId,
          target: conflict.id,
          type: 'conflict_involvement',
          strength: 5
        });
      }
    }
    
    return links;
  }
  
  private async createTimelineNavigator(): Promise<InteractiveVisualization> {
    const htmlPath = path.join(this.outputDir, 'interactive', 'timeline_navigator.html');
    
    const htmlContent = this.generateTimelineNavigatorApp();
    fs.writeFileSync(htmlPath, htmlContent, 'utf-8');
    
    return {
      id: 'timeline_navigator',
      type: 'timeline_navigator',
      htmlPath,
      dependencies: ['vis-timeline'],
      features: [
        'تصفح الأحداث الزمنية بشكل تفاعلي',
        'فلترة حسب الشخصيات أو الصراعات',
        'عرض تفاصيل كل حدث',
        'تكبير/تصغير المحور الزمني'
      ]
    };
  }
  
  private generateTimelineNavigatorApp(): string {
    return `<!DOCTYPE html>
<html dir="rtl" lang="ar">
<head>
    <meta charset="UTF-8">
    <title>متصفح الجدول الزمني</title>
    <script src="https://unpkg.com/vis-timeline@7.7.0/standalone/umd/vis-timeline-graph2d.min.js"></script>
    <link href="https://unpkg.com/vis-timeline@7.7.0/styles/vis-timeline-graph2d.min.css" rel="stylesheet" />
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        #timeline-container { 
            background: white; 
            border-radius: 8px; 
            padding: 20px; 
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        h1 { color: #333; margin-bottom: 1rem; }
        #timeline { height: 600px; }
        .vis-item { background-color: #4ecdc4; border-color: #3ba89c; }
        .vis-item.conflict { background-color: #ff6b6b; border-color: #e05555; }
    </style>
</head>
<body>
    <h1>📅 متصفح الجدول الزمني للأحداث</h1>
    <div id="timeline-container">
        <div id="timeline"></div>
    </div>
    
    <script>
        const items = new vis.DataSet(${JSON.stringify(this.prepareTimelineData())});
        
        const options = {
            orientation: 'top',
            stack: true,
            showCurrentTime: false,
            locale: 'ar',
            rtl: true
        };
        
        const container = document.getElementById('timeline');
        const timeline = new vis.Timeline(container, items, options);
        
        timeline.on('select', function (properties) {
            const selectedId = properties.items[0];
            if (selectedId) {
                const item = items.get(selectedId);
                alert('الحدث: ' + item.content + '\\n' + (item.description || ''));
            }
        });
    </script>
</body>
</html>`;
  }
  
  private prepareTimelineData(): any[] {
    const events: any[] = [];
    
    // استخراج الأحداث من الشبكة
    for (const snapshot of this.network.snapshots) {
      events.push({
        id: `snap_${snapshot.timestamp.getTime()}`,
        content: snapshot.description,
        start: snapshot.timestamp,
        type: 'point',
        className: 'snapshot'
      });
    }
    
    // استخراج أحداث الصراعات
    for (const conflict of this.network.conflicts.values()) {
      if (conflict.timestamps && conflict.timestamps.length > 0) {
        conflict.timestamps.forEach((ts, idx) => {
          events.push({
            id: `conf_${conflict.id}_${idx}`,
            content: `${conflict.name} - ${conflict.phase.name}`,
            start: ts,
            type: 'box',
            className: 'conflict',
            description: conflict.description
          });
        });
      }
    }
    
    return events.sort((a, b) => a.start - b.start);
  }
  
  private async createConflictAnalyzer(): Promise<InteractiveVisualization> {
    const htmlPath = path.join(this.outputDir, 'interactive', 'conflict_analyzer.html');
    
    const htmlContent = this.generateConflictAnalyzerApp();
    fs.writeFileSync(htmlPath, htmlContent, 'utf-8');
    
    return {
      id: 'conflict_analyzer',
      type: 'conflict_analyzer',
      htmlPath,
      dependencies: ['chart.js'],
      features: [
        'تحليل تفصيلي لكل صراع',
        'مقارنة بين الصراعات',
        'إحصائيات مرئية',
        'تصدير البيانات'
      ]
    };
  }
  
  private generateConflictAnalyzerApp(): string {
    return `<!DOCTYPE html>
<html dir="rtl" lang="ar">
<head>
    <meta charset="UTF-8">
    <title>محلل الصراعات</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px; margin-top: 20px; }
        .card { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        h1, h2 { color: #333; }
        select { width: 100%; padding: 10px; margin-bottom: 20px; border: 1px solid #ddd; border-radius: 4px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>⚔️ محلل الصراعات التفاعلي</h1>
        
        <select id="conflict-selector">
            <option value="">اختر صراعاً للتحليل...</option>
            ${Array.from(this.network.conflicts.values()).map(c => 
              `<option value="${c.id}">${c.name}</option>`
            ).join('')}
        </select>
        
        <div class="grid">
            <div class="card">
                <h2>📊 الإحصائيات الأساسية</h2>
                <canvas id="stats-chart"></canvas>
            </div>
            
            <div class="card">
                <h2>👥 الشخصيات المشاركة</h2>
                <div id="characters-list"></div>
            </div>
            
            <div class="card">
                <h2>📈 تطور الصراع</h2>
                <canvas id="evolution-chart"></canvas>
            </div>
            
            <div class="card">
                <h2>🎯 التفاصيل</h2>
                <div id="conflict-details"></div>
            </div>
        </div>
    </div>
    
    <script>
        const conflictData = ${JSON.stringify(
          Array.from(this.network.conflicts.values()).map(c => ({
            id: c.id,
            name: c.name,
            subject: c.subject.name,
            scope: c.scope.name,
            phase: c.phase.name,
            strength: c.strength,
            characters: c.involvedCharacters,
            description: c.description
          }))
        )};
        
        const characterMap = ${JSON.stringify(
          Array.from(this.network.characters.entries()).reduce((acc, [id, char]) => {
            acc[id] = char.name;
            return acc;
          }, {})
        )};
        
        document.getElementById('conflict-selector').addEventListener('change', (e) => {
            const conflictId = e.target.value;
            if (conflictId) {
                const conflict = conflictData.find(c => c.id === conflictId);
                if (conflict) displayConflictAnalysis(conflict);
            }
        });
        
        function displayConflictAnalysis(conflict) {
            // عرض الشخصيات
            const charList = document.getElementById('characters-list');
            charList.innerHTML = conflict.characters
                .map(cid => \`<p>• \${characterMap[cid] || cid}</p>\`)
                .join('');
            
            // عرض التفاصيل
            const details = document.getElementById('conflict-details');
            details.innerHTML = \`
                <p><strong>الموضوع:</strong> \${conflict.subject}</p>
                <p><strong>النطاق:</strong> \${conflict.scope}</p>
                <p><strong>المرحلة:</strong> \${conflict.phase}</p>
                <p><strong>القوة:</strong> \${conflict.strength}/10</p>
                <p><strong>الوصف:</strong> \${conflict.description}</p>
            \`;
            
            // رسم الإحصائيات
            createStatsChart(conflict);
        }
        
        function createStatsChart(conflict) {
            const ctx = document.getElementById('stats-chart');
            new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: ['القوة', 'التعقيد', 'الأهمية', 'التطور', 'التأثير'],
                    datasets: [{
                        label: conflict.name,
                        data: [
                            conflict.strength,
                            conflict.characters.length * 2,
                            conflict.strength * 0.8,
                            7,
                            conflict.strength * 0.9
                        ],
                        backgroundColor: 'rgba(255, 107, 107, 0.2)',
                        borderColor: 'rgba(255, 107, 107, 1)',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        r: {
                            beginAtZero: true,
                            max: 10
                        }
                    }
                }
            });
        }
    </script>
</body>
</html>`;
  }
}

/**
 * محرك التكيف مع المنصات
 */
class PlatformAdaptationEngine {
  constructor(
    private network: ConflictNetwork,
    private s2Conceptual: Dict<str, Any>
  ) {}
  
  async generateSeriesStructure(episodesPerSeason: number = 10): Promise<PlatformAdaptationResults['episodicBreakdown']> {
    logger.info("S7: Generating episodic breakdown for streaming series...");
    
    const conflicts = Array.from(this.network.conflicts.values());
    const totalSeasons = Math.ceil(conflicts.length / (episodesPerSeason / 2));
    
    const seasonBreakdown = new Map<number, SeasonPlan>();
    
    for (let s = 1; s <= totalSeasons; s++) {
      const startIdx = (s - 1) * Math.floor(conflicts.length / totalSeasons);
      const endIdx = s * Math.floor(conflicts.length / totalSeasons);
      const seasonConflicts = conflicts.slice(startIdx, endIdx);
      
      const episodes: Episode[] = [];
      for (let e = 1; e <= episodesPerSeason; e++) {
        const conflictIdx = Math.floor((e - 1) / (episodesPerSeason / seasonConflicts.length));
        const conflict = seasonConflicts[conflictIdx] || seasonConflicts[0];
        
        episodes.push({
          episodeNumber: e,
          seasonNumber: s,
          title: `الحلقة ${e}`,
          assignedConflicts: [conflict.id],
          featuredCharacters: conflict.involvedCharacters.slice(0, 3),
          estimatedIntensity: conflict.strength,
          narrativeFunction: e < 3 ? 'setup' : (e < 7 ? 'development' : (e < 9 ? 'climax' : 'resolution'))
        });
      }
      
      seasonBreakdown.set(s, {
        seasonNumber: s,
        mainConflicts: seasonConflicts.map(c => c.id),
        characterFocus: seasonConflicts.flatMap(c => c.involvedCharacters).slice(0, 5),
thematicProgression: `تصاعد الصراع من ${seasonConflicts[0]?.name || 'البداية'} إلى ${seasonConflicts[seasonConflicts.length - 1]?.name || 'الذروة'}`,
        keyMilestones: episodes
          .filter(ep => ep.narrativeFunction === 'climax')
          .map(ep => `ذروة الحلقة ${ep.episodeNumber}`)
      });
    }
    
    return {
      series: {
        totalSeasons,
        episodesPerSeason,
        totalEpisodes: totalSeasons * episodesPerSeason,
        recommendedRuntime: 45
      },
      seasonBreakdown,
      cliffhangerSuggestions: this.generateCliffhangers(seasonBreakdown),
      characterArcMapping: this.mapCharacterArcs(seasonBreakdown)
    };
  }
  
  private generateCliffhangers(seasons: Map<number, SeasonPlan>): Map<number, string[]> {
    const cliffhangers = new Map<number, string[]>();
    
    for (const [seasonNum, season] of seasons) {
      const suggestions: string[] = [];
      
      if (season.mainConflicts.length > 0) {
        const mainConflict = this.network.conflicts.get(season.mainConflicts[0]);
        if (mainConflict) {
          suggestions.push(`كشف غير متوقع في صراع ${mainConflict.name}`);
          suggestions.push(`تحول مفاجئ في علاقة شخصية رئيسية`);
          suggestions.push(`تصعيد حاد في ${mainConflict.name} يهدد جميع الأطراف`);
        }
      }
      
      cliffhangers.set(seasonNum, suggestions);
    }
    
    return cliffhangers;
  }
  
  private mapCharacterArcs(seasons: Map<number, SeasonPlan>): Map<string, string[]> {
    const arcMapping = new Map<string, string[]>();
    
    for (const char of this.network.characters.values()) {
      const episodes: string[] = [];
      
      for (const [seasonNum, season] of seasons) {
        if (season.characterFocus.includes(char.id)) {
          const seasonEpisodes = Array.from({ length: 10 }, (_, i) => `S${seasonNum}E${i + 1}`);
          episodes.push(...seasonEpisodes);
        }
      }
      
      arcMapping.set(char.id, episodes);
    }
    
    return arcMapping;
  }
  
  async generateCinematicAdaptation(): Promise<CinematicAdaptation> {
    logger.info("S7: Generating cinematic film adaptation structure...");
    
    const conflicts = Array.from(this.network.conflicts.values());
    const majorConflicts = conflicts
      .sort((a, b) => b.strength - a.strength)
      .slice(0, 3);
    
    // تقسيم حسب بنية الفصول الثلاثة الكلاسيكية
    const totalRuntime = 120; // دقيقة
    
    const act1Scenes: string[] = [];
    const act2Scenes: string[] = [];
    const act3Scenes: string[] = [];
    
    // الفصل الأول: التأسيس (25%)
    majorConflicts.slice(0, 1).forEach(conflict => {
      act1Scenes.push(`تقديم ${conflict.name}`);
      conflict.involvedCharacters.slice(0, 3).forEach(charId => {
        const char = this.network.characters.get(charId);
        if (char) act1Scenes.push(`تقديم ${char.name} وعالمه`);
      });
    });
    
    // الفصل الثاني: التصعيد (50%)
    majorConflicts.forEach(conflict => {
      act2Scenes.push(`تصعيد ${conflict.name}`);
      act2Scenes.push(`نقطة تحول في ${conflict.name}`);
      act2Scenes.push(`ذروة فرعية: ${conflict.name} يبلغ أوجه`);
    });
    
    // الفصل الثالث: الحل (25%)
    act3Scenes.push(`الذروة النهائية: اجتماع جميع الصراعات`);
    majorConflicts.forEach(conflict => {
      act3Scenes.push(`حل ${conflict.name}`);
    });
    act3Scenes.push(`الخاتمة والتبعات`);
    
    return {
      recommendedRuntime: totalRuntime,
      actBreakdown: {
        act1: {
          duration: Math.floor(totalRuntime * 0.25),
          keyScenes: act1Scenes
        },
        act2: {
          duration: Math.floor(totalRuntime * 0.5),
          keyScenes: act2Scenes
        },
        act3: {
          duration: Math.floor(totalRuntime * 0.25),
          keyScenes: act3Scenes
        }
      },
      visualStyle: this.s2Conceptual['hybrid_genre'] || 'درامي واقعي',
      pacingSuggestions: 'إيقاع متصاعد مع نقاط راحة استراتيجية بين الذرى',
      condensationStrategy: 'التركيز على الصراعات الرئيسية ودمج الشخصيات الثانوية'
    };
  }
  
  async generateSerializedNovelStructure(): Promise<SerializedAdaptation> {
    logger.info("S7: Generating serialized novel structure...");
    
    const conflicts = Array.from(this.network.conflicts.values());
    const estimatedChapters = conflicts.length * 3; // 3 فصول لكل صراع
    const volumeCount = Math.ceil(estimatedChapters / 12); // 12 فصل لكل مجلد
    
    const volumeStructure = new Map<number, VolumeDetails>();
    
    for (let v = 1; v <= volumeCount; v++) {
      const startChapter = (v - 1) * 12 + 1;
      const endChapter = Math.min(v * 12, estimatedChapters);
      
      const conflictStart = Math.floor((v - 1) * (conflicts.length / volumeCount));
      const conflictEnd = Math.floor(v * (conflicts.length / volumeCount));
      const volumeConflicts = conflicts.slice(conflictStart, conflictEnd);
      
      volumeStructure.set(v, {
        volumeNumber: v,
        chapterRange: [startChapter, endChapter],
        mainConflicts: volumeConflicts.map(c => c.id),
        thematicFocus: volumeConflicts.length > 0 
          ? `التركيز على ${volumeConflicts[0].subject.name}` 
          : 'متنوع'
      });
    }
    
    // اقتراح مواضع الـ Cliffhangers
    const cliffhangerPlacements: number[] = [];
    for (let v = 1; v < volumeCount; v++) {
      cliffhangerPlacements.push(v * 12); // نهاية كل مجلد
    }
    
    return {
      recommendedChapterCount: estimatedChapters,
      volumeStructure,
      cliffhangerPlacement: cliffhangerPlacements,
      narrativePacing: 'إيقاع متدرج مع ذرى في نهاية كل مجلد'
    };
  }
  
  async generateComparativeAnalysis(): Promise<string> {
    const episodic = await this.generateSeriesStructure();
    const cinematic = await this.generateCinematicAdaptation();
    const novel = await this.generateSerializedNovelStructure();
    
    return `
# التحليل المقارن للمنصات

## المسلسل الحلقي (Streaming Series)
- **المواسم:** ${episodic.series.totalSeasons}
- **الحلقات الإجمالية:** ${episodic.series.totalEpisodes}
- **المدة المقترحة:** ${episodic.series.recommendedRuntime} دقيقة/حلقة
- **المزايا:** قدرة على تطوير شخصيات عميق، استكشاف صراعات متعددة
- **التحديات:** الحفاظ على التوتر عبر مواسم متعددة

## الفيلم السينمائي (Feature Film)
- **المدة الكلية:** ${cinematic.recommendedRuntime} دقيقة
- **البنية:** 3 فصول كلاسيكية
- **المزايا:** تأثير عاطفي مكثف، تجربة سينمائية موحدة
- **التحديات:** ضرورة اختزال الصراعات والشخصيات

## الرواية المسلسلة (Serialized Novel)
- **المجلدات:** ${novel.volumeStructure.size}
- **الفصول الكلية:** ${novel.recommendedChapterCount}
- **المزايا:** حرية سردية كاملة، عمق نفسي
- **التحديات:** الحفاظ على تفاعل القارئ عبر مجلدات متعددة

## التوصية
بناءً على تحليل شبكة الصراع، فإن **${this.recommendBestPlatform(episodic, cinematic, novel)}** هي المنصة الأنسب لهذا العمل.
`;
  }
  
  private recommendBestPlatform(episodic: any, cinematic: any, novel: any): string {
    const conflictCount = this.network.conflicts.size;
    const characterCount = this.network.characters.size;
    
    // منطق اتخاذ القرار
    if (conflictCount > 5 && characterCount > 7) {
      return 'المسلسل الحلقي';
    } else if (conflictCount <= 3 && characterCount <= 5) {
      return 'الفيلم السينمائي';
    } else {
      return 'الرواية المسلسلة';
    }
  }
}

/**
 * محرك التقرير النهائي
 */
class FinalReportGenerator {
  constructor(
    private network: ConflictNetwork,
    private allStationsData: Map<number, any>
  ) {}
  
  async generateComprehensiveReport(): Promise<FinalAnalysisReport> {
    logger.info("S7: Generating comprehensive final report...");
    
    const executiveSummary = this.buildExecutiveSummary();
    const strengthsAnalysis = this.analyzeStrengths();
    const weaknessesIdentified = this.identifyWeaknesses();
    const opportunitiesForImprovement = this.findOpportunities();
    const threatsToCohesion = this.assessThreats();
    const overallAssessment = this.calculateOverallAssessment();
    const detailedFindings = this.compileDetailedFindings();
    
    return {
      executiveSummary,
      strengthsAnalysis,
      weaknessesIdentified,
      opportunitiesForImprovement,
      threatsToCohesion,
      overallAssessment,
      detailedFindings
    };
  }
  
  private buildExecutiveSummary(): string {
    const charCount = this.network.characters.size;
    const relCount = this.network.relationships.size;
    const confCount = this.network.conflicts.size;
    
    return `
تم إجراء تحليل شامل ومتعمق للنص السردي عبر 7 محطات تحليلية متخصصة.

**النتائج الكمية:**
- عدد الشخصيات الرئيسية: ${charCount}
- عدد العلاقات المحددة: ${relCount}
- عدد الصراعات المستنبطة: ${confCount}
- عدد اللقطات الزمنية: ${this.network.snapshots.length}

**التقييم الإجمالي:** ${this.getQualitativeRating()}

**الملخص التنفيذي:**
${this.generateNarrativeSummary()}
`;
  }
  
  private getQualitativeRating(): string {
    const s4Data = this.allStationsData.get(4);
    if (s4Data?.results?.overall_efficiency_score) {
      const score = s4Data.results.overall_efficiency_score;
      if (score >= 0.8) return 'ممتاز - بنية قوية ومتماسكة';
      if (score >= 0.6) return 'جيد - بنية قوية مع بعض نقاط التحسين';
      if (score >= 0.4) return 'مقبول - يحتاج تحسينات هيكلية';
      return 'ضعيف - يتطلب إعادة هيكلة كبرى';
    }
    return 'غير محدد - بيانات غير كافية';
  }
  
  private generateNarrativeSummary(): string {
    const s1Data = this.allStationsData.get(1);
    const s2Data = this.allStationsData.get(2);
    
    const storyStatement = s2Data?.conceptual_outputs?.user_selections?.final_story_statement || 'بيان القصة غير متوفر';
    const mainChars = s1Data?.analysis_outputs?.major_characters_identified?.major_characters || [];
    
    return `
العمل يدور حول ${mainChars.slice(0, 3).join(' و')} في ${storyStatement.substring(0, 100)}...
تم بناء شبكة صراع معقدة تربط بين الشخصيات عبر ${this.network.relationships.size} علاقة ديناميكية.
`;
  }
  
  private analyzeStrengths(): string[] {
    const strengths: string[] = [];
    
    const s4Data = this.allStationsData.get(4);
    if (s4Data?.results) {
      const results = s4Data.results;
      
      if (results.conflict_cohesion > 0.6) {
        strengths.push(`تماسك عالٍ بين الصراعات (${(results.conflict_cohesion * 100).toFixed(1)}%)`);
      }
      
      if (results.dramatic_balance?.balance_score > 0.7) {
        strengths.push('توازن ممتاز في توزيع الأدوار الدرامية بين الشخصيات');
      }
      
      if (results.narrative_efficiency?.narrative_efficiency_score > 0.7) {
        strengths.push('كفاءة سردية عالية مع استغلال أمثل للشخصيات');
      }
      
      if (results.redundancy?.redundancy_level === 'Low') {
        strengths.push('مستوى منخفض من التكرار - سرد اقتصادي وفعّال');
      }
    }
    
    const s5Data = this.allStationsData.get(5);
    if (s5Data?.symbolic_analysis_results?.depth_score > 7) {
      strengths.push('عمق رمزي ملحوظ في الطبقات الدلالية');
    }
    
    if (s5Data?.stylistic_analysis_results?.overallToneAssessment?.tone_consistency > 8) {
      strengths.push('اتساق أسلوبي قوي عبر النص');
    }
    
    if (strengths.length === 0) {
      strengths.push('تحليل متوازن يحتاج مزيد من البيانات لتحديد نقاط القوة');
    }
    
    return strengths;
  }
  
  private identifyWeaknesses(): string[] {
    const weaknesses: string[] = [];
    
    const s4Data = this.allStationsData.get(4);
    if (s4Data?.results) {
      const results = s4Data.results;
      
      if (results.conflict_cohesion < 0.4) {
        weaknesses.push(`تماسك ضعيف بين الصراعات (${(results.conflict_cohesion * 100).toFixed(1)}%)`);
      }
      
      if (results.dramatic_balance?.character_involvement_gini > 0.6) {
        weaknesses.push('عدم توازن كبير في أهمية الشخصيات - بعض الشخصيات مهمشة');
      }
      
      if (results.redundancy?.redundancy_level === 'High' || results.redundancy?.redundancy_level === 'Critical') {
        weaknesses.push(`مستوى تكرار ${results.redundancy.redundancy_level} - وجود عناصر مكررة`);
      }
      
      if (results.narrative_density?.density_scores?.story_density < 0.3) {
        weaknesses.push('كثافة سردية منخفضة - القصة قد تبدو مفككة');
      }
    }
    
    const s6Data = this.allStationsData.get(6);
    if (s6Data?.results?.diagnostics_report) {
      const diag = s6Data.results.diagnostics_report;
      
      if (diag.isolated_characters?.length > 0) {
        weaknesses.push(`وجود ${diag.isolated_characters.length} شخصية معزولة غير مدمجة في الشبكة`);
      }
      
      if (diag.abandoned_conflicts?.length > 0) {
        weaknesses.push(`${diag.abandoned_conflicts.length} صراع مهجور أو غير مكتمل`);
      }
    }
    
    if (weaknesses.length === 0) {
      weaknesses.push('لم يتم رصد نقاط ضعف كبرى في التحليل الحالي');
    }
    
    return weaknesses;
  }
  
  private findOpportunities(): string[] {
    const opportunities: string[] = [];
    
    const s6Data = this.allStationsData.get(6);
    if (s6Data?.results?.treatment_recommendations) {
      const treatments = s6Data.results.treatment_recommendations;
      
      if (treatments.character_development_suggestions?.length > 0) {
        opportunities.push('تطوير أعمق لقوس الشخصيات المقترحة');
      }
      
      if (treatments.conflict_enhancement_strategies?.length > 0) {
        opportunities.push('تعزيز الصراعات الموجودة لزيادة التوتر الدرامي');
      }
      
      if (treatments.structural_revisions?.length > 0) {
        opportunities.push('إعادة هيكلة بعض العناصر لتحسين التدفق السردي');
      }
    }
    
    const s5Data = this.allStationsData.get(5);
    if (s5Data?.episodic_integration_results?.balance_report) {
      const balance = s5Data.episodic_integration_results.balance_report;
      if (balance.overall_balance < 0.7) {
        opportunities.push('إعادة توزيع الصراعات عبر الحلقات لتحسين التوازن');
      }
    }
    
    if (opportunities.length === 0) {
      opportunities.push('الحفاظ على البنية الحالية مع صقل تدريجي');
    }
    
    return opportunities;
  }
  
  private assessThreats(): string[] {
    const threats: string[] = [];
    
    const s4Data = this.allStationsData.get(4);
    if (s4Data?.results?.issues) {
      const issues = s4Data.results.issues;
      
      issues.forEach((issue: any) => {
        if (issue.severity === 'critical' || issue.severity === 'major') {
          threats.push(`${issue.description} - خطر: ${issue.severity}`);
        }
      });
    }
    
    const s6Data = this.allStationsData.get(6);
    if (s6Data?.results?.advanced_efficiency_metrics?.risk_assessment) {
      const risks = s6Data.results.advanced_efficiency_metrics.risk_assessment;
      
      if (risks.narrative_coherence_risk > 0.5) {
        threats.push('خطر متوسط إلى عالٍ لفقدان التماسك السردي');
      }
      
      if (risks.character_consistency_risk > 0.5) {
        threats.push('خطر عدم اتساق الشخصيات عبر القصة');
      }
    }
    
    if (threats.length === 0) {
      threats.push('لا توجد تهديدات كبرى للتماسك السردي');
    }
    
    return threats;
  }
  
  private calculateOverallAssessment(): FinalAnalysisReport['overallAssessment'] {
    const s4Data = this.allStationsData.get(4);
    const s5Data = this.allStationsData.get(5);
    const s6Data = this.allStationsData.get(6);
    
    // حساب الدرجات
    const narrativeQuality = s5Data?.stylistic_analysis_results?.overall_tone_assessment?.tone_consistency / 10 || 0.5;
    const structuralIntegrity = s4Data?.results?.conflict_cohesion || 0.5;
    const characterDevelopment = s4Data?.results?.dramatic_balance?.balance_score || 0.5;
    const conflictEffectiveness = s4Data?.results?.narrative_efficiency?.conflict_efficiency || 0.5;
    
    const overallScore = (
      narrativeQuality * 0.25 +
      structuralIntegrity * 0.25 +
      characterDevelopment * 0.25 +
      conflictEffectiveness * 0.25
    );
    
    let rating: 'Excellent' | 'Good' | 'Fair' | 'Needs Improvement' | 'Critical';
    if (overallScore >= 0.8) rating = 'Excellent';
    else if (overallScore >= 0.6) rating = 'Good';
    else if (overallScore >= 0.4) rating = 'Fair';
    else if (overallScore >= 0.2) rating = 'Needs Improvement';
    else rating = 'Critical';
    
    return {
      narrativeQualityScore: narrativeQuality,
      structuralIntegrityScore: structuralIntegrity,
      characterDevelopmentScore: characterDevelopment,
      conflictEffectivenessScore: conflictEffectiveness,
      overallScore,
      rating
    };
  }
  
  private compileDetailedFindings(): Map<string, any> {
    const findings = new Map<string, any>();
    
    for (const [stationNum, stationData] of this.allStationsData) {
      findings.set(`station_${stationNum}`, {
        station_name: `المحطة ${stationNum}`,
        key_outputs: this.extractKeyOutputs(stationNum, stationData),
        performance: stationData.performance_stats || {}
      });
    }
    
    return findings;
  }
  
  private extractKeyOutputs(stationNum: number, data: any): any {
    switch (stationNum) {
      case 1:
        return {
          major_characters: data.analysis_outputs?.major_characters_identified?.major_characters?.length || 0,
          relationships_analyzed: data.analysis_outputs?.relationship_analysis?.key_relationships?.length || 0
        };
      case 2:
        return {
          story_statement: data.conceptual_outputs?.user_selections?.final_story_statement?.substring(0, 100) || 'N/A',
          hybrid_genre: data.conceptual_outputs?.user_selections?.final_hybrid_genre || 'N/A'
        };
      case 3:
        return {
          network_built: data.results?.network_summary || {}
        };
      case 4:
        return {
          efficiency_score: data.results?.overall_efficiency_score || 0,
          rating: data.results?.overall_rating || 'N/A'
        };
      case 5:
        return {
          dynamic_analysis: data.dynamic_analysis_results ? 'Completed' : 'N/A',
          symbolic_depth: data.symbolic_analysis_results?.depth_score || 0
        };
      case 6:
        return {
          diagnostics_run: data.results?.diagnostics_report ? 'Completed' : 'N/A',
          treatment_recommendations: data.results?.treatment_recommendations?.prioritized_actions?.length || 0
        };
      case 7:
        return {
          visualizations_generated: 'In Progress',
          final_report: 'In Progress'
        };
      default:
        return {};
    }
  }
}

/**
 * نظام التصدير النهائي
 */
class ExportPackageGenerator {
  constructor(
    private outputDir: string,
    private allStationsData: Map<number, any>,
    private finalReport: FinalAnalysisReport
  ) {}
  
  async generateExportPackage(): Promise<ExportPackage> {
    logger.info("S7: Generating comprehensive export package...");
    
    const formats = new Map<string, ExportFormat>();
    const deliverables: string[] = [];
    
    // تصدير JSON
    const jsonPath = await this.exportAsJSON();
    formats.set('json', {
      formatType: 'json',
      filePath: jsonPath,
      contentSummary: 'بيانات كاملة بصيغة JSON قابلة للبرمجة'
    });
    deliverables.push(jsonPath);
    
    // تصدير Markdown
    const mdPath = await this.exportAsMarkdown();
    formats.set('markdown', {
      formatType: 'markdown',
      filePath: mdPath,
      contentSummary: 'تقرير شامل بصيغة Markdown قابل للقراءة'
    });
    deliverables.push(mdPath);
    
    // تصدير PDF (محاكاة - يتطلب مكتبة خارجية في الإنتاج)
    logger.info("S7: PDF export would require additional dependencies (e.g., puppeteer)");
    
    const packagePath = this.outputDir;
    
    return {
      formats,
      deliverables,
      packagePath
    };
  }
  
  private async exportAsJSON(): Promise<string> {
    const jsonPath = path.join(this.outputDir, 'complete_analysis.json');
    
    const exportData = {
      metadata: {
        export_timestamp: new Date().toISOString(),
        version: '1.0.0',
        generator: 'Station7_FinalReportGenerator'
      },
      stations_data: Object.fromEntries(this.allStationsData),
      final_report: {
        executive_summary: this.finalReport.executiveSummary,
        strengths: this.finalReport.strengthsAnalysis,
        weaknesses: this.finalReport.weaknessesIdentified,
        opportunities: this.finalReport.opportunitiesForImprovement,
        threats: this.finalReport.threatsToCohesion,
        overall_assessment: this.finalReport.overallAssessment,
        detailed_findings: Object.fromEntries(this.finalReport.detailedFindings)
      }
    };
    
    fs.writeFileSync(jsonPath, JSON.stringify(exportData, null, 2), 'utf-8');
    logger.info(`S7: JSON export saved to: ${jsonPath}`);
    
    return jsonPath;
  }
  
  private async exportAsMarkdown(): Promise<string> {
    const mdPath = path.join(this.outputDir, 'final_report.md');
    
    let markdown = `# التقرير النهائي الشامل لتحليل النص السردي

**تاريخ التصدير:** ${new Date().toLocaleString('ar-EG')}

---

## 📋 الملخص التنفيذي

${this.finalReport.executiveSummary}

---

## ✅ نقاط القوة

${this.finalReport.strengthsAnalysis.map((s, i) => `${i + 1}. ${s}`).join('\n')}

---

## ⚠️ نقاط الضعف

${this.finalReport.weaknessesIdentified.map((w, i) => `${i + 1}. ${w}`).join('\n')}

---

## 🚀 فرص التحسين

${this.finalReport.opportunitiesForImprovement.map((o, i) => `${i + 1}. ${o}`).join('\n')}

---

"""
وحدة التشخيص الشبكي المتقدمة
==============================
تقوم بفحص شامل لشبكة الصراع وتحديد المشاكل الهيكلية والعلاقات الضعيفة
والشخصيات المعزولة والصراعات المهملة.

المؤلف: نظام تحليل النصوص الدرامية
الإصدار: 2.0.0 (Production Ready)
"""

import logging
from typing import Dict, List, Any, Optional, Set, Tuple
from datetime import datetime, timedelta
from collections import defaultdict
import networkx as nx

from core.base_entities import (
    ConflictNetwork, 
    Conflict, 
    Character, 
    Relationship,
    ConflictPhase,
    RelationshipNature
)

logger = logging.getLogger(__name__)


class NetworkDiagnostics:
    """
    محلل تشخيصي متقدم لشبكات الصراع الدرامية
    
    يقوم بفحص شامل للشبكة ويحدد:
    - المشاكل الهيكلية (مكونات منفصلة، عنق الزجاجة)
    - الشخصيات المعزولة أو المحملة بشكل زائد
    - الصراعات المهملة أو الضعيفة
    - الاتصالات الضعيفة
    - التكرارات والازدواجية
    """
    
    def __init__(self, network: ConflictNetwork):
        """
        تهيئة المحلل التشخيصي
        
        Args:
            network: شبكة الصراع المراد تحليلها
        """
        self.network = network
        self.nx_graph = self._build_networkx_graph()
        
        # نتائج التشخيص
        self.structural_issues: List[Dict[str, Any]] = []
        self.isolated_characters: List[Dict[str, Any]] = []
        self.abandoned_conflicts: List[Dict[str, Any]] = []
        self.overloaded_characters: List[Dict[str, Any]] = []
        self.weak_connections: List[Dict[str, Any]] = []
        self.redundancy_issues: List[Dict[str, Any]] = []
        
        logger.info(f"NetworkDiagnostics initialized for network: {network.name}")
    
    def _build_networkx_graph(self) -> nx.Graph:
        """
        بناء رسم بياني NetworkX من شبكة الصراع لتحليل هيكلي متقدم
        
        Returns:
            رسم بياني NetworkX
        """
        G = nx.Graph()
        
        # إضافة العقد (الشخصيات)
        for char_id, character in self.network.characters.items():
            G.add_node(char_id, 
                      name=character.name,
                      type='character',
                      data=character)
        
        # إضافة الحواف (العلاقات)
        for rel_id, relationship in self.network.relationships.items():
            if relationship.source in G.nodes and relationship.target in G.nodes:
                G.add_edge(relationship.source, 
                          relationship.target,
                          weight=relationship.strength,
                          rel_id=rel_id,
                          data=relationship)
        
        logger.info(f"Built NetworkX graph: {G.number_of_nodes()} nodes, {G.number_of_edges()} edges")
        return G
    
    def run_all_diagnostics(self) -> Dict[str, Any]:
        """
        تشغيل جميع التشخيصات الممكنة على الشبكة
        
        Returns:
            تقرير تشخيصي شامل
        """
        logger.info("="*60)
        logger.info("Starting comprehensive network diagnostics...")
        logger.info("="*60)
        
        # تشخيص المشاكل الهيكلية
        self.structural_issues = self._diagnose_structural_issues()
        logger.info(f"✓ Structural issues identified: {len(self.structural_issues)}")
        
        # تشخيص الشخصيات المعزولة
        self.isolated_characters = self._identify_isolated_characters()
        logger.info(f"✓ Isolated characters found: {len(self.isolated_characters)}")
        
        # تشخيص الصراعات المهملة
        self.abandoned_conflicts = self._identify_abandoned_conflicts()
        logger.info(f"✓ Abandoned conflicts detected: {len(self.abandoned_conflicts)}")
        
        # تشخيص الشخصيات المحملة
        self.overloaded_characters = self._identify_overloaded_characters()
        logger.info(f"✓ Overloaded characters found: {len(self.overloaded_characters)}")
        
        # تشخيص الاتصالات الضعيفة
        self.weak_connections = self._identify_weak_connections()
        logger.info(f"✓ Weak connections identified: {len(self.weak_connections)}")
        
        # تشخيص التكرارات
        self.redundancy_issues = self._identify_redundancies()
        logger.info(f"✓ Redundancy issues found: {len(self.redundancy_issues)}")
        
        # حساب درجة الصحة الإجمالية
        overall_health_score = self._calculate_health_score()
        criticality_level = self._determine_criticality_level(overall_health_score)
        
        logger.info("="*60)
        logger.info(f"Network Health Score: {overall_health_score:.2f}/100")
        logger.info(f"Criticality Level: {criticality_level}")
        logger.info("="*60)
        
        return {
            'structural_issues': self.structural_issues,
            'isolated_characters': {
                'total_isolated': len(self.isolated_characters),
                'characters': self.isolated_characters
            },
            'abandoned_conflicts': {
                'total_abandoned': len(self.abandoned_conflicts),
                'conflicts': self.abandoned_conflicts
            },
            'overloaded_characters': {
                'total_overloaded': len(self.overloaded_characters),
                'characters': self.overloaded_characters
            },
            'weak_connections': {
                'total_weak': len(self.weak_connections),
                'connections': self.weak_connections
            },
            'redundancy_issues': {
                'total_redundant': len(self.redundancy_issues),
                'issues': self.redundancy_issues
            },
            'overall_health_score': overall_health_score,
            'criticality_level': criticality_level,
            'summary': self._generate_diagnostic_summary(
                overall_health_score, 
                criticality_level
            )
        }
    
    def _diagnose_structural_issues(self) -> List[Dict[str, Any]]:
        """
        تحديد المشاكل الهيكلية في الشبكة
        
        Returns:
            قائمة بالمشاكل الهيكلية المكتشفة
        """
        issues = []
        
        # 1. فحص المكونات المنفصلة
        if not nx.is_connected(self.nx_graph):
            components = list(nx.connected_components(self.nx_graph))
            if len(components) > 1:
                issues.append({
                    'type': 'disconnected_components',
                    'severity': 'high' if len(components) > 2 else 'medium',
                    'description': f'الشبكة تحتوي على {len(components)} مكونات منفصلة',
                    'affected_entities': {
                        'components': [list(comp) for comp in components],
                        'component_sizes': [len(comp) for comp in components]
                    },
                    'potential_impact': 'فقدان التماسك السردي وتفكك القصة',
                    'recommendation': 'إضافة شخصيات جسر أو أحداث تربط المكونات المنفصلة'
                })
        
        # 2. فحص عنق الزجاجة (Bottleneck)
        if nx.number_of_nodes(self.nx_graph) > 3:
            try:
                articulation_points = list(nx.articulation_points(self.nx_graph))
                if articulation_points:
                    for ap in articulation_points:
                        char_name = self.nx_graph.nodes[ap].get('name', ap)
                        issues.append({
                            'type': 'bottleneck_character',
                            'severity': 'medium',
                            'description': f'الشخصية "{char_name}" تمثل نقطة اختناق في الشبكة',
                            'affected_entities': {
                                'character_id': ap,
                                'character_name': char_name
                            },
                            'potential_impact': 'إزالة هذه الشخصية ستفصل الشبكة',
                            'recommendation': 'إضافة اتصالات بديلة لتقليل الاعتماد على هذه الشخصية'
                        })
            except Exception as e:
                logger.warning(f"Could not calculate articulation points: {e}")
        
        # 3. فحص الصراعات بدون مخرج (Dead-end)
        for conflict_id, conflict in self.network.conflicts.items():
            if conflict.phase == ConflictPhase.STALEMATE:
                # فحص إذا كان الصراع في حالة جمود منذ فترة طويلة
                if conflict.timestamps and len(conflict.timestamps) > 0:
                    last_update = conflict.timestamps[-1] if isinstance(conflict.timestamps[-1], datetime) else datetime.now()
                    days_stale = (datetime.now() - last_update).days
                    
                    if days_stale > 30:  # أكثر من شهر بدون تطور
                        issues.append({
                            'type': 'dead_end_conflict',
                            'severity': 'low',
                            'description': f'الصراع "{conflict.name}" في حالة جمود منذ {days_stale} يوم',
                            'affected_entities': {
                                'conflict_id': conflict_id,
                                'conflict_name': conflict.name,
                                'days_stale': days_stale
                            },
                            'potential_impact': 'قد يفقد القارئ/المشاهد الاهتمام بهذا الخط السردي',
                            'recommendation': 'إضافة نقطة تحول أو تصعيد للصراع'
                        })
        
        return issues
    
    def _identify_isolated_characters(self) -> List[Dict[str, Any]]:
        """
        تحديد الشخصيات المعزولة أو ضعيفة الاتصال
        
        Returns:
            قائمة بالشخصيات المعزولة
        """
        isolated = []
        
        for char_id, character in self.network.characters.items():
            # حساب عدد الاتصالات
            if char_id in self.nx_graph:
                degree = self.nx_graph.degree(char_id)
                
                # شخصية معزولة تماماً
                if degree == 0:
                    isolated.append({
                        'character_id': char_id,
                        'character_name': character.name,
                        'isolation_type': 'completely_isolated',
                        'connection_count': 0,
                        'suggested_connections': self._suggest_connections(char_id),
                        'severity': 'high',
                        'recommendation': 'دمج الشخصية في الشبكة أو إزالتها من القصة'
                    })
                
                # شخصية ضعيفة الاتصال
                elif degree == 1:
                    isolated.append({
                        'character_id': char_id,
                        'character_name': character.name,
                        'isolation_type': 'weakly_connected',
                        'connection_count': 1,
                        'suggested_connections': self._suggest_connections(char_id),
                        'severity': 'medium',
                        'recommendation': 'إضافة علاقات إضافية لتعزيز دور الشخصية'
                    })
            else:
                # الشخصية غير موجودة في الرسم البياني (خطأ بيانات)
                isolated.append({
                    'character_id': char_id,
                    'character_name': character.name,
                    'isolation_type': 'not_in_graph',
                    'connection_count': 0,
                    'suggested_connections': [],
                    'severity': 'critical',
                    'recommendation': 'مراجعة بيانات الشخصية - قد تكون خطأ في البناء'
                })
        
        return isolated
    
    def _identify_abandoned_conflicts(self) -> List[Dict[str, Any]]:
        """
        تحديد الصراعات المهملة أو التي لم تتطور
        
        Returns:
            قائمة بالصراعات المهملة
        """
        abandoned = []
        now = datetime.now()
        
        for conflict_id, conflict in self.network.conflicts.items():
            issue_detected = False
            issue_type = None
            days_inactive = 0
            
            # 1. صراع بدون تطور زمني
            if not conflict.timestamps or len(conflict.timestamps) <= 1:
                issue_detected = True
                issue_type = 'no_progression'
                days_inactive = -1  # غير معروف
            
            # 2. صراع عالق في مرحلة معينة
            elif len(conflict.timestamps) > 1:
                last_update = conflict.timestamps[-1] if isinstance(conflict.timestamps[-1], datetime) else datetime.now()
                days_inactive = (now - last_update).days
                
                if days_inactive > 45 and conflict.phase in [ConflictPhase.LATENT, ConflictPhase.STALEMATE]:
                    issue_detected = True
                    issue_type = 'stuck_in_phase'
            
            # 3. صراع بمشاركة غير كافية
            if len(conflict.involved_characters) < 2:
                issue_detected = True
                issue_type = 'insufficient_involvement'
            
            if issue_detected:
                abandoned.append({
                    'conflict_id': conflict_id,
                    'conflict_name': conflict.name,
                    'issue_type': issue_type,
                    'current_phase': conflict.phase.name if hasattr(conflict.phase, 'name') else str(conflict.phase),
                    'days_inactive': days_inactive,
                    'involved_characters_count': len(conflict.involved_characters),
                    'severity': 'high' if issue_type == 'no_progression' else 'medium',
                    'suggested_actions': self._suggest_conflict_revival(conflict, issue_type),
                    'recommendation': f'إعادة تنشيط الصراع بـ{self._get_revival_strategy(issue_type)}'
                })
        
        return abandoned
    
    def _identify_overloaded_characters(self) -> List[Dict[str, Any]]:
        """
        تحديد الشخصيات المحملة بعدد كبير من العلاقات والصراعات
        
        Returns:
            قائمة بالشخصيات المحملة
        """
        overloaded = []
        
        # حساب متوسط المشاركة
        total_chars = len(self.network.characters)
        if total_chars == 0:
            return overloaded
        
        total_relationships = len(self.network.relationships)
        total_conflicts = len(self.network.conflicts)
        
        avg_relationships_per_char = total_relationships / total_chars if total_chars > 0 else 0
        avg_conflicts_per_char = total_conflicts / total_chars if total_chars > 0 else 0
        
        # حد التحميل الزائد: 2x المتوسط
        overload_threshold_rel = avg_relationships_per_char * 2
        overload_threshold_conf = avg_conflicts_per_char * 2
        
        for char_id, character in self.network.characters.items():
            # عد العلاقات
            rel_count = sum(1 for rel in self.network.relationships.values() 
                           if rel.source == char_id or rel.target == char_id)
            
            # عد الصراعات
            conf_count = sum(1 for conf in self.network.conflicts.values() 
                            if char_id in conf.involved_characters)
            
            # حساب درجة التحميل
            overload_score = (rel_count / max(avg_relationships_per_char, 1)) + \
                           (conf_count / max(avg_conflicts_per_char, 1))
            
            if rel_count > overload_threshold_rel or conf_count > overload_threshold_conf:
                overloaded.append({
                    'character_id': char_id,
                    'character_name': character.name,
                    'relationship_count': rel_count,
                    'conflict_count': conf_count,
                    'overload_score': overload_score,
                    'severity': 'high' if overload_score > 4 else 'medium',
                    'suggested_redistribution': self._suggest_load_redistribution(
                        char_id, rel_count, conf_count
                    ),
                    'recommendation': f'إعادة توزيع {int(rel_count * 0.3)} علاقة و {int(conf_count * 0.2)} صراع'
                })
        
        return overloaded
    
    def _identify_weak_connections(self) -> List[Dict[str, Any]]:
        """
        تحديد الاتصالات الضعيفة (علاقات ضعيفة أو روابط صراع هشة)
        
        Returns:
            قائمة بالاتصالات الضعيفة
        """
        weak = []
        
        # فحص العلاقات الضعيفة
        for rel_id, relationship in self.network.relationships.items():
            if relationship.strength <= 3:  # قوة ضعيفة (1-3 من 10)
                char1 = self.network.characters.get(relationship.source)
                char2 = self.network.characters.get(relationship.target)
                
                if char1 and char2:
                    weak.append({
                        'connection_id': rel_id,
                        'connection_type': 'relationship',
                        'entities': [char1.name, char2.name],
                        'entity_ids': [relationship.source, relationship.target],
                        'strength_score': relationship.strength,
                        'severity': 'low',
                        'reason_for_weakness': 'علاقة ضعيفة قد لا تدعم الصراع بشكل فعال',
                        'suggested_strengthening': f'تعزيز العلاقة بين {char1.name} و {char2.name} من خلال مشاهد تفاعلية إضافية'
                    })
        
        # فحص روابط الصراع الضعيفة
        for conflict_id, conflict in self.network.conflicts.items():
            if conflict.strength <= 4 and conflict.phase not in [ConflictPhase.RESOLUTION, ConflictPhase.AFTERMATH]:
                weak.append({
                    'connection_id': conflict_id,
                    'connection_type': 'conflict',
                    'entities': conflict.involved_characters[:3],  # أول 3 شخصيات
                    'entity_ids': conflict.involved_characters[:3],
                    'strength_score': conflict.strength,
                    'severity': 'medium' if conflict.strength <= 2 else 'low',
                    'reason_for_weakness': f'صراع "{conflict.name}" بقوة منخفضة ({conflict.strength}/10)',
                    'suggested_strengthening': f'تصعيد الصراع وزيادة المخاطر المرتبطة به'
                })
        
        return weak
    
    def _identify_redundancies(self) -> List[Dict[str, Any]]:
        """
        تحديد التكرارات والازدواجية في العلاقات والصراعات
        
        Returns:
            قائمة بمشاكل التكرار
        """
        redundancies = []
        
        # فحص العلاقات المكررة
        relationship_pairs = defaultdict(list)
        for rel_id, rel in self.network.relationships.items():
            pair = tuple(sorted([rel.source, rel.target]))
            relationship_pairs[pair].append((rel_id, rel))
        
        for pair, rels in relationship_pairs.items():
            if len(rels) > 1:
                char1 = self.network.characters.get(pair[0])
                char2 = self.network.characters.get(pair[1])
                
                if char1 and char2:
                    redundancies.append({
                        'type': 'duplicate_relationships',
                        'entities': [char1.name, char2.name],
                        'entity_ids': list(pair),
                        'duplicate_count': len(rels),
                        'similarity_score': 0.85,  # افتراضي
                        'severity': 'low',
                        'suggested_merge': f'دمج {len(rels)} علاقات بين {char1.name} و {char2.name} في علاقة واحدة معقدة',
                        'recommendation': 'الاحتفاظ بالعلاقة الأقوى ودمج خصائص الأخريات'
                    })
        
        # فحص الصراعات المتشابهة
        conflicts_list = list(self.network.conflicts.items())
        for i in range(len(conflicts_list)):
            for j in range(i + 1, len(conflicts_list)):
                conf1_id, conf1 = conflicts_list[i]
                conf2_id, conf2 = conflicts_list[j]
                
                # حساب التشابه بناءً على الشخصيات المشتركة والموضوع
                shared_chars = set(conf1.involved_characters) & set(conf2.involved_characters)
                similarity = len(shared_chars) / max(len(conf1.involved_characters), len(conf2.involved_characters), 1)
                
                if similarity > 0.6 and conf1.subject == conf2.subject:
                    redundancies.append({
                        'type': 'overlapping_conflicts',
                        'entities': [conf1.name, conf2.name],
                        'entity_ids': [conf1_id, conf2_id],
                        'similarity_score': similarity,
                        'shared_characters': len(shared_chars),
                        'severity': 'medium',
                        'suggested_merge': f'دمج الصراعين "{conf1.name}" و "{conf2.name}" في صراع واحد أكثر تعقيداً',
                        'recommendation': 'تبسيط البنية بدمج الصراعات المتداخلة'
                    })
        
        return redundancies
    
    def _calculate_health_score(self) -> float:
        """
        حساب درجة صحة الشبكة الإجمالية (0-100)
        
        Returns:
            درجة الصحة من 0 إلى 100
        """
        score = 100.0
        
        # خصم نقاط للمشاكل الهيكلية
        for issue in self.structural_issues:
            if issue['severity'] == 'critical':
                score -= 15
            elif issue['severity'] == 'high':
                score -= 10
            elif issue['severity'] == 'medium':
                score -= 5
            else:
                score -= 2
        
        # خصم نقاط للشخصيات المعزولة
        score -= len(self.isolated_characters) * 3
        
        # خصم نقاط للصراعات المهملة
        score -= len(self.abandoned_conflicts) * 5
        
        # خصم نقاط للشخصيات المحملة
        score -= len(self.overloaded_characters) * 4
        
        # خصم نقاط للاتصالات الضعيفة
        score -= len(self.weak_connections) * 1
        
        # خصم نقاط للتكرارات
        score -= len(self.redundancy_issues) * 2
        
        return max(0.0, min(100.0, score))
    
    def _determine_criticality_level(self, health_score: float) -> str:
        """
        تحديد مستوى الخطورة بناءً على درجة الصحة
        
        Args:
            health_score: درجة الصحة (0-100)
            
        Returns:
            مستوى الخطورة
        """
        if health_score >= 80:
            return 'healthy'
        elif health_score >= 60:
            return 'minor_issues'
        elif health_score >= 40:
            return 'moderate_issues'
        elif health_score >= 20:
            return 'major_issues'
        else:
            return 'critical'
    
    def _suggest_connections(self, char_id: str) -> List[str]:
        """
        اقتراح اتصالات ممكنة لشخصية معزولة
        
        Args:
            char_id: معرّف الشخصية
            
        Returns:
            قائمة باقتراحات الاتصال
        """
        suggestions = []
        
        # اقتراح الاتصال مع الشخصيات المركزية
        if self.nx_graph.number_of_nodes() > 0:
            try:
                centrality = nx.degree_centrality(self.nx_graph)
                top_central = sorted(centrality.items(), key=lambda x: x[1], reverse=True)[:3]
                
                for central_char_id, _ in top_central:
                    if central_char_id != char_id:
                        char_name = self.nx_graph.nodes[central_char_id].get('name', central_char_id)
                        suggestions.append(f'ربط مع الشخصية المركزية: {char_name}')
            except:
                pass
        
        if not suggestions:
            suggestions.append('إضافة علاقة مع أي شخصية رئيسية في القصة')
        
        return suggestions
    
    def _suggest_conflict_revival(self, conflict: Conflict, issue_type: str) -> List[str]:
        """
        اقتراح طرق لإحياء صراع مهمل
        
        Args:
            conflict: الصراع المهمل
            issue_type: نوع المشكلة
            
        Returns:
            قائمة بالاقتراحات
        """
        suggestions = []
        
        if issue_type == 'no_progression':
            suggestions.extend([
                'إضافة نقطة تحول محورية تغير ديناميكية الصراع',
                'إدخال معلومة جديدة أو حدث خارجي يصعّد الموقف',
                'تغيير توازن القوى بين الأطراف المتصارعة'
            ])
        
        elif issue_type == 'stuck_in_phase':
            suggestions.extend([
                f'الانتقال من مرحلة {conflict.phase.name} إلى مرحلة أكثر ديناميكية',
                'إضافة ضغط زمني أو مهلة نهائية',
                'إدخال شخصية أو عنصر جديد لكسر الجمود'
            ])
        
        elif issue_type == 'insufficient_involvement':
            suggestions.extend([
                'إضافة شخصيات داعمة للصراع',
                'توسيع نطاق الصراع ليشمل المزيد من الشخصيات',
                'ربط الصراع بخطوط سردية أخرى'
            ])
        
        return suggestions
    
    def _get_revival_strategy(self, issue_type: str) -> str:
        """
        الحصول على استراتيجية إحياء مختصرة
        
        Args:
            issue_type: نوع المشكلة
            
        Returns:
            استراتيجية الإحياء
        """
        strategies = {
            'no_progression': 'إضافة نقطة تحول أو تصعيد',
            'stuck_in_phase': 'تغيير المرحلة أو إدخال عنصر خارجي',
            'insufficient_involvement': 'إضافة شخصيات أو توسيع النطاق'
        }
        return strategies.get(issue_type, 'إعادة تقييم دور الصراع في القصة')
    
    def _suggest_load_redistribution(
        self, 
        char_id: str, 
        rel_count: int, 
        conf_count: int
    ) -> List[str]:
        """
        اقتراح إعادة توزيع الحمل من شخصية محملة
        
        Args:
            char_id: معرّف الشخصية
            rel_count: عدد العلاقات
            conf_count: عدد الصراعات
            
        Returns:
            قائمة باقتراحات إعادة التوزيع
        """
        suggestions = []
        character = self.network.characters.get(char_id)
        
        if character:
            if rel_count > 5:
                suggestions.append(
                    f'نقل {int(rel_count * 0.3)} علاقات إلى شخصيات داعمة جديدة'
                )
            
            if conf_count > 3:
                suggestions.append(
                    f'توزيع {int(conf_count * 0.25)} صراعات على شخصيات أخرى'
                )
            
            suggestions.append(
                'إنشاء شخصيات ثانوية لتخفيف الحمل الدرامي'
            )
        
        return suggestions
    
    def _generate_diagnostic_summary(
        self, 
        health_score: float, 
        criticality_level: str
    ) -> str:
        """
        توليد ملخص تشخيصي شامل
        
        Args:
            health_score: درجة الصحة
            criticality_level: مستوى الخطورة
            
        Returns:
            نص الملخص
        """
        summary_parts = [
            f"تقييم الشبكة: {health_score:.1f}/100 ({criticality_level})",
            f"\nعدد المشاكل المكتشفة:",
            f"  • مشاكل هيكلية: {len(self.structural_issues)}",
            f"  • شخصيات معزولة: {len(self.isolated_characters)}",
            f"  • صراعات مهملة: {len(self.abandoned_conflicts)}",
            f"  • شخصيات محملة: {len(self.overloaded_characters)}",
            f"  • اتصالات ضعيفة: {len(self.weak_connections)}",
            f"  • مشاكل تكرار: {len(self.redundancy_issues)}"
        ]
        
        # التوصية الرئيسية
        if criticality_level == 'critical':
            summary_parts.append(
                "\n⚠️ تحذير: الشبكة في حالة حرجة وتحتاج إلى مراجعة شاملة فورية"
            )
        elif criticality_level == 'major_issues':
            summary_parts.append(
                "\n⚠️ تنبيه: توجد مشاكل كبيرة تتطلب معالجة قبل المتابعة"
            )
        elif criticality_level == 'moderate_issues':
            summary_parts.append(
                "\n✓ الشبكة في حالة جيدة مع بعض المجالات للتحسين"
            )
        else:
            summary_parts.append(
                "\n✓ الشبكة في حالة صحية ممتازة"
            )
        
        return '\n'.join(summary_parts)


# دالة مساعدة للاستخدام السريع
def diagnose_network(network: ConflictNetwork) -> Dict[str, Any]:
    """
    دالة مساعدة لتشغيل التشخيص الكامل على شبكة
    
    Args:
        network: شبكة الصراع المراد تحليلها
        
    Returns:
        تقرير تشخيصي شامل
    """
    diagnostics = NetworkDiagnostics(network)
    return diagnostics.run_all_diagnostics()

    """
وحدة استراتيجيات العلاج والتحسين
===================================
تقدم حلولاً عملية ومنهجية لمعالجة المشاكل المكتشفة في شبكة الصراع
وتحسين جودة السرد الدرامي.

المؤلف: نظام تحليل النصوص الدرامية  
الإصدار: 2.0.0 (Production Ready)
"""

import logging
from typing import Dict, List, Any, Optional, Set, Tuple
from collections import defaultdict
from datetime import datetime

from core.base_entities import (
    ConflictNetwork,
    Conflict,
    Character,
    Relationship,
    ConflictPhase,
    ConflictSubject,
    RelationshipType,
    RelationshipNature
)

logger = logging.getLogger(__name__)


class TreatmentStrategies:
    """
    محلل ومولد استراتيجيات العلاج للشبكات الدرامية
    
    يقدم:
    - إجراءات ذات أولوية عالية للمشاكل الحرجة
    - إصلاحات سريعة قابلة للتنفيذ الفوري
    - مراجعات هيكلية شاملة
    - اقتراحات لتطوير الشخصيات
    - استراتيجيات لتعزيز الصراعات
    """
    
    def __init__(
        self, 
        network: ConflictNetwork,
        diagnostics_report: Optional[Dict[str, Any]] = None
    ):
        """
        تهيئة محلل استراتيجيات العلاج
        
        Args:
            network: شبكة الصراع
            diagnostics_report: تقرير التشخيص (اختياري)
        """
        self.network = network
        self.diagnostics_report = diagnostics_report or {}
        
        # نتائج التحليل
        self.prioritized_actions: List[Dict[str, Any]] = []
        self.quick_fixes: List[Dict[str, Any]] = []
        self.structural_revisions: List[Dict[str, Any]] = []
        self.character_suggestions: List[Dict[str, Any]] = []
        self.conflict_strategies: List[Dict[str, Any]] = []
        
        logger.info(f"TreatmentStrategies initialized for: {network.name}")
    
    def analyze_and_recommend_treatments(self) -> Dict[str, Any]:
        """
        تحليل شامل وتوليد جميع التوصيات العلاجية
        
        Returns:
            مجموعة شاملة من استراتيجيات العلاج
        """
        logger.info("="*60)
        logger.info("Generating comprehensive treatment strategies...")
        logger.info("="*60)
        
        # 1. تحديد الإجراءات ذات الأولوية
        self.prioritized_actions = self._generate_prioritized_actions()
        logger.info(f"✓ Prioritized actions generated: {len(self.prioritized_actions)}")
        
        # 2. إنشاء إصلاحات سريعة
        self.quick_fixes = self._generate_quick_fixes()
        logger.info(f"✓ Quick fixes identified: {len(self.quick_fixes)}")
        
        # 3. اقتراح مراجعات هيكلية
        self.structural_revisions = self._plan_structural_revisions()
        logger.info(f"✓ Structural revisions planned: {len(self.structural_revisions)}")
        
        # 4. اقتراحات تطوير الشخصيات
        self.character_suggestions = self._develop_character_suggestions()
        logger.info(f"✓ Character development suggestions: {len(self.character_suggestions)}")
        
        # 5. استراتيجيات تعزيز الصراعات
        self.conflict_strategies = self._enhance_conflict_strategies()
        logger.info(f"✓ Conflict enhancement strategies: {len(self.conflict_strategies)}")
        
        # 6. إنشاء ملخص موحد
        consolidated_summary = self._create_consolidated_summary()
        
        logger.info("="*60)
        logger.info("Treatment strategies generation completed")
        logger.info("="*60)
        
        return {
            'prioritized_actions': self.prioritized_actions,
            'quick_fixes': self.quick_fixes,
            'structural_revisions': self.structural_revisions,
            'character_development_suggestions': self.character_suggestions,
            'conflict_enhancement_strategies': self.conflict_strategies,
            'consolidated_summary': consolidated_summary,
            'total_recommendations': (
                len(self.prioritized_actions) + 
                len(self.quick_fixes) + 
                len(self.structural_revisions) +
                len(self.character_suggestions) +
                len(self.conflict_strategies)
            ),
            'implementation_roadmap': self._create_implementation_roadmap()
        }
    
    def _generate_prioritized_actions(self) -> List[Dict[str, Any]]:
        """
        توليد قائمة بالإجراءات مرتبة حسب الأولوية
        
        Returns:
            قائمة الإجراءات ذات الأولوية
        """
        actions = []
        
        # من المشاكل الهيكلية
        structural_issues = self.diagnostics_report.get('structural_issues', [])
        for issue in structural_issues:
            priority = self._map_severity_to_priority(issue.get('severity', 'low'))
            
            actions.append({
                'priority': priority,
                'action_type': 'structural_fix',
                'target_entity': {
                    'type': 'network_structure',
                    'issue_type': issue.get('type'),
                    'description': issue.get('description')
                },
                'description': issue.get('recommendation', 'معالجة المشكلة الهيكلية'),
                'expected_impact': issue.get('potential_impact', 'تحسين التماسك السردي'),
                'effort': self._estimate_effort(issue.get('type')),
                'estimated_time': self._estimate_time(issue.get('type')),
                'risk_level': 'low'
            })
        
        # من الشخصيات المعزولة
        isolated_chars = self.diagnostics_report.get('isolated_characters', {}).get('characters', [])
        for char_issue in isolated_chars:
            if char_issue.get('isolation_type') == 'completely_isolated':
                actions.append({
                    'priority': 'high',
                    'action_type': 'integrate_character',
                    'target_entity': {
                        'type': 'character',
                        'id': char_issue.get('character_id'),
                        'name': char_issue.get('character_name')
                    },
                    'description': f"دمج الشخصية المعزولة '{char_issue.get('character_name')}' في الشبكة",
                    'expected_impact': 'تعزيز التماسك السردي وإثراء الديناميكيات',
                    'effort': 'medium',
                    'estimated_time': '2-4 ساعات',
                    'risk_level': 'low',
                    'specific_suggestions': char_issue.get('suggested_connections', [])
                })
        
        # من الصراعات المهملة
        abandoned_conflicts = self.diagnostics_report.get('abandoned_conflicts', {}).get('conflicts', [])
        for conf_issue in abandoned_conflicts:
            actions.append({
                'priority': 'high' if conf_issue.get('issue_type') == 'no_progression' else 'medium',
                'action_type': 'revive_conflict',
                'target_entity': {
                    'type': 'conflict',
                    'id': conf_issue.get('conflict_id'),
                    'name': conf_issue.get('conflict_name')
                },
                'description': f"إحياء الصراع المهمل '{conf_issue.get('conflict_name')}'",
                'expected_impact': 'استعادة الزخم السردي وتجديد الاهتمام',
                'effort': 'medium',
                'estimated_time': '3-6 ساعات',
                'risk_level': 'medium',
                'specific_suggestions': conf_issue.get('suggested_actions', [])
            })
        
        # من الشخصيات المحملة
        overloaded_chars = self.diagnostics_report.get('overloaded_characters', {}).get('characters', [])
        for char_issue in overloaded_chars:
            actions.append({
                'priority': 'medium',
                'action_type': 'redistribute_load',
                'target_entity': {
                    'type': 'character',
                    'id': char_issue.get('character_id'),
                    'name': char_issue.get('character_name')
                },
                'description': f"إعادة توزيع الحمل عن '{char_issue.get('character_name')}'",
                'expected_impact': 'تحسين التوازن السردي وتطوير شخصيات ثانوية',
                'effort': 'high',
                'estimated_time': '4-8 ساعات',
                'risk_level': 'medium',
                'specific_suggestions': char_issue.get('suggested_redistribution', [])
            })
        
        # ترتيب حسب الأولوية
        priority_order = {'critical': 0, 'high': 1, 'medium': 2, 'low': 3}
        actions.sort(key=lambda x: priority_order.get(x['priority'], 99))
        
        return actions
    
    def _generate_quick_fixes(self) -> List[Dict[str, Any]]:
        """
        توليد إصلاحات سريعة قابلة للتنفيذ الفوري
        
        Returns:
            قائمة الإصلاحات السريعة
        """
        fixes = []
        
        # إصلاحات للاتصالات الضعيفة
        weak_connections = self.diagnostics_report.get('weak_connections', {}).get('connections', [])
        for weak in weak_connections:
            if weak.get('connection_type') == 'relationship':
                fixes.append({
                    'issue_id': weak.get('connection_id'),
                    'fix_type': 'strengthen_relationship',
                    'description': weak.get('suggested_strengthening'),
                    'implementation': (
                        f"1. تحديد العلاقة: {weak.get('connection_id')}\n"
                        f"2. زيادة قيمة strength من {weak.get('strength_score')} إلى 6-7\n"
                        f"3. إضافة مشاهد تفاعلية بين الشخصيات\n"
                        f"4. تعميق الدوافع المشتركة"
                    ),
                    'estimated_time': '30-60 دقيقة',
                    'impact': 'متوسط',
                    'complexity': 'منخفض'
                })
            
            elif weak.get('connection_type') == 'conflict':
                fixes.append({
                    'issue_id': weak.get('connection_id'),
                    'fix_type': 'intensify_conflict',
                    'description': f"تكثيف الصراع الضعيف ({weak.get('strength_score')}/10)",
                    'implementation': (
                        f"1. تحديد الصراع: {weak.get('connection_id')}\n"
                        f"2. رفع درجة strength إلى 6-8\n"
                        f"3. إضافة مخاطر أو عواقب أكبر\n"
                        f"4. زيادة التوتر بين الأطراف المتصارعة"
                    ),
                    'estimated_time': '1-2 ساعة',
                    'impact': 'عالي',
                    'complexity': 'متوسط'
                })
        
        # إصلاحات للتكرارات
        redundancies = self.diagnostics_report.get('redundancy_issues', {}).get('issues', [])
        for redundancy in redundancies:
            if redundancy.get('type') == 'duplicate_relationships':
                fixes.append({
                    'issue_id': f"redundancy_{redundancy.get('entity_ids', ['unknown'])[0]}",
                    'fix_type': 'merge_duplicates',
                    'description': redundancy.get('suggested_merge'),
                    'implementation': (
                        f"1. مراجعة العلاقات المكررة بين: {', '.join(redundancy.get('entities', []))}\n"
                        f"2. اختيار العلاقة الأقوى كأساس\n"
                        f"3. دمج خصائص العلاقات الأخرى\n"
                        f"4. حذف العلاقات المكررة"
                    ),
                    'estimated_time': '15-30 دقيقة',
                    'impact': 'منخفض',
                    'complexity': 'منخفض'
                })
        
        return fixes
    
    def _plan_structural_revisions(self) -> List[Dict[str, Any]]:
        """
        تخطيط مراجعات هيكلية شاملة
        
        Returns:
            قائمة المراجعات الهيكلية
        """
        revisions = []
        
        # معالجة المكونات المنفصلة
        structural_issues = self.diagnostics_report.get('structural_issues', [])
        for issue in structural_issues:
            if issue.get('type') == 'disconnected_components':
                components = issue.get('affected_entities', {}).get('components', [])
                
                revisions.append({
                    'revision_type': 'bridge_disconnected_components',
                    'scope': 'network-wide',
                    'description': f'ربط {len(components)} مكونات منفصلة في الشبكة',
                    'rationale': 'تحسين التماسك السردي ووحدة القصة',
                    'steps': [
                        f'تحديد المكونات المنفصلة: {len(components)} مكونات',
                        'تحليل الثيمات والموضوعات المشتركة بين المكونات',
                        'إنشاء شخصية جسر (Bridge Character) أو حدث محوري',
                        'ربط المكونات من خلال علاقات أو صراعات مشتركة',
                        'التحقق من تحسن التماسك الشبكي'
                    ],
                    'affected_elements': [
                        comp[0] if isinstance(comp, list) and len(comp) > 0 else 'unknown'
                        for comp in components
                    ],
                    'expected_outcome': 'شبكة موحدة ومتماسكة بدون مكونات معزولة',
                    'effort': 'high',
                    'estimated_duration': '1-2 أسابيع',
                    'risk_assessment': {
                        'probability': 'medium',
                        'impact': 'high',
                        'mitigation': 'إنشاء نقاط ربط طبيعية تتماشى مع الثيمات الموجودة'
                    }
                })
            
            elif issue.get('type') == 'bottleneck_character':
                char_name = issue.get('affected_entities', {}).get('character_name')
                
                revisions.append({
                    'revision_type': 'redistribute_from_bottleneck',
                    'scope': 'character-centric',
                    'description': f'إعادة توزيع الاعتماد على الشخصية المحورية: {char_name}',
                    'rationale': 'تقليل نقاط الاختناق وزيادة مرونة الشبكة',
                    'steps': [
                        f'تحديد جميع الاتصالات التي تمر عبر {char_name}',
                        'إنشاء مسارات بديلة بين الشخصيات الأخرى',
                        'تطوير شخصيات ثانوية لتحمل بعض الأدوار',
                        'الحفاظ على أهمية الشخصية دون جعلها نقطة اختناق'
                    ],
                    'affected_elements': [char_name] if char_name else [],
                    'expected_outcome': 'شبكة أكثر مرونة مع توزيع أفضل للأدوار',
                    'effort': 'medium',
                    'estimated_duration': '3-5 أيام',
                    'risk_assessment': {
                        'probability': 'low',
                        'impact': 'medium',
                        'mitigation': 'الحفاظ على دور الشخصية الأساسي'
                    }
                })
        
        # معالجة التكرارات الكبيرة
        redundancies = self.diagnostics_report.get('redundancy_issues', {}).get('issues', [])
        if len(redundancies) > 3:
            revisions.append({
                'revision_type': 'consolidate_redundancies',
                'scope': 'network-wide',
                'description': 'دمج وتبسيط العناصر المكررة في الشبكة',
                'rationale': 'تقليل التعقيد غير الضروري وتحسين الوضوح',
                'steps': [
                    f'مراجعة جميع {len(redundancies)} حالة تكرار',
                    'تحديد العناصر الأساسية لكل مجموعة مكررة',
                    'دمج العناصر المتشابهة في كيانات أكثر تعقيداً',
                    'إعادة توزيع الشخصيات والأدوار',
                    'التحقق من الحفاظ على الأهمية السردية'
                ],
                'affected_elements': [
                    r.get('entities', ['unknown'])[0] for r in redundancies[:5]
                ],
                'expected_outcome': 'بنية أبسط وأكثر وضوحاً',
                'effort': 'medium',
                'estimated_duration': '4-7 أيام',
                'risk_assessment': {
                    'probability': 'low',
                    'impact': 'medium',
                    'mitigation': 'الدمج التدريجي مع اختبار الأثر'
                }
            })
        
        return revisions
    
    def _develop_character_suggestions(self) -> List[Dict[str, Any]]:
        """
        تطوير اقتراحات لتحسين الشخصيات
        
        Returns:
            قائمة اقتراحات تطوير الشخصيات
        """
        suggestions = []
        
        # للشخصيات المعزولة
        isolated_chars = self.diagnostics_report.get('isolated_characters', {}).get('characters', [])
        for char_issue in isolated_chars:
            character = self.network.characters.get(char_issue.get('character_id'))
            
            if character:
                suggestions.append({
                    'character_id': char_issue.get('character_id'),
                    'character_name': char_issue.get('character_name'),
                    'issue': char_issue.get('isolation_type'),
                    'development_focus': 'Integration and Relationship Building',
                    'suggested_actions': [
                        'إنشاء علاقة قوية مع شخصية محورية واحدة على الأقل',
                        'إضافة دافع شخصي يربط الشخصية بالصراع الرئيسي',
                        'تطوير قوس تحول يبرر دمجها في الشبكة',
                        'إضافة مشاهد تفاعلية مع شخصيات أخرى'
                    ],
                    'narrative_role_enhancement': 'تحويل الشخصية من عنصر معزول إلى جزء فاعل في الديناميكية',
                    'priority': 'high',
                    'estimated_scenes_needed': 3
                })
        
        # للشخصيات المحملة
        overloaded_chars = self.diagnostics_report.get('overloaded_characters', {}).get('characters', [])
        for char_issue in overloaded_chars:
            character = self.network.characters.get(char_issue.get('character_id'))
            
            if character:
                suggestions.append({
                    'character_id': char_issue.get('character_id'),
                    'character_name': char_issue.get('character_name'),
                    'issue': 'overload',
                    'development_focus': 'Load Distribution and Role Clarification',
                    'suggested_actions': [
                        'تحديد الأدوار الأساسية للشخصية بوضوح',
                        'نقل بعض المسؤوليات السردية لشخصيات داعمة',
                        'تطوير شخصيات ثانوية لتحمل بعض العلاقات والصراعات',
                        'التركيز على قوس التطور الأساسي للشخصية'
                    ],
                    'narrative_role_enhancement': 'تبسيط دور الشخصية لتحقيق عمق أكبر',
                    'priority': 'medium',
                    'estimated_new_characters_needed': 1
                })
        
        # اقتراحات عامة لتحسين الشخصيات
        all_characters = list(self.network.characters.values())
        for character in all_characters[:5]:  # أول 5 شخصيات
            # فحص إذا لم تكن معزولة أو محملة
            if not any(c.get('character_id') == character.id for c in isolated_chars + overloaded_chars):
                suggestions.append({
                    'character_id': character.id,
                    'character_name': character.name,
                    'issue': 'enhancement',
                    'development_focus': 'Depth and Complexity',
                    'suggested_actions': [
                        'إضافة طبقات إضافية للشخصية (ماضي، سر، صراع داخلي)',
                        'تطوير علاقة معقدة واحدة على الأقل',
                        'إضافة لحظات ضعف أو تناقض لجعل الشخصية أكثر إنسانية',
                        'ربط دوافع الشخصية بالثيمات الرئيسية للقصة'
                    ],
                    'narrative_role_enhancement': 'تعميق الشخصية وجعلها أكثر تذكراً',
                    'priority': 'low',
                    'estimated_scenes_needed': 2
                })
        
        return suggestions
    
    def _enhance_conflict_strategies(self) -> List[Dict[str, Any]]:
        """
        تطوير استراتيجيات لتعزيز الصراعات
        
        Returns:
            قائمة استراتيجيات تعزيز الصراعات
        """
        strategies = []
        
        # للصراعات المهملة
        abandoned_conflicts = self.diagnostics_report.get('abandoned_conflicts', {}).get('conflicts', [])
        for conf_issue in abandoned_conflicts:
            conflict = self.network.conflicts.get(conf_issue.get('conflict_id'))
            
            if conflict:
                strategies.append({
                    'conflict_id': conf_issue.get('conflict_id'),
                    'conflict_name': conf_issue.get('conflict_name'),
                    'current_status': conf_issue.get('issue_type'),
                    'enhancement_type': 'reactivation',
                    'proposed_actions': [
                        'إضافة نقطة تحول غير متوقعة',
                        'رفع المخاطر والعواقب',
                        'إدخال معلومة جديدة تغير التوازن',
                        f'الانتقال من مرحلة {conf_issue.get("current_phase")} إلى مرحلة أكثر ديناميكية'
                    ],
                    'target_phase': self._suggest_next_phase(conf_issue.get('current_phase')),
                    'target_strength': 7,
                    'priority': 'high',
                    'expected_dramatic_impact': 'استعادة الاهتمام وتصعيد التوتر'
                })
        
        # للصراعات الضعيفة
        weak_connections = self.diagnostics_report.get('weak_connections', {}).get('connections', [])
        for weak in weak_connections:
            if weak.get('connection_type') == 'conflict':
                conflict = self.network.conflicts.get(weak.get('connection_id'))
                
                if conflict:
                    strategies.append({
                        'conflict_id': weak.get('connection_id'),
                        'conflict_name': conflict.name,
                        'current_status': 'weak',
                        'enhancement_type': 'intensification',
                        'proposed_actions': [
                            f'رفع قوة الصراع من {weak.get("strength_score")} إلى 7-8',
                            'زيادة عدد الشخصيات المشاركة',
                            'ربط الصراع بثيمة رئيسية',
                            'إضافة عواقب شخصية لكل طرف متصارع'
                        ],
                        'target_phase': 'ESCALATING',
                        'target_strength': 8,
                        'priority': 'medium',
                        'expected_dramatic_impact': 'تعزيز التوتر الدرامي'
                    })
        
        # استراتيجيات عامة لتحسين الصراعات
        all_conflicts = list(self.network.conflicts.values())
        for conflict in all_conflicts[:3]:  # أول 3 صراعات
            if conflict.phase not in [ConflictPhase.CLIMAX, ConflictPhase.RESOLUTION]:
                strategies.append({
                    'conflict_id': conflict.id,
                    'conflict_name': conflict.name,
                    'current_status': 'active',
                    'enhancement_type': 'deepening',
                    'proposed_actions': [
                        'إضافة طبقة رمزية أو ثيمة أعمق للصراع',
                        'ربط الصراع بصراعات أخرى لخلق تعقيد',
                        'تطوير صراع داخلي لكل شخصية مشاركة',
                        'إضافة نقاط تحول صغيرة لإبقاء الصراع ديناميكياً'
                    ],
                    'target_phase': self._suggest_next_phase(conflict.phase.name if hasattr(conflict.phase, 'name') else str(conflict.phase)),
                    'target_strength': min(conflict.strength + 2, 10),
                    'priority': 'low',
                    'expected_dramatic_impact': 'تعميق الصراع وجعله أكثر تأثيراً'
                })
        
        return strategies
    
    def _create_consolidated_summary(self) -> str:
        """
        إنشاء ملخص موحد لجميع استراتيجيات العلاج
        
        Returns:
            نص الملخص
        """
        total_recommendations = (
            len(self.prioritized_actions) +
            len(self.quick_fixes) +
            len(self.structural_revisions) +
            len(self.character_suggestions) +
            len(self.conflict_strategies)
        )
        
        summary_parts = [
            "=" * 60,
            "ملخص استراتيجيات العلاج الموحد",
            "=" * 60,
            f"\nإجمالي التوصيات: {total_recommendations}",
            f"\n### الإجراءات ذات الأولوية ({len(self.prioritized_actions)}):",
        ]
        
        # ملخص الإجراءات الحرجة
        critical_actions = [a for a in self.prioritized_actions if a['priority'] == 'critical']
        high_actions = [a for a in self.prioritized_actions if a['priority'] == 'high']
        
        if critical_actions:
            summary_parts.append(f"  • إجراءات حرجة: {len(critical_actions)}")
        if high_actions:
            summary_parts.append(f"  • إجراءات عالية الأولوية: {len(high_actions)}")
        
        if self.quick_fixes:
            summary_parts.extend([
                f"\n### الإصلاحات السريعة ({len(self.quick_fixes)}):",
                "  • يمكن تنفيذها فوراً لتحسين سريع"
            ])
        
        if self.structural_revisions:
            summary_parts.extend([
                f"\n### المراجعات الهيكلية ({len(self.structural_revisions)}):",
                "  • تغييرات جوهرية لتحسين البنية"
            ])
        
        if self.character_suggestions:
            summary_parts.extend([
                f"\n### تطوير الشخصيات ({len(self.character_suggestions)}):",
                "  • اقتراحات لتعميق وتحسين الشخصيات"
            ])
        
        if self.conflict_strategies:
            summary_parts.extend([
                f"\n### تعزيز الصراعات ({len(self.conflict_strategies)}):",
                "  • استراتيجيات لتقوية الخطوط الدرامية"
            ])
        
        summary_parts.extend([
            "\n" + "=" * 60,
            "التوصية الرئيسية:",
            self._get_primary_recommendation(),
            "=" * 60
        ])
        
        return '\n'.join(summary_parts)
    
    def _create_implementation_roadmap(self) -> Dict[str, Any]:
        """
        إنشاء خارطة طريق للتنفيذ
        
        Returns:
            خارطة طريق منظمة
        """
        roadmap = {
            'phase_1_immediate': {
                'title': 'المرحلة 1: إجراءات فورية (1-3 أيام)',
                'actions': [],
                'focus': 'الإصلاحات السريعة والمشاكل الحرجة'
            },
            'phase_2_short_term': {
                'title': 'المرحلة 2: قصيرة الأمد (1-2 أسابيع)',
                'actions': [],
                'focus': 'المعالجات الهيكلية والشخصيات'
            },
            'phase_3_long_term': {
                'title': 'المرحلة 3: طويلة الأمد (2-4 أسابيع)',
                'actions': [],
                'focus': 'التعميق والصقل النهائي'
            }
        }
        
        # توزيع الإجراءات على المراحل
        for action in self.prioritized_actions:
            if action['priority'] in ['critical', 'high']:
                roadmap['phase_1_immediate']['actions'].append(action['description'])
        
        for fix in self.quick_fixes:
            roadmap['phase_1_immediate']['actions'].append(fix['description'])
        
        for revision in self.structural_revisions:
            roadmap['phase_2_short_term']['actions'].append(revision['description'])
        
        for suggestion in self.character_suggestions:
            if suggestion['priority'] == 'high':
                roadmap['phase_2_short_term']['actions'].append(
                    f"تطوير: {suggestion['character_name']}"
                )
            else:
                roadmap['phase_3_long_term']['actions'].append(
                    f"تعميق: {suggestion['character_name']}"
                )
        
        for strategy in self.conflict_strategies:
            if strategy['priority'] == 'high':
                roadmap['phase_2_short_term']['actions'].append(
                    f"إحياء: {strategy['conflict_name']}"
                )
            else:
                roadmap['phase_3_long_term']['actions'].append(
                    f"تعزيز: {strategy['conflict_name']}"
                )
        
        return roadmap
    
    def _map_severity_to_priority(self, severity: str) -> str:
        """
        تحويل مستوى الخطورة إلى أولوية
        
        Args:
            severity: مستوى الخطورة
            
        Returns:
            مستوى الأولوية
        """
        mapping = {
            'critical': 'critical',
            'high': 'high',
            'medium': 'medium',
            'low': 'low'
        }
        return mapping.get(severity, 'low')
    
    def _estimate_effort(self, issue_type: str) -> str:
        """
        تقدير مستوى الجهد المطلوب
        
        Args:
            issue_type: نوع المشكلة
            
        Returns:
            تقدير الجهد
        """
        effort_map = {
            'disconnected_components': 'high',
            'bottleneck_character': 'medium',
            'dead_end_conflict': 'medium',
            'completely_isolated': 'medium',
            'weakly_connected': 'low',
            'overload': 'high'
        }
        return effort_map.get(issue_type, 'medium')
    
    def _estimate_time(self, issue_type: str) -> str:
        """
        تقدير الوقت المطلوب
        
        Args:
            issue_type: نوع المشكلة
            
        Returns:
            تقدير الوقت
        """
        time_map = {
            'disconnected_components': '1-2 أسابيع',
            'bottleneck_character': '3-5 أيام',
            'dead_end_conflict': '2-4 أيام',
            'completely_isolated': '2-4 ساعات',
            'weakly_connected': '1-2 ساعة',
            'overload': '4-8 ساعات'
        }
        return time_map.get(issue_type, '2-4 ساعات')
    
    def _suggest_next_phase(self, current_phase: str) -> str:
        """
        اقتراح المرحلة التالية للصراع
        
        Args:
            current_phase: المرحلة الحالية
            
        Returns:
            المرحلة المقترحة
        """
        phase_progression = {
            'LATENT': 'EMERGING',
            'EMERGING': 'ESCALATING',
            'ESCALATING': 'CLIMAX',
            'STALEMATE': 'ESCALATING',
            'CLIMAX': 'DEESCALATING',
            'DEESCALATING': 'RESOLUTION',
            'RESOLUTION': 'AFTERMATH'
        }
        return phase_progression.get(current_phase, 'ESCALATING')
    
    def _get_primary_recommendation(self) -> str:
        """
        الحصول على التوصية الرئيسية
        
        Returns:
            نص التوصية
        """
        health_score = self.diagnostics_report.get('overall_health_score', 50)
        criticality = self.diagnostics_report.get('criticality_level', 'moderate_issues')
        
        if criticality == 'critical':
            return "الشبكة تحتاج إلى مراجعة شاملة فورية. ابدأ بالإجراءات الحرجة ثم الإصلاحات السريعة."
        elif criticality == 'major_issues':
            return "معالجة المشاكل الرئيسية أولاً، ثم التركيز على المراجعات الهيكلية."
        elif criticality == 'moderate_issues':
            return "الشبكة في حالة جيدة. ركز على التحسينات التدريجية والصقل."
        else:
            return "الشبكة في حالة ممتازة. استمر في التطوير والتعميق."


# دالة مساعدة للاستخدام السريع
def generate_treatments(
    network: ConflictNetwork,
    diagnostics_report: Optional[Dict[str, Any]] = None
) -> Dict[str, Any]:
    """
    دالة مساعدة لتوليد استراتيجيات العلاج
    
    Args:
        network: شبكة الصراع
        diagnostics_report: تقرير التشخيص (اختياري)
        
    Returns:
        استراتيجيات العلاج الشاملة
    """
    treatment = TreatmentStrategies(network, diagnostics_report)
    return treatment.analyze_and_recommend_treatments()

    